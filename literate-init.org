#+title: Конфигурация под ванильный Emacs
#+startup: content
#+startup: noindent

* Вводная

Уход с Doom на собственную конфигурацию с сохранением привычных
инструментов (успешно).

Цель - использовать новые версии Emacs, которые Doom не успевает
поддерживать.

*Как установить?*
1. Склонировать этот проект настроек в директорию ~/.config (или
   просто завести там ссылку).
2. Скопировать файл init.el в директорию ~/.emacs.d/ .
3. Запустить Emacs.
4. Дождаться установки пакетов. По ходу установки отвечать на вопросы
   утвердительно.
(Настройка сразу подтянет все, что нужно для дальнейшей работы, и
больше в интернет обращаться не будет.)

*Как перейти c Vim (EVIL) на стандартную раскладку Emacs?*
1. В разделе "[[id:44f272c6-5f95-440f-8a1f-1766fe438feb][Включение Evil по всему редактору]]" установить
   переменную my/evil в nil:
   : (setq my/evil nil)
2. Это все. Все раскладки должны сохраниться, а префикс-лидер к ним
   по-умолчанию станет =Ctrl-s=.

* Содержание                                                            :toc:
- [[#вводная][Вводная]]
- [[#lexical-binding-лексические-замыкания][Lexical-binding. Лексические замыкания]]
- [[#отладка][Отладка]]
- [[#общие-параметры-и-переменные-данной-конфигурации][Общие параметры и переменные данной конфигурации]]
  - [[#кодировка-по-умолчанию-utf-8][Кодировка по-умолчанию (utf-8)]]
  - [[#директория-файлов-конфигурации][Директория файлов конфигурации]]
  - [[#идентификация-пользователя-emacs][Идентификация пользователя Emacs]]
  - [[#включение-evil-по-всему-редактору][Включение Evil по всему редактору]]
- [[#подготовка-к-установке-пакетов-из-репозиториев][Подготовка к установке пакетов из репозиториев]]
- [[#пока-редактор-загружается-поправим-ему-внешний-вид][Пока редактор загружается, поправим ему внешний вид]]
  - [[#меню-и-панель-инструментов-menu-and-toolbar][Меню и панель инструментов (menu and toolbar)]]
  - [[#красивые-темы-и-установка-темы-по-умолчанию][Красивые темы и установка темы по-умолчанию]]
- [[#полезные-пакеты-вытащенные-из-сторонних-проектов][Полезные пакеты, вытащенные из сторонних проектов]]
  - [[#spacemacs][Spacemacs]]
- [[#среда][Среда]]
  - [[#сохранение-состояния-для-desktop][Сохранение состояния для Desktop]]
  - [[#удаление-файлов-и-бэкапы][Удаление файлов и бэкапы]]
  - [[#звуковой-сигнал-типа-гудок][Звуковой сигнал (типа "гудок")]]
  - [[#сборщик-мусора-gc][Сборщик мусора (GC)]]
- [[#evil-режим-редактирования][Evil. Режим редактирования]]
  - [[#установка-и-настройка][Установка и настройка]]
  - [[#general-назначение-клавиш-на-помощь-evil][General (назначение клавиш на помощь evil)]]
  - [[#настройка-поведения-клавиш-для-evil-mode-как-в-vim][Настройка поведения клавиш для evil-mode, как в Vim.]]
- [[#внешний-вид-ui-и-gui][Внешний вид UI и GUI]]
  - [[#автоматическая-установка-шрифтов][Автоматическая установка шрифтов]]
  - [[#установка-nerd-шрифтов-иконочки][Установка nerd-шрифтов (иконочки)]]
  - [[#мигание-курсора][Мигание курсора]]
  - [[#подсветка-строки-с-курсором][Подсветка строки с курсором]]
  - [[#прозрачность][Прозрачность]]
  - [[#настройка-статусной-панели-modeline][Настройка статусной панели (modeline)]]
  - [[#показ-объекта-внутри-которого-находится-курсор-header-line][Показ объекта внутри которого находится курсор (header-line)]]
  - [[#установка-текста-в-заголовке-основного-окна-фрейма][Установка текста в заголовке основного окна (фрейма)]]
  - [[#подсветка-кодов-цвета-соответствующим-цветом-rainbow-mode][Подсветка кодов цвета соответствующим цветом (rainbow mode)]]
  - [[#отказываемся-от-диалоговых-окон][Отказываемся от диалоговых окон]]
  - [[#тильды-в-конце-буффера][Тильды в конце буффера]]
  - [[#увеличение-и-уменьшение-шрифта-в-окне][Увеличение и уменьшение шрифта в окне]]
  - [[#настройка-окна-компиляции-compilation][Настройка окна компиляции (compilation)]]
- [[#регистры-и-операции-с-ними][Регистры и операции с ними]]
  - [[#общий-буфер-обмена-для-emacs-и-ос][Общий буфер обмена для Emacs и ОС]]
  - [[#быстрая-работа-с-регистрами--и-][Быстрая работа с регистрами `+' и `"']]
- [[#редактирование-текста-и-интерфейс-к-нему][Редактирование текста и интерфейс к нему]]
  - [[#общие-клавиши-для-редактирования-текста][Общие клавиши для редактирования текста]]
  - [[#follow-mode---просматриваем-непрерывный-текст-в-нескольких-буферах][Follow-mode - просматриваем непрерывный текст в нескольких буферах]]
  - [[#отмена-изменений-на-основе-дерева-undo-tree][Отмена изменений на основе дерева (undo-tree)]]
  - [[#прокручивание-текста][Прокручивание текста]]
  - [[#avy-перемещение-по-всему-редактору][Avy. Перемещение по всему редактору]]
  - [[#нумерация-строк][Нумерация строк]]
  - [[#wgrep-отслеживаем-не-сохраненное-во-всех-буферах][Wgrep. Отслеживаем не сохраненное во всех буферах]]
  - [[#автоотступ-indent][Автоотступ (indent)]]
  - [[#esc-кодирование-для-работы-с-url][ESC-кодирование для работы с URL]]
  - [[#более-привычная-раскладка-клавиш-для-evil-mode-ближе-к-vim-и-консоли][Более привычная раскладка клавиш для evil-mode (ближе к Vim и консоли)]]
  - [[#переключение-раскладки-клавиатуры][Переключение раскладки клавиатуры]]
  - [[#схлопывание-текста-yafolding][Схлопывание текста (yafolding)]]
  - [[#подсветка-отступов-highlight-indent-guides][Подсветка отступов (highlight-indent-guides)]]
  - [[#подсветка-отступов-indent-bars][Подсветка отступов (indent-bars)]]
  - [[#проверка-орфографии][Проверка орфографии]]
  - [[#сниппеты-yasnippet][Сниппеты (Yasnippet)]]
  - [[#закладки][Закладки]]
  - [[#работа-с-kill-ring][Работа с Kill-ring]]
  - [[#контекстное-меню-по-правой-клавише-мыши][Контекстное меню по правой клавише мыши]]
  - [[#выделение-прямоугольная-область-выделения-по-ctrl-и-клавише-мышки][Выделение. Прямоугольная область выделения по Ctrl и клавише мышки]]
- [[#подсказки-выпадашки-автодополнения][Подсказки, выпадашки, автодополнения]]
  - [[#ivy---меню-с-поиском-по-частичному-совпадению][Ivy - меню с поиском по частичному совпадению]]
  - [[#подсказки-на-клавиши][Подсказки на клавиши]]
  - [[#counsel-меню-вызова-функции-с-более-полным-описанием][Counsel. Меню вызова функции с более полным описанием]]
  - [[#company-автодополнения][Company. Автодополнения]]
  - [[#наполнение-полезным-содержимым-ivy-меню][Наполнение полезным содержимым ivy-меню]]
  - [[#некоторые-дополнения-пакетов][Некоторые дополнения пакетов]]
  - [[#клавиши-перемещения-по-минибуферу][Клавиши перемещения по минибуферу]]
- [[#поиск-и-выделение][Поиск и выделение]]
  - [[#swiper-удобный-живой-поиск-текста-по-открытому-буфферу][Swiper. Удобный живой поиск текста по открытому буфферу]]
  - [[#поиск-на-стартовой-странице-emacs][Поиск на стартовой странице Emacs]]
  - [[#выделение-при-поиске-по-тексту][Выделение при поиске по тексту]]
  - [[#символ-технического-пробела-_][Символ технического пробела `_']]
  - [[#чувствительность-к-регистру-прописные-и-строчные-символы][Чувствительность к регистру (прописные и строчные символы)]]
  - [[#imenu-навигация-по-документу-через-меню][Imenu. Навигация по документу через меню]]
  - [[#выделение-по-регулярному-выражению-highlight][Выделение по регулярному выражению (highlight)]]
- [[#работа-с-вкладками-tab][Работа с вкладками (tab)]]
  - [[#новая-именованная-вкладка][Новая именованная вкладка]]
- [[#работа-с-фреймами][Работа с фреймами]]
  - [[#клавиши-для-работы-с-фреймами][Клавиши для работы с фреймами]]
  - [[#поиск-фрейма-по-имени][Поиск фрейма по имени]]
  - [[#вид-окон-при-открытии-нового-фрейма][Вид окон при открытии нового фрейма]]
- [[#работа-с-окнами][Работа с окнами]]
  - [[#клавиши-для-работы-с-окнами][Клавиши для работы с окнами]]
  - [[#нумерация-окон][Нумерация окон]]
  - [[#разделение-рабочего-пространства-на-заданное-количество-окон][Разделение рабочего пространства на заданное количество окон]]
  - [[#переключение-окон-как-в-spacemacs][Переключение окон, как в Spacemacs]]
  - [[#разделение-окна][Разделение окна]]
  - [[#ширина-разделителя-окон][Ширина разделителя окон]]
  - [[#настройка-ediff][Настройка Ediff]]
- [[#работа-с-буферами][Работа с буферами]]
  - [[#клавиши-для-работы-с-буферами][Клавиши для работы с буферами]]
  - [[#отображение-popup-буферов-внизу-окна-и-прочие-настройки-показа-буферов][Отображение popup-буферов внизу окна и прочие настройки показа буферов]]
  - [[#открытие-буфера-простое-и-с-разделением-окна][Открытие буфера, простое и с разделением окна]]
  - [[#перенос-буферов-между-окнами][Перенос буферов между окнами]]
  - [[#переключение-показа-по-центру-окна][Переключение показа по центру окна]]
  - [[#показ-буферов-разобранных-по-проектам][Показ буферов, разобранных по проектам]]
  - [[#scratch-буфер][Scratch буфер]]
- [[#работа-с-файлами][Работа с файлами]]
  - [[#клавиши-для-работы-с-файлами][Клавиши для работы с файлами]]
  - [[#режим-ранее-открытых-файлов][Режим ранее открытых файлов]]
  - [[#восстановление-позиции-курсора-в-открытом-файле][Восстановление позиции курсора в открытом файле]]
  - [[#автоматическое-обновление-буферов-при-внешнем-изменении-их-содержимого][Автоматическое обновление буферов при внешнем изменении их содержимого]]
  - [[#открытие-файла-с-разделением-окна][Открытие файла с разделением окна]]
  - [[#копирование-в-буфер-обмена-текущего-имени-файла][Копирование в буфер обмена текущего имени файла]]
  - [[#удаление-лишних-пробелов-при-сохранении-файла][Удаление лишних пробелов при сохранении файла]]
  - [[#dired-настройка-файлового-менеджера][Dired. Настройка файлового менеджера]]
  - [[#история-сохраненных-файлов][История сохраненных файлов]]
  - [[#открытие-файла-средствами-операционной-системы][Открытие файла средствами операционной системы]]
  - [[#логирование-всплывающих-сообщений][Логирование всплывающих сообщений]]
  - [[#поиск-текста-и-файла-по-директории][Поиск текста и файла по директории]]
  - [[#графический-диалог-открытия-файла][Графический диалог открытия файла]]
  - [[#gpg-костыли][GPG-костыли]]
- [[#рабочие-пространства-workspaces-perspectives][Рабочие пространства (workspaces, perspectives)]]
  - [[#установка-и-настройка-рабочих-пространств][Установка и настройка рабочих пространств]]
  - [[#клавиши-для-работы-с-рабочими-пространствами][Клавиши для работы с рабочими пространствами]]
  - [[#открытие-новых-рабочих-пространств-в-новых-фреймах][Открытие новых рабочих пространств в новых фреймах]]
- [[#проекты-projects][Проекты (projects)]]
  - [[#установка-и-настройка-работы-с-проектами-projectile][Установка и настройка работы с проектами (Projectile)]]
  - [[#совместная-работа-проектов-и-рабочих-пространств][Совместная работа проектов и рабочих пространств]]
  - [[#исключение-файлов-из-поиска-по-проектам][Исключение файлов из поиска по проектам]]
- [[#демоны][Демоны]]
  - [[#свой-хук-на-создание-первого-клиентского-фрейма][Свой хук на создание первого клиентского фрейма]]
  - [[#задание-цветовых-тем-для-известных-демонов][Задание цветовых тем для известных демонов]]
  - [[#задание-имен-для-рабочих-пространств-и-фреймов-на-старте-первого-клиентского-фрейма][Задание имен для рабочих пространств и фреймов на старте первого клиентского фрейма]]
  - [[#ярлыки-для-работы-с-известными-демонами][Ярлыки для работы с известными демонами]]
- [[#org][Org]]
  - [[#начальная-инициализация-всей-org-кухни][Начальная инициализация всей org-кухни]]
  - [[#клавиши-для-работы-в-org-mode][Клавиши для работы в org-mode]]
  - [[#переход-по-ссылкам][Переход по ссылкам]]
  - [[#функция-показа-и-скрытия-картинки-в-org-mode][Функция показа и скрытия картинки в org-mode]]
  - [[#разнообразная-реакция-на-enter-ret][Разнообразная реакция на Enter (RET)]]
  - [[#разнообразная-реакция-на-двойное-нажатие-мышки][Разнообразная реакция на двойное нажатие мышки]]
  - [[#открытие-org-ссылки-в-том-же-окне][Открытие org-ссылки в том же окне]]
  - [[#директория-для-org-файлов-и-прочей-org-кухни][Директория для org-файлов и прочей org-кухни]]
  - [[#подгрузка-остальных-пакетов][Подгрузка остальных пакетов]]
  - [[#запуск-скриптов-в-org-babel-src-блоках][Запуск скриптов в org-babel src-блоках]]
  - [[#поддержка-показа-картинок-в-результатах-выполнения-org-babel-блоков][Поддержка показа картинок в результатах выполнения org-babel блоков]]
  - [[#перенос-длинных-строк-по-словам][Перенос длинных строк по словам]]
  - [[#поддержка-org-календаря][Поддержка org-календаря]]
  - [[#карсивые-метки-списков][Карсивые метки списков]]
  - [[#отступы-в-src-блоках][Отступы в src-блоках]]
  - [[#автоматическое-схлопывание-org-babel-блоков][Автоматическое схлопывание org-babel блоков]]
  - [[#параметры-экспортирования-из-org-mode][Параметры экспортирования из org-mode]]
  - [[#ручная-вставка-оглавления-toc][Ручная вставка оглавления (toc)]]
  - [[#вычисление-babel-блоков-при-экспорте][Вычисление babel-блоков при экспорте]]
  - [[#экспорт-в-pdf-через-latex][Экспорт в PDF через Latex]]
  - [[#экспорт-в-markdown][Экспорт в Markdown]]
  - [[#latex-preview-формулы-проямо-в-org-тексте][LaTeX preview. Формулы проямо в org-тексте]]
  - [[#latex-preview-ручное-изменение-размеров-формул-костыль][LaTeX preview. Ручное изменение размеров формул (костыль)]]
  - [[#копирование-ссылки-в-буфер-обмена][Копирование ссылки в буфер обмена]]
  - [[#преобразование-url-в-ссылку-с-именем-задачи-или-файла][Преобразование URL в ссылку с именем задачи или файла]]
  - [[#открытие-картинок-и-файлов-по-ссылке-в-том-же-буфере][Открытие картинок (и файлов) по ссылке в том же буфере]]
  - [[#клавиши-для-работы-с-таблицами][Клавиши для работы с таблицами]]
  - [[#показ-картинок-результатов-выполнения-org-babel-блоков][Показ картинок-результатов выполнения org-babel блоков]]
  - [[#показ-времени-выполнения-babel-блока][Показ времени выполнения babel-блока]]
  - [[#org-modern-красивое-представление-org][Org-modern. Красивое представление org]]
  - [[#слайды-и-презентации][Слайды и презентации]]
  - [[#новый-буфер-в-режиме-org-mode][Новый буфер в режиме org-mode]]
  - [[#работа-с-параграфом-в-отдельном-буфере-indirect-buffer][Работа с параграфом в отдельном буфере (indirect buffer)]]
  - [[#agenda][Agenda]]
  - [[#agenda-статусы-задач][Agenda. Статусы задач]]
  - [[#journal][Journal]]
  - [[#drag-n-drop-в-dired-mode-org-download][Drag-n-drop в dired-mode (org-download)]]
- [[#org-roam][Org-roam]]
  - [[#установка][Установка]]
  - [[#исключение-тегов-из-наследования][Исключение тегов из наследования]]
  - [[#шаблоны][Шаблоны]]
  - [[#поддержка-работы-в-разных-хранилищах-vault-и-разных-поддиректориях-subdirectory][Поддержка работы в разных хранилищах (vault) и разных поддиректориях (subdirectory)]]
  - [[#org-roam-ui][Org-roam-ui]]
  - [[#org-roam-db-query-только-информация][Org-roam-db-query (только информация)]]
  - [[#org-ql-поиск-по-org-файлам][Org-ql. Поиск по org-файлам]]
  - [[#org-roam-ql-поиск-по-файлам-org-roam][Org-roam-ql. Поиск по файлам org-roam]]
- [[#терминалы][Терминалы]]
  - [[#eshell][eshell]]
  - [[#shell][shell]]
  - [[#vterm][vterm]]
  - [[#асинхронный-вызов-системных-команд-async-shell-command][Асинхронный вызов системных команд (async-shell-command)]]
- [[#удаленный-доступ-tramp][Удаленный доступ (tramp)]]
  - [[#клавиши-для-функций-tramp][Клавиши для функций tramp]]
  - [[#ошибка-too-many-authentication-failures][Ошибка "Too many authentication failures"]]
- [[#инструменты-внешние][Инструменты внешние]]
  - [[#treemacs][Treemacs]]
  - [[#magit][Magit]]
  - [[#git-timemachine][Git-timemachine]]
  - [[#подсветка-разницы-с-head-в-каждой-строке-git-gutter][Подсветка разницы с HEAD в каждой строке (git-gutter)]]
  - [[#blamer-смотрелка-заголовков-последних-коммитов-в-коде][Blamer (смотрелка заголовков последних коммитов в коде)]]
  - [[#docker][Docker]]
  - [[#календарь-как-его-представление][Календарь, как его представление]]
  - [[#tldr-примеры-запуска-утилит-из-командной-строки][Tldr. Примеры запуска утилит из командной строки]]
- [[#инструменты-свои][Инструменты свои]]
  - [[#словарик-под-stardict][Словарик под StarDict]]
  - [[#калькулятор-на-python][Калькулятор на Python]]
- [[#сценарии-для-emacsclient][Сценарии для emacsclient]]
  - [[#вызов-словарика][Вызов словарика]]
  - [[#список-закладок][Список закладок]]
  - [[#вызов-живого-калькулятора-на-python][Вызов живого калькулятора на Python]]
- [[#панель-на-старте-с-логотипом-dashboard][Панель на старте с логотипом (dashboard)]]
  - [[#выбор-случайной-картинки-для-стартового-логотипа][Выбор случайной картинки для стартового логотипа]]
  - [[#настройка-панели][Настройка панели]]
- [[#llm-всевозможные-клиенты][LLM. Всевозможные клиенты]]
  - [[#чтение-ключей-из-gpg-файлов][Чтение ключей из gpg-файлов]]
  - [[#общие-клавиши][Общие клавиши]]
  - [[#ollama-buddy-клиент-для-ollama][Ollama-buddy (клиент для Ollama)]]
  - [[#gptel-простой-llm-клиент-для-emacs][GPTel (простой LLM-клиент для Emacs)]]
  - [[#gptel-подключаем-deepseek][GPTel. Подключаем DeepSeek]]
  - [[#gptel-подключаем-ollama][GPTel. Подключаем Ollama]]
  - [[#gptel-подключаем-gigachat][GPTel. Подключаем GigaChat]]
    - [[#материалы-только-информация-и-ссылки][Материалы (только информация и ссылки)]]
    - [[#получение-access-token][Получение access token]]
    - [[#настройки][Настройки]]
  - [[#работа-с-кодом-автодополнение-оптимизация-и-прочее][Работа с кодом (автодополнение, оптимизация и прочее)]]
    - [[#буфер-для-результатов-работы-с-кодом][Буфер для результатов работы с кодом]]
    - [[#функции-работы-с-кодом][Функции работы с кодом]]
    - [[#горячие-клавиши][Горячие клавиши]]
- [[#lsp-сервер-vs-eglot][LSP сервер (vs Eglot)]]
  - [[#установка-1][Установка]]
  - [[#общие-настройки][Общие настройки]]
  - [[#клавиши-для-работы][Клавиши для работы]]
  - [[#перезагрузка][Перезагрузка]]
  - [[#copilot][Copilot]]
  - [[#semgrep][Semgrep]]
- [[#tree-sitter-treesit][Tree sitter (treesit)]]
  - [[#treesit-установка-и-общие-настройки][Treesit. Установка и общие настройки]]
  - [[#combobulate---редактирование-с-treesit][Combobulate - редактирование с treesit]]
  - [[#выделение-родительских-блоков-в-программном-коде][Выделение родительских блоков (в программном коде)]]
- [[#программирование][Программирование]]
  - [[#навигация-по-ошибкам][Навигация по ошибкам]]
  - [[#компиляция-compile-назначение-клавиш][Компиляция (compile). Назначение клавиш]]
  - [[#emacs-lisp][Emacs-Lisp]]
  - [[#показ-кандидатов-через-ivy-xref][Показ кандидатов через ivy-xref]]
  - [[#dumb-jump-решение-проблемы-перехода-по-сущностям][Dumb-jump. Решение проблемы перехода по сущностям]]
  - [[#logview][Logview]]
  - [[#markdown][Markdown]]
  - [[#csv-и-tsv][CSV и TSV]]
  - [[#pdf][PDF]]
  - [[#yaml][Yaml]]
  - [[#json][Json]]
  - [[#make][Make]]
  - [[#vimrc][Vimrc]]
  - [[#plantuml][PlantUML]]
  - [[#mermaid][Mermaid]]
  - [[#gnuplot][Gnuplot]]
  - [[#restclient][Restclient]]
  - [[#python][Python]]
  - [[#python-pyvenv][Python. Pyvenv]]
  - [[#emacs-ipython-notebook-ein][Emacs IPython Notebook (ein)]]
  - [[#haskell][Haskell]]
  - [[#rust][Rust]]
  - [[#c-default-lsp-server][C++ (default LSP-server)]]
  - [[#c-clangd-на-удаленном-сервере-через-docker-информация][C++. Clangd на удаленном сервере через docker (информация)]]
  - [[#clang-format-форматирование-c][Clang-format. Форматирование C++]]
  - [[#cmake][Cmake]]
  - [[#go][Go]]
  - [[#groovy][Groovy]]
  - [[#java][Java]]
  - [[#java-spring-boot][Java. Spring Boot]]
  - [[#javascripttypescript][JavaScript/TypeScript]]
  - [[#scala][Scala]]
- [[#финалочки][Финалочки]]
  - [[#чистка-статусной-панели-от-всего-лишнего-modeline][Чистка статусной панели от всего лишнего (modeline)]]

* Lexical-binding. Лексические замыкания

С ними лучше, чем без них. :)

Включаются локальной переменной =lexical-binging= и работают в
пределах своего буфера.  При загрузке el-файла можно включить
специальным комментарием в начале.

Включим лексические замыкания в этом конфиге.

#+begin_src emacs-lisp :tangle yes
;;; -*- lexical-binding: t -*-
#+end_src

* Отладка

Создаем буфер =*my/log-buffer*= и пишем в него логи.
Функция для записи - =(my/log TEXT)=.
Иногда нужно для отладки кода в этом документе.

#+begin_src emacs-lisp :tangle yes
(setq my/log-buffer (get-buffer-create "*my/log-buffer*"))

(defun my/log (text)
    (interactive "s")
    (with-current-buffer my/log-buffer
        (goto-char (point-max))
        (insert text)
        (insert "\n")
        (goto-char (point-max))))
#+end_src

* Общие параметры и переменные данной конфигурации

Здесь собраны параметры, значения которых будут далее использованы по всему
конфигу.

** Кодировка по-умолчанию (utf-8)

Убираем ошибку, которая появляется при незнакомой кодировке. Все
должно быть в UTF-8.

#+begin_src emacs-lisp :tangle yes
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment 'utf-8)
#+end_src

** Директория файлов конфигурации

Для дальнейшей работы в переменой =my/config-dir= устанавливается путь
к файлам настроек, т.е. путь к проекту с этим файлом.
Значение переменной my/config-dir задается в файле проекта [[./init.el][init.el]].

** Идентификация пользователя Emacs

Подпишемся, как просят. :)

"Some functionality uses this to identify you, e.g. GPG configuration,
email clients, file templates and snippets."

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Vaddson"
      user-mail-address "vaddson@vaddson.aaa")
#+end_src

** Включение Evil по всему редактору
   :PROPERTIES:
   :ID:       44f272c6-5f95-440f-8a1f-1766fe438feb
   :END:

Здесь выбирается режим редактирования.  По-умолчанию это Vim (EVIL).
Чтобы переключиться на Emacs, надо сбросить переменную =my/evil= в nil.

#+begin_src emacs-lisp :tangle yes
(setq my/evil t)  ;; For Vim keys.
;; (setq my/evil nil)  ;; For Emacs keys.
#+end_src

Префикс-лидер для Vim установлен в =пробел=, для Emacs - =Ctrl-s=.
Эти префиксы задаются в разделе "[[id:03e1b30d-e7f1-42ac-bc0b-71a9b2970fcf][General (назначение клавиш на помощь evil)]]".

* Подготовка к установке пакетов из репозиториев

Подцепим все репозитории.

#+begin_src emacs-lisp :tangle yes
(require 'package)

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)

;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
#+end_src

Рекомендуемые где-то кем-то действия перед загрузкой пакетов.  (Если
какой-то пакет по прошествии времени упорно не находится в
репозиториях, спасает ручной вызов функции =package-refresh-contents=.

#+begin_src emacs-lisp :tangle yes
;; disable automatic loading of packages after the init file
(setq package-enable-at-startup nil)
;; instead load them explicitly
(package-initialize)
;; refresh package descriptions
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

Пакеты будем цеплять через =use-package=. Установим его.

#+begin_src emacs-lisp :tangle yes
;;; use-package initialization
;;; install use-package if not already done
(if (not (package-installed-p 'use-package))
    (progn (package-refresh-contents)
           (package-install 'use-package)))
;;; use-package for вид GUI
#+end_src

Подцепим работу с qelpa. Если пакет не установлен, то позаботимся о
первом обновлении.

#+begin_src emacs-lisp :tangle yes
(setq quelpa-update-melpa-p (not (package-installed-p 'quelpa-use-package)))

(use-package quelpa-use-package
    ;; :init
    ;; (setq quelpa-update-melpa-p nil)
    :ensure t)
(require 'quelpa-use-package)
#+end_src

Не будем кошмарить логом с ошибками, если там только предупреждения.

#+begin_src emacs-lisp :tangle yes
(setq warning-minimum-level :error)
#+end_src

* Пока редактор загружается, поправим ему внешний вид

** Меню и панель инструментов (menu and toolbar)

Скроем лишние элементы управления такие, как меню, полосы прокрутки и
прочее. Меню по-прежнему остается доступно по клавише =F10=.

#+begin_src emacs-lisp :tangle yes
(menu-bar-mode     -1)  ;; Отключаем графическое меню.
(tool-bar-mode     -1)  ;; Отключаем tool-bar.
(scroll-bar-mode   -1)  ;; Отключаем полосы прокрутки.
(tab-bar-mode      -1)  ;; Отключаем панель закладок.
#+end_src

** Красивые темы и установка темы по-умолчанию
   :PROPERTIES:
   :ID:       40986685-fc80-45b7-ab77-4cac074fea9f
   :END:

Загружаем красивые темы и устанавливаем одну из них.
Стараемся успеть до загрузки всех остальных настроек.

#+begin_src emacs-lisp :tangle yes
(use-package doom-themes
    :ensure t
    :config
    (load-theme 'doom-one t)
    ;; (load-theme 'doom-gruvbox-light t)
    ;; (load-theme 'doom-gruvbox t)
    ;; (load-theme 'doom-molokai t)
    )
(use-package modus-themes
    :ensure t)
(use-package ef-themes
    :ensure t)
#+end_src

* Полезные пакеты, вытащенные из сторонних проектов

Здесь импортируются удобства, вытащенные из сторонних конфигураций Emacs.

** Spacemacs

Библиотека, вытянутая из Spacemacs. Так и тащу ее за собой через Doom. :)

#+begin_src emacs-lisp :tangle yes
(load-file (file-name-concat my/config-dir "/funcs.el"))
#+end_src

* Среда

** Сохранение состояния для Desktop

Запретим сохранение среды, чтобы не мешалось.

#+begin_src emacs-lisp :tangle yes
(setq desktop-save-mode nil)
#+end_src

** Удаление файлов и бэкапы

Файлы удаляем только в корзину.

#+begin_src emacs-lisp :tangle yes
(setq delete-by-moving-to-trash t)
#+end_src

А бэкапы файлов запрещаем. Очень неудобно они называются, да и не нужны мне.

#+begin_src emacs-lisp :tangle yes
(setq make-backup-files nil)
(setq auto-save-default nil)
#+end_src

** Звуковой сигнал (типа "гудок")

Вот ни разу не был нужен. Отключаем.

#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+end_src

** Сборщик мусора (GC)

Добыл из Emacs-чатика настройки для сборщика мусора.  Там порог
выворачивается в максимум: меньше экономии, больше скорость работы.
Попробуем.

#+begin_src emacs-lisp :tangle yes
(use-package gcmh
	:ensure t
	:config
	(gcmh-mode 1)
	(setf gc-cons-threshold gcmh-high-cons-threshold)
	;; Release severe GC strategy before the user restart to working
	(add-hook 'pre-command-hook #'gcmh-set-high-threshold)
	(add-hook 'post-command-hook #'gcmh-register-idle-gc))
#+end_src

* Evil. Режим редактирования
  :PROPERTIES:
  :ID:       cc78f980-e959-4169-b667-4b40109e08a7
  :END:

** Установка и настройка

Сразу ставим пакет =evil= и включаем эмуляцию редактора Vim. Здесь же
ставим замену табуляций на пробелы для команды =evil-indent=.

При необходимости переключение между Evil и Emacs режимами в пределах
одного буфера можно делать клавишами =Ctrl-z=.

#+begin_src emacs-lisp :tangle yes
(use-package evil
    :ensure t
    :init
    ;; (setq evil-undo-system 'undo-tree)
    (setq evil-want-keybinding nil)
    :config
    (setq-default indent-tabs-mode nil)
    (setq evil-indent-convert-tabs t))
#+end_src

Включаем Evil, если [[id:44f272c6-5f95-440f-8a1f-1766fe438feb][на старте]] это было заказано.

#+begin_src emacs-lisp :tangle yes
(when my/evil
    (evil-mode))
#+end_src

Устанавливаем evil-клавиши для всего, что есть.

Устанавливаем сразу все карты клавиш функцией =evil-collection-init=.
Список того, что там еще есть:
- evil-collection-bm-setup
- evil-collection-calendar-setup
- evil-collection-calendar-setup-org-bindings
- evil-collection-comint-setup
- evil-collection-compile-setup
- evil-collection-custom-setup
- evil-collection-debug-setup
- evil-collection-diff-mode-setup
- evil-collection-dired-setup
- evil-collection-edebug-setup
- evil-collection-ediff-setup
- evil-collection-eglot-setup
- evil-collection-elisp-mode-setup
- evil-collection-elisp-refs-setup
- evil-collection-epa-setup
- evil-collection-eshell-setup
- evil-collection-eshell-setup-keys
- evil-collection-finder-setup
- evil-collection-flycheck-setup
- evil-collection-flymake-setup
- evil-collection-grep-setup
- evil-collection-help-setup
- evil-collection-helpful-setup
- evil-collection-ibuffer-setup
- evil-collection-imenu-setup
- evil-collection-indent-setup
- evil-collection-info-setup
- evil-collection-ivy-setup
- evil-collection-log-edit-setup
- evil-collection-magit-section-setup
- evil-collection-magit-setup
- evil-collection-magit-todos-setup
- evil-collection-man-setup
- evil-collection-markdown-mode-setup
- evil-collection-org-roam-setup
- evil-collection-org-setup
- evil-collection-package-menu-setup
- evil-collection-popup-setup
- evil-collection-python-setup
- evil-collection-setup
- evil-collection-sh-script-setup
- evil-collection-so-long-setup
- evil-collection-vc-git-setup
- evil-collection-view-setup
- evil-collection-wgrep-setup
- evil-collection-which-key-setup
- evil-collection-xref-setup

#+begin_src emacs-lisp :tangle yes
(use-package evil-collection
    :ensure t
    :config
    (evil-collection-init))
#+end_src

Догружаем остальной ворох пакетов для evil.

#+begin_src emacs-lisp :tangle yes
(use-package evil-args
    :ensure t)
(use-package evil-easymotion
    :ensure t)
(use-package evil-embrace
    :ensure t)
(use-package evil-escape
    :ensure t)
(use-package evil-exchange
    :ensure t)
(use-package evil-indent-plus
    :ensure t)
(use-package evil-lion
    :ensure t)
(use-package evil-nerd-commenter
    :ensure t)
(use-package evil-numbers
    :ensure t)
(use-package evil-snipe
    :ensure t)
(use-package evil-surround
    :ensure t)
(use-package evil-textobj-anyblock
    :ensure t)
(use-package evil-vimish-fold
    :ensure t)
(use-package evil-visualstar
    :ensure t)
#+end_src

** General (назначение клавиш на помощь evil)
   :PROPERTIES:
   :ID:       03e1b30d-e7f1-42ac-bc0b-71a9b2970fcf
   :END:

Установка клавиш leader (=пробел= или =Alt-m=) и localleader (с добавкой =m= к лидеру).
Для режима редактирования Emacs лидеры переопределяются в =Ctrl-s=.

#+begin_src emacs-lisp :tangle yes
(if my/evil
    (setq my/leader "SPC"
          my/leader-non-normal "M-m"
          my/localleader "SPC m"
          my/localleader-non-normal "M-m m")
    (setq my/leader "C-s"
          my/leader-non-normal "C-s"
          my/localleader "C-s m"
          my/localleader-non-normal "C-s m"
          my/evil-prefix "C-s C-s"))
#+end_src

Для определения клавиш удобнее переключиться на пакет =general=.
Заодно для некоторых раскладок отменим клавишу пробела.
Для предотвращения внезапной ошибки вызовем функцию (general-auto-unbind-keys).

#+begin_src emacs-lisp :tangle yes
(use-package general
    :ensure t
    :config
    (general-auto-unbind-keys)
    (evil-define-key 'normal dired-mode-map (kbd my/leader) nil))
#+end_src

Определим на основе general-define-key свои функции назначения клавиш.
- Функция =my/leader= будет назначать клавишам префикс с
  лидером (=пробел= или =Alt-m=).
- Функция =my/localleader= будет назначать клавишам префикс с
  локальным лидером (=пробел m= или =Atl-m m=).
- Функция =my/evil-define-key= будет назначать клавиши в режимах EVIL
  без префикса, как то: normal, visual, insert, replace, moniton, emacs.

#+begin_src emacs-lisp :tangle yes
(defmacro my/leader-def (states keymaps &rest args)
    `(my/--define-key my/leader
                      my/leader-non-normal
                      ,states
                      ,keymaps
                      ,@args))

(defmacro my/localleader-def (states keymaps &rest args)
    `(my/--define-key my/localleader
                      my/localleader-non-normal
                      ,states
                      ,keymaps
                      ,@args))

(defmacro my/evil-define-key (states keymaps &rest args)
    (if my/evil
        (progn
            (setq states (or states
                             '(normal visual insert replace moniton emacs)))
            `(general-define-key :states ',states
                                 :keymaps ',keymaps
                                 ,@args))
        `(general-define-key :keymaps ',keymaps
                             :prefix my/evil-prefix
                             ,@args)))

(defmacro my/--define-key (leader leader-non-normal states keymaps &rest args)
    (if my/evil
        (progn
            (setq states (or states
                             '(normal visual insert replace moniton emacs)))
            `(general-define-key :states ',states
                                 :keymaps ',keymaps
                                 :prefix ,leader
                                 ;; :global-prefix ,leader-non-normal
                                 :non-normal-prefix ,leader-non-normal
                                 ,@args))
        `(general-define-key :keymaps ',keymaps
                             :prefix ,leader
                             ,@args)))

(unless my/evil
    (general-define-key my/evil-prefix '(:ignore t :which-key "normal")))
#+end_src

Назначим некоторые полезные сочетания клавиш.
Ниже это вычисление LISP-выражения, введенного с клавиатуры.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               ";" '(pp-eval-expression :which-key "Eval LISP expression"))
#+end_src

** Настройка поведения клавиш для evil-mode, как в Vim.

Перемещение по строкам и внутри них хоть и сделано в evil-mode, но
работает как-то все равно с огрехами (или мне так кажется). Поэтому
сделаем костыль, в котором четко определим, как должна работать
навигация.

Здесь включается, как в Vim, реакция на "dd", "V" и т.п.. "Допил
напильником" ниже.

#+begin_src emacs-lisp :tangle yes
(setq evil-respect-visual-line-mode nil)
#+end_src

Перемещение курсора, как в Vim, независимо от `global-visual-mode' и
прочих "удобств".

#+begin_src emacs-lisp :tangle yes
(define-key evil-normal-state-map (kbd "j") #'evil-next-line)
(define-key evil-visual-state-map (kbd "j") #'evil-next-line)
(define-key evil-normal-state-map (kbd "g j") #'evil-next-visual-line)
(define-key evil-visual-state-map (kbd "g j") #'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "k") #'evil-previous-line)
(define-key evil-visual-state-map (kbd "k") #'evil-previous-line)
(define-key evil-normal-state-map (kbd "g k") #'evil-previous-visual-line)
(define-key evil-visual-state-map (kbd "g k") #'evil-previous-visual-line)
(define-key evil-normal-state-map (kbd "$") #'evil-end-of-line)
(define-key evil-visual-state-map (kbd "$") #'evil-end-of-line)
(define-key evil-normal-state-map (kbd "^") #'evil-first-non-blank)
(define-key evil-visual-state-map (kbd "^") #'evil-first-non-blank)
(define-key evil-normal-state-map (kbd "0") #'evil-beginning-of-line)
(define-key evil-visual-state-map (kbd "0") #'evil-beginning-of-line)

(define-key evil-normal-state-map (kbd "A") #'my/evil-append-line)
(defun my/evil-append-line ()
    (interactive)
    (evil-end-of-line)
    (evil-append 1))

(define-key evil-normal-state-map (kbd "I") #'my/evil-insert-line)
(defun my/evil-insert-line ()
    (interactive)
    (evil-first-non-blank)
    (evil-insert 1))

(define-key evil-normal-state-map (kbd "D") #'my/evil-delete-line)
(defun my/evil-delete-line ()
    (interactive)
    (save-excursion
        (let ((beg (point))
              (end))
            (evil-end-of-line)
            ;; (setq end (point))
            (setq end (min (buffer-end +1) (+ 1 (point))))
            (evil-delete-line beg end))))

(define-key evil-normal-state-map (kbd "C") #'my/evil-change-line)
(defun my/evil-change-line ()
    (interactive)
    (save-excursion
        (let ((beg (point))
              (end))
            (evil-end-of-line)
            (setq end (min (buffer-end +1) (+ 1 (point))))
            (evil-change beg end))))

(define-key evil-normal-state-map (kbd "S") #'my/evil-change-whole-line)
(defun my/evil-change-whole-line ()
    (interactive)
    (let ((beg)
          (end))
        (evil-first-non-blank)
        (setq beg (point))
        (evil-end-of-line)
        (setq end (min (buffer-end +1) (+ 1 (point))))
        (evil-change beg end)))
#+end_src

* Внешний вид UI и GUI

** Автоматическая установка шрифтов

Для маленького монитора в 14" удобнее взять шрифт побольше.  Поскольку
отображение текста в Emacs не подстраивается к текущему DPI, напишем
следующий костыль.

Для этого установим в редактор два шрифта: обычный и побольше.
Пример:
: (setq my/global-font "Droid Sans Mono-10")
Глобальный шрифт (обычный) будем держать в переменной =my/global-font=,
а шрифт побольше - в переменной =my/global-font-inc=.

Поскольку шрифты ниже могут быть не установлены в системе, сделаем
подстраховку: назначим список шрифтов по приоритету и дефолтный nil.

Размер шрифтов надо выставлять не по размеру экрана, а по DPI (в нашем
случае - точек на 1 мм - DPMM). Пока лень заморачиваться общей
формулой, поэтому поставим только три размера шрифта. Ниже оставлю для
напоминания три DPMM в порядке увеличения шрифтов при разрешении 1920
точек:
1. 3.562 = 1920 / 539 -- 24", округляем до 4.
2. 5.026 = 1920 / 382 -- 17", округляем до 5.
3. 6.193 = 1920 / 310 -- 14", округляем до 6.

#+begin_src emacs-lisp :tangle yes
(setq my/font-families '((:family "JetBrains Mono" :size-dec 8 :size 9 :size-inc 10 :size-hug 13)
                         (:family "Liberation Mono" :size-dec 8 :size 9 :size-inc 10 :size-hug 13)
                         (:family "Monospace" :size-dec 8 :size 9 :size-inc 10 :size-hug 13)))
#+end_src

Теперь напишем подстраховку на наличие в системе шрифтов.  Работать это
будет только при живом фрейме.

#+begin_src emacs-lisp :tangle yes
(require 'cl)

(setq my/frame-font-families nil
      my/global-font-dec nil
      my/global-font nil
      my/global-font-inc nil
      my/global-font-hug nil)

(defun my/ensure-fonts (&optional frame)
    (unless my/frame-font-families
        (setq my/frame-font-families (font-family-list frame))
        (when my/frame-font-families
            (dolist (row my/font-families)
                (let ((family (plist-get row :family))
                      (size-dec (plist-get row :size-dec))
                      (size (plist-get row :size))
                      (size-inc (plist-get row :size-inc))
                      (size-hug (plist-get row :size-hug)))
                    (when (member family my/frame-font-families)
                        (setq my/global-font-dec (format "%s-%s" family size-dec)
                              my/global-font (format "%s-%s" family size)
                              my/global-font-inc (format "%s-%s" family size-inc)
                              my/global-font-hug (format "%s-%s" family size-hug))
                        (add-to-list 'default-frame-alist `(font . ,my/global-font))
                        (cl-return family)))))))
#+end_src

Напишем функцию, которая в указанном (или активном) фрейме в
зависимости от ширины экрана выбирает один из двух шрифтов.

#+begin_src emacs-lisp :tangle yes
(defun my/select-frame-font-for-monitor (frame font-dec font font-inc font-hug)
    (my/ensure-fonts frame)
    (when (and font-dec font font-inc font-hug)
        (pcase (my/--select-font-size-category frame)
            ('small
             (set-frame-font font-dec t))
            ('big
             (set-frame-font font-inc t))
            ('hugo
             (set-frame-font font-hug t))
            (_
             (set-frame-font font t)))))

(defun my/--select-font-size-category (frame)
    (let* ((monitor-attrs (frame-monitor-attributes frame))
           (points (nth 3 (assoc 'workarea monitor-attrs)))
           (mm-width (cl-second (assoc 'mm-size monitor-attrs)))
           (dpmm (if mm-width (/ points (float mm-width)) 5.0)))
        (cond ((> dpmm 6.4) 'hugo)
              ((> dpmm 6.0) 'big)
              ((> dpmm 4.0) 'normal)
              (t 'small))))
#+end_src

Теперь с помощью полученной функции обновляем шрифт в активном фрейме.
В случае запуска демоном установку шрифта ниже надо пропустить.

#+begin_src emacs-lisp :tangle yes
(unless (daemonp)
    (my/select-frame-font-for-monitor nil
                                      my/global-font-dec
                                      my/global-font
                                      my/global-font-inc
                                      my/global-font-hug))
#+end_src

При создании фрейма навесим обработчик этого события, чтобы размер
шрифта выровнять автоматически. Повторение хука на создание фрейма
клиента - это костыль.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-make-frame-functions
          (lambda (frame)
              (my/select-frame-font-for-monitor frame
                                                my/global-font-dec
                                                my/global-font
                                                my/global-font-inc
                                                my/global-font-hug)))
(add-hook 'my/server-after-make-frame-hook
          (lambda ()
              (my/select-frame-font-for-monitor nil
                                                my/global-font-dec
                                                my/global-font
                                                my/global-font-inc
                                                my/global-font-hug)))
#+end_src

Не всегда получится правильно угадать и выставить шрифт
автоматически. Так что предусмотрим "ручное управлене".

#+begin_src emacs-lisp :tangle yes
(defun my/correct-font-in-current-frame ()
    (interactive)
    (my/ensure-fonts)
    (my/select-frame-font-for-monitor nil
                                      my/global-font-dec
                                      my/global-font
                                      my/global-font-inc
                                      my/global-font-hug))

(my/leader-def nil 'override
               "e" '(:ignore t :which-key "env/edit"))
(my/leader-def nil 'override
               "e d" #'my/correct-font-in-current-frame)
#+end_src

** Установка nerd-шрифтов (иконочки)

Для начала проверим, установлены ли все nerd-пакеты. Это будет
индикатором для установки шрифтов с иконками.

#+begin_src emacs-lisp :tangle yes
(defun my/--is-nerd-packages-installed ()
    (reduce (lambda (a b)
                (and a b))
            (mapcar 'package-installed-p
                    '(nerd-icons all-the-icons-nerd-fonts all-the-icons))))

(setq my/--is-nerd-packages-installed (my/--is-nerd-packages-installed))
#+end_src

Установим необходимые пакеты под иконки.

#+begin_src emacs-lisp :tangle yes
(use-package nerd-icons
    :ensure t)
(use-package all-the-icons-nerd-fonts
	:ensure t)
(use-package all-the-icons
    :if (display-graphic-p))
#+end_src

Теперь установим сами иконки. Позаботимся о разовости установки.

#+begin_src emacs-lisp :tangle yes
(unless my/--is-nerd-packages-installed  ;; TODO: Перенести custom в отдельный
                                         ;;     файл и сделать загрузку в начале.
    (unless (boundp 'is-nerd-icons-install-fonts)
        (nerd-icons-install-fonts t)
        (setq is-nerd-icons-install-fonts t)
        (customize-save-variable 'is-nerd-icons-install-fonts t)))
#+end_src

** Мигание курсора

Выключаем мигание курсора.

#+begin_src emacs-lisp :tangle yes
(blink-cursor-mode 0)
#+end_src

** Подсветка строки с курсором

Подсветим строку с курсором во всех буферах.

#+begin_src emacs-lisp :tangle yes
(global-hl-line-mode 1)
#+end_src

** Прозрачность

Делаем три уровня прозрачности редактора:
1. непрозрачный,
2. слегка прозрачный,
3. достаточно прозрачный (не пользуюсь, но, может, пригодится). :)

#+begin_src emacs-lisp :tangle yes
(defvar my/transparency-level 0
    "Transparence level for Emacs environment. Values: 0, 1 or 2.")

(defun my/change-transparency ()
    "Toggles transparency of Emacs between 3 settings (none, mild, moderate)."
    (interactive)
    (setq my/transparency-level (mod (+ 1 my/transparency-level) 3))
    (my/set-transparency))

(defun my/set-transparency (&optional frame)
    "Set current transparency from my/transparency-level variable."
    (interactive)
    (let ((true-frame (or frame (selected-frame))))
        (pcase my/transparency-level
            (0
             (set-frame-parameter true-frame 'alpha '(100 . 100)))
            (1
             (set-frame-parameter true-frame 'alpha '(85 . 85)))
            (2
             (set-frame-parameter true-frame 'alpha '(65 . 65))))))
#+end_src

Если открылся новый фрейм, то восстановим его прозрачность.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-make-frame-functions #'my/set-transparency)
#+end_src

Смену уровней прозрачности вешаем на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "t" '(:ignore t :which-key "toggles"))
(my/leader-def nil 'override
               "t t" #'my/change-transparency
               "t T" #'my/set-transparency)
#+end_src

** Настройка статусной панели (modeline)

Установим в панели отображение позиции курсора.

#+begin_src emacs-lisp :tangle yes
(setq mode-line-position (list "(%l,%C)"))
#+end_src

** Показ объекта внутри которого находится курсор (header-line)

Часто бывает нужно посмотреть, в каком объекте находится курсор. Это
может быть функция из программного кода или заголовок в org-mode или
что-то еще.

Сделаем такую строку.

#+begin_src emacs-lisp :tangle yes
(defun my/show-header-line ()
    (setq-default header-line-format
                  '((which-func-mode (" " which-func-format " ")))))

(defun my/hide-header-line ()
    (setq-default header-line-format nil))

(which-function-mode)
(my/show-header-line)
(setq mode-line-misc-info
      ;; We remove Which Function Mode from the mode line, because it's mostly
      ;; invisible here anyway.
      (assq-delete-all 'which-function-mode mode-line-misc-info))
#+end_src

Цвет текста в header-line перенастроим, поскольку по-умолчанию он слишком слепой.

Type [M-x list-faces-display] to see all colors.

#+begin_src emacs-lisp :tangle yes
(set-face-foreground 'which-func            "#7f9fff" )
#+end_src

** Установка текста в заголовке основного окна (фрейма)

Если размещать работу по разным фреймам, то скоро можно запутаться, в
каком из них что.  Здесь спасает текст в заголовке фрейма.  Нужно
иметь возможность назначать текст окна интерактивно.

Определим для этого соответствующую функцию. Неизменная часть
заголовка будет жить в переменной =my/application-name=.

#+begin_src emacs-lisp :tangle yes
(setq my/application-name "GNU EMACS"
      my/frames-texts (make-hash-table))

(defun my/make-title-bar-text (text)
    (concat text " - " my/application-name))

(defun my/set-title-bar (text)
    "Set title bar like: '<my-text> - <app-name>'.
Find application name in my/application-name variable."
    (let ((frame-text (my/make-title-bar-text text))
          (frame (selected-frame)))
        (set-frame-name frame-text)
        (puthash frame text my/frames-texts)
        frame-text))

(defun my/set-title-bar-interactive (text)
    "Interactive set title bar. Type 'M-x RET my/set-title-bar-interactive RET some-text'"
    (interactive (list (read-string "Enter text for title bar: "
                                    (my/--current-frame-text))))
    (my/set-title-bar text))

(defun my/--current-frame-text ()
    (let* ((frame (selected-frame))
           (text (gethash frame my/frames-texts)))
        (if (stringp text) text "")))
#+end_src

И повесим назначение заголовка окну на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "n" '(:ignore t :which-key "notes"))
(my/leader-def nil 'override
    "n i" '(my/set-title-bar-interactive :which-key "Set frame title"))
#+end_src

Ниже устанавливаем формат заголовка по умолчанию.

#+begin_src emacs-lisp :tangle yes
(setq frame-title-format
      '(multiple-frames "%b"
                        ("" "%b - " my/application-name)))
#+end_src

** Подсветка кодов цвета соответствующим цветом (rainbow mode)

Здесь на постоянку устанавливается подсветка фона у текстовых значений
цветов, например: #aa0000, #00aa00, #0000aa

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode
	:ensure t
	:config
	(define-globalized-minor-mode global-rainbow-mode rainbow-mode
		(lambda () (rainbow-mode 1))))
#+end_src

Можно выставить подсветку цветов везде по-умолчанию через вызов
=(global-rainbow-mode 1)=. Однако, она не дружит с некоторыми более
полезными режимами, такими как org-agenda. Так что оставим код ниже
только для примера.

#+begin_example emacs-lisp :tangle yes
(global-rainbow-mode 1)  ; Remove comment for turn on on start Emacs.
#+end_example

Лучше поставим режим rainbow-mode только для программного и org
режимов.

#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook (lambda () (rainbow-mode 1)))
(add-hook 'org-mode-hook (lambda () (rainbow-mode 1)))
#+end_src

** Отказываемся от диалоговых окон

Ибо не по emacs'ерски это. :)

#+begin_src emacs-lisp :tangle yes
(setq use-dialog-box nil)
;; (setq use-file-dialog nil)
;; (setq pop-up-windows nil)
#+end_src

** Тильды в конце буффера

В Vim было удобно видеть тильды "~" в конце буфера. Установим их.

#+begin_src emacs-lisp :tangle yes
(use-package vi-tilde-fringe
    :ensure t
    :config
    (global-vi-tilde-fringe-mode 1))
#+end_src

** Увеличение и уменьшение шрифта в окне

Нужно в основном во время демонстраций экрана.

#+begin_src emacs-lisp :tangle yes
(require 'face-remap)
(text-scale-mode 1)
#+end_src

Горячие клавиши, как в любом редакторе или консоли.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-=") #'text-scale-increase)
(global-set-key (kbd "C--") #'text-scale-decrease)
#+end_src

** Настройка окна компиляции (compilation)

Для окна компиляции выставим настройки:
- Гасить процесс компиляции перед началом нового.
- Запрос на сохранение всех буферов при старте компиляции.
- Останавливать прокрутку в окне компиляции при первой строчке с ошибкой.
- Цветная раскраска текста.

#+begin_src emacs-lisp :tangle yes
(require 'compile)

(setq compilation-always-kill t       ; kill compilation process before starting another
      compilation-ask-about-save t    ; save all buffers on `compile'
      compilation-scroll-output 'first-error)
(add-hook 'compilation-filter-hook #'my/apply-ansi-color-to-compilation-buffer)

(defun my/apply-ansi-color-to-compilation-buffer ()
    (with-silent-modifications
        (ansi-color-apply-on-region compilation-filter-start (point))))
#+end_src

* Регистры и операции с ними

** Общий буфер обмена для Emacs и ОС

Запретим для evil. Раздельные с ОС буфера обмена здесь удобней
(т.е. сделаем, как в оригинальном Vim).

#+begin_src emacs-lisp :tangle yes
(when my/evil
    (setq x-select-enable-clipboard nil))
#+end_src

** Быстрая работа с регистрами `+' и `"'

Часто нужно скопировать содержимое буфера ОС в буфер Emacs.  Тут будем
пользоваться регистрами "vim", предоставляемыми через evil-mode.

Ниже код копирует содержимое регистра `+' в регистр `"' по =Ctrl-,=.
Далее можно пользоваться =Ctrl-y= для вставки.

#+begin_src emacs-lisp :tangle yes
(defun my/copy-system-clipboard-to-emacs ()
    (interactive)
    (let ((text (evil-get-register ?+)))
        (evil-set-register ?\" text)
        (minibuffer-message (concat "Register `\"': " text))))

(global-set-key (kbd "C-,") #'my/copy-system-clipboard-to-emacs)
#+end_src

Аналогично в обратную сторону, из регистра `"' в `+' и `*'.

#+begin_src emacs-lisp :tangle yes
(defun my/copy-emacs-clipboard-to-system ()
    (interactive)
    (let ((text (evil-get-register ?\")))
        (evil-set-register ?+ text)
        (evil-set-register ?* text)
        (minibuffer-message (concat "Registers `+' and `*': " text))))

(global-set-key (kbd "C-;") #'my/copy-emacs-clipboard-to-system)
#+end_src

* Редактирование текста и интерфейс к нему

** Общие клавиши для редактирования текста

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "e a" 'align-regexp)
#+end_src

** Follow-mode - просматриваем непрерывный текст в нескольких буферах

Длинный текст можно центрировать в окне, а можно разделить окно и
просматривать непрерывно текст в получившихся разных буферах.

Повесим включение follow-mode на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override "e f" 'follow-mode)
#+end_src

** Отмена изменений на основе дерева (undo-tree)

Очень удобное окошко с деревом изменений по буферу.
Сразу отменим запись дерева изменений в файл.

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
	:ensure t
	:config
    (setq undo-tree-auto-save-history nil))
#+end_src

Подружим undo-tree с evil.

#+begin_src emacs-lisp :tangle yes
(setq evil-undo-system 'undo-tree
      evil-undo-function 'undo-tree-undo)
(global-undo-tree-mode 1)
(evil-set-undo-system 'undo-tree)
(add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode)
#+end_src

Чтобы в окошке с деревом изменений не помнить про клавишу "d"
(показать diff изменеий), включим ее эффект сразу при показе этого
окна.

#+begin_src emacs-lisp :tangle yes
(defun my/undo-tree-visualize ()
	(interactive)
	(undo-tree-visualize)
	(undo-tree-visualizer-toggle-diff))
#+end_src

И переопределим предустановленные из пакета клавиши "Ctrl-x u".

#+begin_src emacs-lisp :tangle yes
(define-key undo-tree-map (kbd "C-x u") #'my/undo-tree-visualize)
#+end_src

** Прокручивание текста

Ставим прокручивание текста мышкой по три строки, клавишами по одной и
забываем об этом.

#+begin_src emacs-lisp :tangle yes
(setq mouse-wheel-scroll-amount '(3 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+end_src

Прокрутка курсором по одной строке.

#+begin_src emacs-lisp :tangle yes
(if (>= emacs-major-version 30)
    (setq scroll-step 1
          scroll-preserve-screen-position t  ;; nil
          scroll-margin 1  ;; 0
          scroll-conservatively 10000  ;; 0
          maximum-scroll-margin 0.1  ;; 0.25
          scroll-up-aggressively 0.0   ;; nil
          scroll-down-aggressively 0.0)  ;; nil
    (setq scroll-step 1
          scroll-preserve-screen-position t  ;; nil
          scroll-margin 0  ;; 0
          scroll-conservatively 10000  ;; 0
          maximum-scroll-margin 0.0  ;; 0.25
          scroll-up-aggressively 0.0   ;; nil
          scroll-down-aggressively 0.0))  ;; nil
#+end_src

Начиная с Emacs 29, имеем плавную прокрутку по пикселям. Наконец-то
картинки при прокрутке не скачут на весь размер (ну, почти).

#+begin_src emacs-lisp :tangle yes
(when (fboundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode 1))
#+end_src

** Avy. Перемещение по всему редактору

Все любят =Avy=. Этот пакет позволяет перемещать курсор на любую
позицию видимого в редакторе текста. Текст этот может быть как в
активном окне, так и в любом другом.

Поставим пакет и назначим переход по двум символам или
последовательности символов.

#+begin_src emacs-lisp :tangle yes
(use-package avy
    :ensure t
    :config
    (my/evil-define-key '(normal visual) 'override
                        "g s s" #'evil-avy-goto-char-timer
                        "g s /" #'evil-avy-goto-char-2
                        "g s l" #'evil-avy-goto-line))
#+end_src

** Нумерация строк

В =evil-mode= самая удобная нумерация строк - относительная.  Выставим
по-умолчанию относительную нумерацию, если [[id:44f272c6-5f95-440f-8a1f-1766fe438feb][редактор запущен в режиме EVIL]],
или оставим привычную нумерацию в противном случае.

Ширину для номеров строк сделаем в четыре символа (по-умолчанию -
три).

#+begin_src emacs-lisp :tangle yes
(setq-default display-line-numbers-width 4)
#+end_src

Зададим в переменной нумерацию строк по-умолчанию.

#+begin_src emacs-lisp :tangle yes
(if my/evil
    (setq my/display-line-numbers 'relative)
    (setq my/display-line-numbers 'value))
#+end_src

Определим функции переключения нумерации строк.
Действовать будем через локальные переменные буферов
~display-line-numbers~.

#+begin_src emacs-lisp :tangle yes
(defun my/display-line-numbers (&optional arg)
    (interactive)
    (cond ((not arg)
           (if display-line-numbers
               (setq-local display-line-numbers nil)
               (setq-local display-line-numbers my/display-line-numbers)))
          ((or (equal t arg) (> arg 0))
           (setq-local display-line-numbers my/display-line-numbers))
          ((< arg 0)
           (setq-local display-line-numbers nil))))

(defun my/display-next-line-numbers ()
    (interactive)
    (pcase display-line-numbers
        (`relative
         (setq-local display-line-numbers 'value))
        (`value
         (setq-local display-line-numbers nil))
        (_
         (setq-local display-line-numbers 'relative))))
#+end_src

Теперь покажем номера строк для текстовых и программных режимов.

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook (lambda () (my/display-line-numbers 1)))
(add-hook 'prog-mode-hook (lambda () (my/display-line-numbers 1)))
(add-hook 'org-mode-hook (lambda () (my/display-line-numbers 1)))
#+end_src

Горячие клавиши смены показа нумерации строк.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t l" '(my/display-next-line-numbers
            :which-key "Change line numbers")
    "t L" '((lambda ()
                (interactive)
                (my/display-line-numbers 1))
            :which-key "Default line numbers"))
#+end_src

** Wgrep. Отслеживаем не сохраненное во всех буферах

При выходе из редактора тот предупредит о не сохраненных буферах.

#+begin_src emacs-lisp :tangle yes
(use-package wgrep
    :ensure t)
#+end_src

** Автоотступ (indent)

Четыре пробела - лучший отступ.

#+begin_src emacs-lisp :tangle yes
(setq-default tab-width 4) ;; ширина табуляции - 4 пробельных символа
(setq-default c-basic-offset 4)
(setq-default standart-indent 4) ;; стандартная ширина отступа - 4 пробельных символа
(setq-default plantuml-indent-level 4)
(setq-default lisp-body-indent 4) ;; сдвигать lisp-выражения на 4 пробельных символа
(setq lisp-indent-function 'common-lisp-indent-function)
(setq-default c-basic-offset 4)
(setq-default c-ts-mode-indent-offset 4)
#+end_src

** ESC-кодирование для работы с URL

Часто бывает нужно кодировать и раскодировать URL, например, как в Python:

#+begin_example python
from urllib.parse import quote, unquote
#+end_example

Сделаем аналоги функций =quote= и =unquote= из Python'а:
- =my/quote-reion=
- =my/unquote-reion=
Они интерактивны и работают с выделенными в тексте URL'ами.

#+begin_src emacs-lisp :tangle yes
(defun my/quote-url (url-text)
    "Quote URL to esc-sequence."
    (url-encode-url url-text))

(defun my/unquote-url (url-text)
    "Unquote URL from esc-sequence to UTF-8."
    (decode-coding-string (url-unhex-string url-text) 'utf-8))

(defun my/quote-region ()
    "Quote text (like URL) in region."
    (interactive)
    (let ((beg (region-beginning))
          (end (region-end))
          (text))
        (setq text (buffer-substring-no-properties beg end))
        (kill-region beg end)
        (insert (my/quote-url text))))

(defun my/unquote-region ()
    "Unquote text (like URL) in region."
    (interactive)
    (let ((beg (region-beginning))
          (end (region-end))
          (text))
        (setq text (buffer-substring-no-properties beg end))
        (kill-region beg end)
        (insert (my/unquote-url text))))
#+end_src

Горячие клавиши не назначал. Пользуемся =M-x=.

** Более привычная раскладка клавиш для evil-mode (ближе к Vim и консоли)

Переносим привычные клавиши передвижения, удаления и ввода и в Emacs тоже.

#+begin_src emacs-lisp :tangle yes
(define-key evil-insert-state-map (kbd "C-j") (kbd "RET"))
(define-key evil-replace-state-map (kbd "C-j") (kbd "RET"))
(define-key evil-normal-state-map (kbd "C-j") (kbd "j"))
(define-key evil-visual-state-map (kbd "C-j") (kbd "j"))
(define-key evil-insert-state-map (kbd "C-h") (kbd "<backspace>"))
(define-key evil-replace-state-map (kbd "C-h") (kbd "<backspace>"))
(define-key evil-normal-state-map (kbd "C-h") (kbd "h"))
(define-key evil-visual-state-map (kbd "C-h") (kbd "h"))
#+end_src

А удалению символа влево - особое место. Удобно при наборе пути в Ivy или Helm.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-h") 'delete-backward-char)
#+end_src

После такого надо реанимировать вызов части полезных функций из Emacs.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "h c" #'helpful-command)
(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

Убираем неудобные сочетания клавиш:
- закрытие окна по Ctrl+x, Ctrl+c,
- удаление слова перед курсором по Ctrl+Backspace.

#+begin_src emacs-lisp :tangle yes
(unbind-key (kbd "C-x C-c"))
(unbind-key (kbd "<C-backspace>"))
#+end_src

** Переключение раскладки клавиатуры

Внутри Vim и evil-mode много удобней иметь внутренне переключение
раскладки клавиатуры. Такое переключение позволяет пользоваться
командами модального режима вне зависимости от состояния раскладки. И,
хотя, переключение в evil-mode работает хуже, чем в Vim, все равно оно
того стоит.

#+begin_src emacs-lisp :tangle yes
(set-input-method 'russian-computer)
(global-set-key (kbd "C-c d") #'toggle-input-method)
#+end_src

Во время поиска в Ex-режиме нельзя задать аккорд, поэтому переключение
раскладки в Ex ставим на сокращенное сочетание =C-d=. (Придется
помнить.)

#+begin_src emacs-lisp :tangle yes
(define-key evil-ex-search-keymap (kbd "C-d") #'toggle-input-method)
(define-key evil-ex-map (kbd "C-d") #'toggle-input-method)
#+end_src

** Схлопывание текста (yafolding)

Выбрал пакет =yafolding=. Объект схлопывания определяется по
отступам. Есть три варианта схлопывания:
- объекта,
- родительского объекта,
- всех объектов (может сильно тормозить).

#+begin_src emacs-lisp :tangle yes
(use-package yafolding
	:ensure t
	:config
	(add-hook 'buffer-list-update-hook 'yafolding-mode))
#+end_src

Текст на месте сворачивания.

#+begin_src emacs-lisp :tangle yes
(setq yafolding-ellipsis-content "•••")
#+end_src

Но также удобно схлопывать выделенный текст. Для этого допишем
yafolding-toggle-element. Можно сочетать с выделением блоков в коде
через treesit.

#+begin_src emacs-lisp :tangle yes
(defun my/yafolding-toggle-element ()
    (interactive)
    (if (not (use-region-p))
        (yafolding-toggle-element)
        (yafolding-hide-region (use-region-beginning)
                               (use-region-end))
        (deactivate-mark)))
#+end_src

Назначим горячие клавиши для схлопывания текста.

#+begin_src emacs-lisp :tangle yes
(my/leader-def '(normal visual motion) 'override
               "y" '(:ignore t :which-key "folding")
               "y RET" #'my/yafolding-toggle-element
               "y p" #'yafolding-hide-parent-element
               "y f" #'yafolding-toggle-all)
#+end_src

** Подсветка отступов (highlight-indent-guides)

Можно подсветить верткальньной "чертой" отступы в тексте. Почти всегда
это удобно. Подсвечивать можно или символом "|", что не всегда
работает гладко, или перекрашивая фон у символов (тут без проблем).

/Замечание:/ Highlighitng-indent-guides сильно тормозит работу с
длинными файлами по причине частого вызова функции redisplay. Поэтому
подсветку отступов исключаем для режимов org-mode, markdown-mode и
json-mode.  Последний из них еще подключается с минорным режимом
prog-mode, поэтому делаем свою функцию проверки на режимы, в которых
отступы подсвечиваться не должны.

#+begin_src emacs-lisp :tangle yes
(use-package highlight-indent-guides
	:ensure t
    :config
	(setq highlight-indent-guides-method 'column)
    (dolist (mode '(prog-mode-hook
                    yaml-mode-hook))
        (add-hook mode 'my/--highlight-indent-guides-mode)))

(defun my/--highlight-indent-guides-mode (&optional arg)
    (unless (member major-mode '(json-mode
                                 org-mode-hook
                                 markdown-mode-hook))
        (highlight-indent-guides-mode arg)))
#+end_src

** Подсветка отступов (indent-bars)

Подсветка отступов [[https://github.com/jdtsmith/indent-bars][indent-bars]]
(более быстрая, чем hilight-indent-guides-mode, но халтурная).

Умеет поддерживать tree-sitter (надо доработать конфигурацию).

#+begin_src emacs-lisp :tangle yes
(use-package indent-bars
    :ensure t
    :hook ((json-mode
            ) . indent-bars-mode))
#+end_src

** Проверка орфографии

Проверка орфографии делается на основе утилиты hunspell. Ее нужно
предварительно установить в систему.
: sudo pacman -S hunspell

Словари лежат в директории настроек редактора ../dictionaries/hunspell/.
Чтобы утилита hunspell имела к ним доступ, установим переменную среды DICPATH.

#+begin_src emacs-lisp :tangle yes
(setenv "DICPATH" (file-name-concat my/config-dir "/dictionaries/hunspell/"))
#+end_src

Осталось настроить ispell. Код ниже работает как по русским, так и по английским словам.

#+begin_src emacs-lisp :tangle yes
(when (executable-find "hunspell")
    (setq ispell-local-dictionary-alist '(("russian"
             "[АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюяA-Za-z]"
             "[^АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюяA-Za-z]"
             ""  ;; было "[-']", но убрал, чтобы эти символы не мешали обнаружению ошибок.
             nil ("-d" "ru_RU,en_US") nil utf-8))
          ispell-program-name "hunspell"
          ispell-dictionary "russian"
          ispell-really-aspell nil
          ispell-really-hunspell t
          ispell-encoding8-command t
          ispell-silently-savep t))
#+end_src

Включаем проверку синтаксиса на лету в emacs с помощью =flyspell-mode=.
Автоматическое его включение ставим только на редактирование литературных
текстов (text, org, markdown и т.п.).

#+begin_src emacs-lisp :tangle yes
(dolist (hook '(text-mode-hook
                org-mode-hook
                markdown-mode-hook))
    (add-hook hook (lambda ()
                       (flyspell-mode 1))))
#+end_src

Горячие клавиши для flyspell-mode оказались неудобными для меня. Выпилим их.

#+begin_src emacs-lisp :tangle yes
(require 'flyspell)
(assq-delete-all 'flyspell-mode minor-mode-map-alist)
(define-key flyspell-mode-map (kbd "C-,") nil)
(define-key flyspell-mode-map (kbd "C-;") nil)
#+end_src

Подсказки по исправлению слова зашиты на функцию =ispell-word=.

** Сниппеты (Yasnippet)

Сниппет в Emacs - это заранее подготовленный кусок текста, который
можно вставить себе в документ при редактировании.  Очень удобный и
полезный инструмент! Сниппеты могут на лету доопределяться параметрами
и быть привязаны к разным типам документов.

Грузим пакеты, указываем директорию со своими сниппетами.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
    :ensure t
    :config
    (add-to-list 'yas-snippet-dirs (file-name-concat my/config-dir "/snippets"))
    (yas-global-mode 1))
(use-package yasnippet-classic-snippets
    :ensure t)
(use-package yasnippet-snippets
    :ensure t)
(use-package ivy-yasnippet
    :ensure t)
#+end_src

Горячие клавиши для выбора сниппета по его названию.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "I" '(:ignore t :which-key "insert"))
(my/leader-def nil 'override
               "I s" #'yas-insert-snippet)
#+end_src

** Закладки

Есть очень удобные встроенные закладки.  Запоминают не только строку в
буфере, но и позицию в строке.  Закладки сохраняются даже если буфер
был закрыт.

Назначим дополнительные горячие клавиши с лидером.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "j" '(:ignore t :which-key "jump"))
(my/leader-def nil 'override
               "j m" '(:ignore t :which-key "bookmarks")
               "j m m" #'counsel-bookmark
               "j m j" #'bookmark-jump
               "j m s" #'bookmark-save
               "j m l" #'bookmark-bmenu-list
               "j m p" #'bookmark-set
               "j m d" #'bookmark-delete)
#+end_src

** Работа с Kill-ring

Бывает нужно выбрать какой-то из текстов, лежащих в буферах
обмена. Проще всего это сделать, заглянув в kill-ring.

Здесь нужны только горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c y") #'yank-from-kill-ring)
#+end_src

** Контекстное меню по правой клавише мыши

Сделаем привычное контекстное меню по правой клавише мыши.

#+begin_src emacs-lisp :tangle yes
(global-set-key [mouse-3]
                (lambda ()
                    (interactive)
                    (unless (use-region-p)
                        (mouse-set-point last-input-event)
                        (redisplay t))
                    (context-menu-open)))
#+end_src

** Выделение. Прямоугольная область выделения по Ctrl и клавише мышки

Сделаем прямоугольное выделение по Ctrl с левой клавишей мышки.

Сочетание =Ctrl-x пробел= по-прежнему включает начало прямоугольного
выделения, если нужно выделять клавишами.

(Почти работает в normal режиме.)

#+begin_src emacs-lisp :tangle yes
(if (not my/evil)
    (progn
        (global-set-key [C-down-mouse-1] #'mouse-drag-region-rectangle))
    (progn
        (defun my/mouse-start-rectangle (start-event)
            (interactive "e")
            (deactivate-mark)
            (mouse-set-point start-event)
            (rectangle-mark-mode +1)
            (let ((drag-event))
                (track-mouse
                    (while (progn
                               (setq drag-event (read-event))
                               (mouse-movement-p drag-event))
                        (mouse-set-point drag-event)))))

        (global-set-key (kbd "C-<down-mouse-1>") #'my/mouse-start-rectangle)))
#+end_src

* Подсказки, выпадашки, автодополнения

** Ivy - меню с поиском по частичному совпадению

=Ivy= - одно из самых удобных меню с выбором элементов по частичному совпадению
текста. Есть более новый =Vertico=, но сперва сделаю, к чему привык.

#+begin_src emacs-lisp :tangle yes
(use-package ivy
    :ensure t
    :config
    (ivy-mode)
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-wrap t))
(use-package ivy-hydra
    :ensure t)
#+end_src

Определим горячие клавиши на восстановление результатов последней
сессии ivy.  (Помним, что буфер с результатами поиска можно
зафиксировать клавишами =Ctrl-c Ctrl-o=.)

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "'" #'ivy-resume)
#+end_src

** Подсказки на клавиши

При вводе клавишного аккорда получаем подсказку на его продолжение.

#+begin_src emacs-lisp :tangle yes
(use-package guide-key
    :ensure t
    :diminish guide-key-mode)
(use-package which-key
    :ensure t
    :config
    (setq which-key-sort-order 'which-key-key-order-alpha
          which-key-sort-uppercase-first nil)
    (which-key-mode 1))
#+end_src

Пакет ниже дает развернутые подсказки. Поставим такую на подсказку для клавиш.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
    :ensure t
    :config
    (my/leader-def nil 'override
                   "h k" '(helpful-key :which-key "Describe key")))
(my/leader-def nil 'override
               "h" '(:ignore t :which-key "help"))
#+end_src

** Counsel. Меню вызова функции с более полным описанием

Здесь нужен пакет =counsel=. Функциями из него подменяем стандартные.
Отключаем предпоказ содержимого буферов при их выборе в меню.

#+begin_src emacs-lisp :tangle yes
(use-package counsel
    :ensure t
    :config
    (setq counsel-switch-buffer-preview-virtual-buffers nil))
(use-package counsel-projectile
    :ensure t
    ;; :config
    ;; (counsel-projectile-mode 1)
    ;; (ivy-set-display-transformer #'counsel-projectile-find-file nil)
    )
#+end_src

При поиске текста по проекту через =counsel-projectile-rg= нужно
заходить в скрытые папки, но не трогать .git.  Сделаем настройки
для ripgrep (добавим туда "--hidden" и "-g!.git").

#+begin_src emacs-lisp :tangle yes
;; (setq counsel-rg-base-command
;;       '("rg" "--max-columns" "240" "--with-filename" "--no-heading"
;;         "--line-number" "--color" "never" "--hidden" "-g!.git" "%s" "|| true"))
(setq counsel-rg-base-command "rg --max-columns 240 --with-filename --no-heading --line-number --color never --hidden -g!.git %s || true")
#+end_src

Уберем "^" из начала поисковой строки в counsel и вообще в Ivy.

#+begin_src emacs-lisp :tangle yes
(setq ivy-initial-inputs-alist
      '((counsel-minor . "+")
        (counsel-package . "+")
        (counsel-org-capture . "")
        (counsel-M-x . "")
        (counsel-describe-symbol . "")
        (org-refile . "")
        (org-agenda-refile . "")
        (org-capture-refile . "")
        (Man-completion-table . "")
        (woman . "")))

#+end_src

Подменим стандартные функции на их counsel-аналог.
Так, как это закомментарено ниже, не будет работать.
Позже допилю другое решение.

# #+begin_src emacs-lisp :tangle yes
# (advice-add #'find-library :override #'counsel-find-library)
# (advice-add #'info-lookup-symbol :override #'counsel-info-lookup-symbol)
# (advice-add #'locate :override #'counsel-locate)
# (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
# (global-set-key (kbd "C-c g") 'counsel-git)
# (global-set-key (kbd "C-c j") 'counsel-git-grep)
# (global-set-key (kbd "C-c k") 'counsel-ag)
# (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
# #+end_src

Определяем действия =counsel= на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(setq suggest-key-bindings t)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-r") #'counsel-minibuffer-history)
(my/leader-def nil 'override
               ":" '(counsel-M-x :which-key "M-x")
               "h f" '(counsel-describe-function :which-key "Describe function")
               "h v" '(counsel-describe-variable :which-key "Describe variable")
               "h p" '(describe-package :which-key "Describe package")
               "h o" '(counsel-describe-symbol :which-key "Descrive symbol")
               "h t" '(counsel-load-theme :which-key "Load visual theme")
               "h a" '(counsel-apropos :which-key "Apropos")
               "h m" '(describe-mode :which-key "Describe mode")
               "h i" '(emacs-index-search :which-key "Emacs index search"))
#+end_src

** Company. Автодополнения

Строим автодополнения через =Company= и =Ivy=.

#+begin_src emacs-lisp :tangle yes
(use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode))
(use-package company-dict
    :ensure t)
(use-package company-box
    :ensure t)
(use-package company-restclient
    :ensure t)
(use-package ivy-hydra
    :ensure t)
(use-package company-shell
    :ensure t)
#+end_src

Чтобы автодополнения не были в lovercase, добавим следующее
(по-умолчанию было 'case-replace):

#+begin_src emacs-lisp :tangle yes
(setq-default company-dabbrev-downcase nil)
#+end_src

А автодополнять начнем с двух символов (по-умолчанию три).

#+begin_src emacs-lisp :tangle yes
(setq company-minimum-prefix-length 2)
#+end_src

Назначим горячие клавиши для переключения ~company-mode~. Это нужно
при работе на удаленных машинах, поскольку синхронная задержка мешает.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "e c" 'company-mode)
#+end_src

** Наполнение полезным содержимым ivy-меню

Теперь грузим пакет ivy-rich, который эту красоту и поддерживает.

#+begin_src emacs-lisp :tangle yes
(use-package ivy-rich
    :ensure t)
#+end_src

Очень удобно при поиске описания переменной сразу видеть в минибуфере
значения всех кандидатов.

Чтобы так сделать, напишем трансформер для ivy (взято из Doom).

#+begin_src emacs-lisp :tangle yes
(defun doom/ivy-rich-describe-variable-transformer (cand)
	"Previews the value of the variable in the minibuffer"
	(let* ((sym (intern cand))
		   (val (and (boundp sym) (symbol-value sym)))
		   (print-level 3))
		(replace-regexp-in-string
		 "[\n\t\^[\^M\^@\^G]" " "
		 (cond ((booleanp val)
				(propertize (format "%s" val) 'face
							(if (null val)
								'font-lock-comment-face
								'success)))
			   ((symbolp val)
				(propertize (format "'%s" val)
							'face 'highlight-quoted-symbol))
			   ((keymapp val)
				(propertize "<keymap>" 'face 'font-lock-constant-face))
			   ((listp val)
				(prin1-to-string val))
			   ((stringp val)
				(propertize (format "%S" val) 'face 'font-lock-string-face))
			   ((numberp val)
				(propertize (format "%s" val) 'face 'highlight-numbers-number))
			   ((format "%s" val)))
		 t)))
#+end_src

Теперь осталось воспользоваться этим трансформером в списке
=ivy-rich-display-transformers-list=.  В этом списке описываются
колонки и правила их заполнения для мининбуфера ivy.

#+begin_src emacs-lisp :tangle yes
(plist-put ivy-rich-display-transformers-list
           'counsel-describe-variable
           '(:columns
             ((counsel-describe-variable-transformer (:width 40))
              (doom/ivy-rich-describe-variable-transformer (:width 50))
              (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face)))))
#+end_src

Информация о пакетах.

#+begin_src emacs-lisp :tangle yes
(plist-put ivy-rich-display-transformers-list
           'package-install
           '(:columns
             ((ivy-rich-candidate (:width 30))
              (ivy-rich-package-version (:width 16 :face font-lock-comment-face))
              (ivy-rich-package-archive-summary (:width 7 :face font-lock-builtin-face))
              (ivy-rich-package-install-summary (:face font-lock-doc-face)))))
#+end_src

# Поиск файлов.
#
# #+begin_src emacs-lisp :tangle yes
# (let ((funcs '(counsel-find-file
#                find-file)))
#     (dolist (func funcs)
#         (plist-put ivy-rich-display-transformers-list
#                    func
#                    '(:columns
#                      ((ivy-read-file-transformer)
#                       (ivy-rich-counsel-find-file-truename
#                        (:face font-lock-doc-face)))))))
# #+end_src

Для остальных выборов буферов тоже выведем информацию о
кандидатах.

#+begin_src emacs-lisp :tangle yes
(let ((funcs '(persp-switch-to-buffer
               projectile-switch-to-buffer-other-window
               projectile-switch-to-buffer
               projectile-read-buffer-to-switch
               counsel-switch-buffer-other-window))
      (actions (plist-get ivy-rich-display-transformers-list
                          'ivy-switch-buffer)))
    (dolist (func funcs)
        (plist-put ivy-rich-display-transformers-list
                   func
                   actions)))
#+end_src

Выделение в буфере ivy на размер текста в строке очень раздражает,
поскольку не всегда видно, что выбрано.  Намного удобней выделение
строки на всю ширину окна.  К сожалению, я пока что не нашел, как
установить описание колонок по-умолчанию, поэтому обхожусь костылем
ниже.

#+begin_src emacs-lisp :tangle yes
(let ((funcs '(my/persp-frame-switch
               persp-kill
               counsel-find-file
               find-file
               my/make-frame-and-switch-perpective
               counsel-projectile-switch-project
               projectile-switch-project
               my/switch-project-with-workspace-safe-title
               my/switch-project-with-workspace
               counsel-projectile-find-file
               projectile-find-file
               load-file
               swiper
               counsel-imenu
               counsel-org-goto
               describe-package
               counsel-load-theme
               load-theme
               counsel-apropos
               apropos
               )))
    (dolist (func funcs)
        (plist-put ivy-rich-display-transformers-list
                   func
                   '(:columns
                     ((ivy-rich-candidate (:width 1.0)))))))
#+end_src

Включаем информацию в ivy поиске.

#+begin_src emacs-lisp :tangle yes
(ivy-rich-mode 1)
#+end_src

** Некоторые дополнения пакетов

Копирую сюда установку некоторых пакетов из прошлых конфигов.
Прокомментирую как-нибудь позже.

#+begin_src emacs-lisp :tangle yes
(use-package amx
    :ensure t)
(use-package flx
    :ensure t)
(use-package prescient
    :ensure t)
(use-package ivy-posframe
    :ensure t)
(use-package all-the-icons-ivy
    :ensure t)
#+end_src

** Клавиши перемещения по минибуферу

Вернем более привычное мне перемещение по строкам минибуферов, как было в Doom:
Ctrl + jk. Собственно, из него и беру код ниже.

#+begin_src emacs-lisp :tangle yes
(setq my/default-minibuffer-maps (list minibuffer-local-map
                                       minibuffer-local-ns-map
                                       minibuffer-local-completion-map
                                       minibuffer-local-must-match-map
                                       minibuffer-local-isearch-map
                                       read-expression-map
                                       ivy-minibuffer-map
                                       ivy-switch-buffer-map))

(mapc (lambda (key-map)
          (define-key key-map (kbd "C-j") #'next-line)
          (define-key key-map (kbd "C-k") #'previous-line)
          (define-key key-map (kbd "C-S-j") #'scroll-up-command)
          (define-key key-map (kbd "C-S-k") #'scroll-down-command))
      my/default-minibuffer-maps)

(mapc (lambda (key-map)
          (evil-define-key 'insert key-map (kbd "C-j") #'next-line)
          (evil-define-key 'insert key-map (kbd "C-k") #'previous-line))
      my/default-minibuffer-maps)

(define-key read-expression-map (kbd "C-j") #'next-line-or-history-element)
(define-key read-expression-map (kbd "C-k") #'previous-line-or-history-element)
#+end_src

* Поиск и выделение

** Swiper. Удобный живой поиск текста по открытому буфферу

Очень удобный поиск текста по открытому буферу. Результаты показываются в
минибуфере по мере ввода поискового текста.

#+begin_src emacs-lisp :tangle yes
(use-package swiper
    :ensure t)
#+end_src

Горячие клавиши для вызова поиска swiper.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "s" '(:ignore t :which-key "search"))
(my/leader-def nil 'override
               "s s" '(swiper :which-key "Search buffer")
               "s S" '(swiper-isearch-thing-at-point
                       :which-key "Search buffer for thing at point")
               "s b" '(counsel-grep-or-swiper :which-key "Grep or search buffer"))
#+end_src

** Поиск на стартовой странице Emacs

Были проблемы поиска текста на стартовой странице Doom Emacs.
Проблемы решены следующим способом.

#+begin_src emacs-lisp :tangle yes
(set-input-method 'russian-computer)
(isearch-toggle-input-method)
#+end_src

** Выделение при поиске по тексту

Не отключаем выделение по всему тексту при поиске.

#+begin_example emacs-lisp :tangle yes
(setq evil-ex-search-highlight-all nil)
#+end_example

** Символ технического пробела `_'

Emacs по-умолчанию не причисляет символ `_' к составу слова, что очень неудобно.
Исправим положение.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-change-major-mode-hook
          (lambda ()
              (modify-syntax-entry ?_ "w")))
(modify-syntax-entry ?_ "w")
#+end_src

** Чувствительность к регистру (прописные и строчные символы)

Чувствительность нужна и важна (особенно при поиске).

Есть три параметра настройки:
- =sensitive=,
- =insensitive=,
- =smart=
Возможно, =smart= даже удобней.

Use [M-x toggle-case-fold-search] to toggle mode.

#+begin_src emacs-lisp :tangle yes
(setq case-fold-search nil)  ; Use [M-x toggle-case-fold-search] to toggle mode.
(setq evil-ex-search-case 'smart)  ; sensitive, insensitive, smart
#+end_src

** Imenu. Навигация по документу через меню

Imenu - дает не только удобный способ навигации по документу, но и
показывает его структуру.  Если это текстовый файл с разметкой (org),
то определит в нем заголовки (оглавление).  Если это программный код,
то определит в нем классы и функции.

Определим глубину заголовков (два по-умолчанию - это очень мало).

#+begin_src emacs-lisp :tangle yes
(setq org-imenu-depth 8)
#+end_src

Определим горячие клавиши для навигации через imenu.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "s i" '(counsel-imenu :which-key "IMenu"))
#+end_src

Установим дополнтельный пакет, который в отдельном окне отображает
оглавление.

#+begin_src emacs-lisp :tangle yes
(use-package imenu-list
    :ensure t
    :config
    (my/leader-def nil 'override
                   "s I" '(imenu-list-smart-toggle :which-key "IMenu content")))
#+end_src

Отменим перенос строк по умолчанию в окне оглавления.

#+begin_src emacs-lisp :tangle yes
(add-hook 'imenu-list-major-mode-hook 'my/--unwrap-words)

(defun my/--unwrap-words ()
    (my/set-word-wrap 1))
#+end_src

** Выделение по регулярному выражению (highlight)

Выделять текст будем функцией highlight-regexp.
Но ей неудобно пользоваться часто. Автоматизируем кое-что:
- При отсутствии выделения берем слово под курсором,
- Выделенный или полученный текст окружаем в маркеры границ
  слова "\<" и "\>".

#+begin_src emacs-lisp :tangle yes
(defun my/highlihth-regexp ()
    (interactive)
    (let* ((beg (region-beginning))
           (end (region-end))
           (region-text (buffer-substring-no-properties beg end)))
        (if (or (not (use-region-p))
                (string-empty-p region-text))
            (progn (setq region-text (concat "\\<" (word-at-point t) "\\>"))
                   (highlight-regexp region-text 'isearch))
            (highlight-regexp (concat "\\<" region-text "\\>")
                              'isearch))))
#+end_src

Здесь запилим горячие клавиши для вызова функций (highlight-regexp) и
(unhighlight-regexp). С их помощью будем выделять текст и снимать
выделение точечно по каждой регулярке.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "s h" 'highlight-regexp
               "s H" 'my/highlihth-regexp
               "s u" 'unhighlight-regexp)
#+end_src

* Работа с вкладками (tab)

** Новая именованная вкладка

Создает новую вкладку и интерактивно назначает ей имя. Один прокол - полоса во вкладками почему-то сразу не показывается. Дерганье соответствующих функций показа не помогает.

#+begin_src emacs-lisp :tangle yes
(defun my/new-tab-with-name (tab-name)
    (interactive (list (read-string "Enter a name for new tab: ")))
    (tab-bar-new-tab)
    (tab-rename tab-name)
    (tab-bar-mode -1)
    (message "Tab \"%s\" is active." tab-name))
#+end_src

Горячие клавиши для интерактивно именованной вкладки.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x t a") #'my/new-tab-with-name)
#+end_src

* Работа с фреймами

** Клавиши для работы с фреймами

Здесь определим набор клавиш для привычных действий с фреймами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "q" '(:ignore t :which-key "quite/close"))
(my/leader-def nil 'override
    "o f" '(make-frame :which-key "Make frame")
    "q f" '(delete-frame :which-key "Delete frame"))
#+end_src

** Поиск фрейма по имени

Поиск фрейма по имени. Результат - найденный фрейм с указанным именем или nil.
(Для справки: Есть функция =select-frame-by-name=, которая по имени находит фрейм и активизирует его.)

#+begin_src emacs-lisp :tangle yes
(defun my/get-frame-by-name (name)
    "If there is a frame named NAME, return it, else nil."
    (-some (lambda (frame)
               (when (equal name (frame-parameter frame 'name))
                   frame))
           (frame-list)))
#+end_src

** Вид окон при открытии нового фрейма

Когда появляется новый клиент, то хорошо бы скрыть все, что было во
фрейме ранее открытого клиента.  Для этого оставим в нем только одно
окно и выведем в него приветственный буфер (dashboard).

Но сперва предусмотрим случай, когда этого не нужно. Сделаем флажок и
функцию, которая им управляет.

#+begin_src emacs-lisp :tangle yes
(setq my/prepare-windows-in-new-frame t)

(defun my/prepare-windows-in-new-frame (&optional arg)
    (let ((result my/prepare-windows-in-new-frame))
        (if (eq arg 'charge)
            (setq my/prepare-windows-in-new-frame nil)
            (setq my/prepare-windows-in-new-frame t))
        result))
#+end_src

Теперь сам хук.

#+begin_src emacs-lisp :tangle yes
(add-hook 'my/server-after-make-frame-hook
          'my/call-prepare-widnows-in-new-frame)

(defun my/call-prepare-widnows-in-new-frame (&optional frame)
    (when (my/prepare-windows-in-new-frame)
        (persp-switch "main")
        (switch-to-buffer "*scratch*")
        (switch-to-buffer "*dashboard*")
        (delete-other-windows)))
#+end_src

* Работа с окнами

** Клавиши для работы с окнами

В целом, все уже есть в evil и вызывается по Ctrl-w.
Но верну сочетания клавиш, к которым привык в Doom.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "w" '(:ignore t :which-key "windows")
               "w d" #'evil-window-delete
               "w r" #'evil-window-rotate-downwards
               "w R" #'evil-window-rotate-upwards
               "w =" #'balance-windows
               "w l" #'evil-window-right
               "w h" #'evil-window-left
               "w j" #'evil-window-down
               "w k" #'evil-window-up
               "w C-S-l" #'evil-window-move-far-right
               "w C-S-h" #'evil-window-move-far-left
               "w C-S-j" #'evil-window-move-very-bottom
               "w C-S-k" #'evil-window-move-very-top)
#+end_src

Малое изменение размеров окон.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-{") 'my/shrink-window-horizontally)
(global-set-key (kbd "C-}") 'my/enlarge-window-horizontally)
(global-set-key (kbd "C-(") 'shrink-window)
(global-set-key (kbd "C-)") 'enlarge-window)

(defun my/shrink-window-horizontally ()
    (interactive)
    (shrink-window-horizontally 4))

(defun my/enlarge-window-horizontally ()
    (interactive)
    (enlarge-window-horizontally 4))
#+end_src

Отдельно перетащим из Doom расширение окон по горизонтали и вертикали.

#+begin_src emacs-lisp :tangle yes
(defun doom/window-maximize-horizontally ()
	"Delete all windows to the left and right of the current window."
	(interactive)
	(require 'windmove)
	(save-excursion
		(while (ignore-errors (windmove-left)) (delete-window))
		(while (ignore-errors (windmove-right)) (delete-window))))

(defun doom/window-maximize-vertically ()
	"Delete all windows above and below the current window."
	(interactive)
	(require 'windmove)
	(save-excursion
		(while (ignore-errors (windmove-up)) (delete-window))
		(while (ignore-errors (windmove-down)) (delete-window))))
#+end_src

"Максимизация" окон.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
	"w m m" #'delete-other-windows
	"w m s" #'doom/window-maximize-horizontally
	"w m v" #'doom/window-maximize-vertically)
#+end_src

Сохранение и восстановление расположения окон через хранение в
регистрах. По-умолчанию работа с регистрами доступна через клавиши
- ~C-x r w~ - сохранить положение окон в регистр (выбирается буквой).
- ~C-x r j~ - вернуть расположение из регистра.

Однако, сделаем более привычные клавиши через клавишу лидера:

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "w p" '(:ignore 1 :which-key "Position of windows")
    "w p s" '(window-configuration-to-register :which-key "Save to register")
    "w p l" '(jump-to-register :which-key "Restore from register"))
#+end_src

** Нумерация окон

Работа с окнами на основе их нумерации. Нумерацию окон устанавливаем
локальньно, в текущем фрейме (переменная =winum-scope=).

#+begin_src emacs-lisp :tangle yes
(use-package winum
    :ensure t
    :config
    (winum-mode 1)
    (setq winum-scope 'frame-local))
#+end_src

** Разделение рабочего пространства на заданное количество окон

Взято из Spacemacs. Рабочее пространство разделяется по <leader>-w-<Num> на
заданное количество окон (от одного до четырех). Буфера по окнам распределяются
в порядке очереди и выбираются из текущего проекта.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "w 1" '(spacemacs/window-split-single-column :which-key "Window split single column")
    "w 2" '(spacemacs/window-split-double-columns :which-key "Window split double columns")
    "w 3" '(spacemacs/window-split-triple-columns :which-key "Window split triple columns")
    "w 4" '(spacemacs/window-split-grid :which-key "Window split grid"))
#+end_src

** Переключение окон, как в Spacemacs

Переключение окон по <leader>-<Num>.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "0" '(treemacs-select-window :which-key "Select window 0")
    "1" '(winum-select-window-1 :which-key "Select window 1")
    "2" '(winum-select-window-2 :which-key "Select window 2")
    "3" '(winum-select-window-3 :which-key "Select window 3")
    "4" '(winum-select-window-4 :which-key "Select window 4")
    "5" '(winum-select-window-5 :which-key "Select window 5")
    "6" '(winum-select-window-6 :which-key "Select window 6")
    "7" '(winum-select-window-7 :which-key "Select window 7")
    "8" '(winum-select-window-8 :which-key "Select window 8")
    "9" '(winum-select-window-9 :which-key "Select window 9"))
#+end_src

** Разделение окна

Вертикальное и горизонтальное разделение окна с переносом фокуса.

#+begin_src emacs-lisp :tangle yes
(defun my/split-window-right-and-focus ()
    (interactive)
    (split-window-right)
    (windmove-right))

(defun my/split-window-below-and-focus ()
    (interactive)
    (split-window-below)
    (windmove-down))
#+end_src

Горячие клавиши для разделения окна (с переключением в новое окно и без
переключения).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "w v" '(evil-window-vsplit :which-key "Split window vertical")
    "w V" '(my/split-window-right-and-focus :which-key "Split window vertical with focus")
    "w s" '(evil-window-split :which-key "Split window horizontally")
    "w S" '(my/split-window-below-and-focus :which-key "Split window horizontally with focus"))
#+end_src

** Ширина разделителя окон

Сделаем разделение окон по-заметнее.

#+begin_src emacs-lisp :tangle yes
(window-divider-mode 1)
(setq window-divider-default-right-width 4)
#+end_src

** Настройка Ediff

Настроим расположение окон для сравнения содежимого буферов.  Ставим
окна сравниваемых буферов рядом (а не одно под другим), панель
управления уводим вниз (а не в отдельный фрейм).

#+begin_src emacs-lisp :tangle yes
(require 'ediff)
(setq ediff-diff-options "-w" ; turn off whitespace checking
      ediff-split-window-function #'split-window-horizontally
      ediff-window-setup-function #'ediff-setup-windows-plain)
#+end_src

Для удобства предусмотрим инструмент сохранения предыдущего состояния
окон. Перед использованием ediff надо вызвать
=my/ediff--store-window-configuration=, тогда хук восстановит прежнее
положение окон.

#+begin_src emacs-lisp :tangle yes
(defvar my/ediff--window-configuration nil)

(defun my/ediff--store-window-configuration ()
    (push (current-window-configuration) my/ediff--window-configuration))

(defun my/ediff--restore-window-configuration ()
    (when-let (configuration (pop my/ediff--window-configuration))
        (set-window-configuration configuration)))

(add-hook 'ediff-quit-hook 'my/ediff--restore-window-configuration)
#+end_src

* Работа с буферами

Для работы части функций этого раздела используется код, взятый из
Spacemacs. Код находится в файле [[./funcs.el][funcs.el]].

** Клавиши для работы с буферами

Здесь определим набор клавиш для привычных действий с буферами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "b" '(:ignore t :which-key "buffers")
               "b b" '(counsel-projectile-switch-to-buffer
                       :which-key "Switch buffer in project")
               "SPC" '(counsel-projectile-switch-to-buffer
                       :which-key "Switch buffer in project")
               "b B" '(ivy-switch-buffer :which-key "Switch buffer")
               ;; "b B" '(counsel-switch-buffer :which-key "Switch buffer")
               "b d" '(kill-current-buffer :which-key "Kill buffer")
               "b r" '(rename-buffer :which-key "Rename buffer")
               "b v" '(my/revert-buffer :which-key "Revert buffer"))

(defun my/revert-buffer ()
    "Revert a buffer with ignore auto and without confirm."
    (interactive)
    (revert-buffer t t)
    (message "The buffer was reverted."))
#+end_src

** Отображение popup-буферов внизу окна и прочие настройки показа буферов

Мне удобней работать с popup-окнами (например окно помощи "*Help*"),
когда они появляются не сбоку фрейма, а снизу.  Делается через задание
списка ACTION для функции =display-buffer=.

Настроим сначала фокус у окон с help-буферами.

#+begin_src emacs-lisp :tangle yes
(setq help-window-select t)
#+end_src

Теперь все остальное.

#+begin_src emacs-lisp :tangle yes
(setq display-buffer-alist
      '(
        ;; Any new buffer
        ("^\\*new .*")

        ;; Dashboard
        ("^\\*dashboard\\*$")

        ;; PlantUML
        ("^\\*PLANTUML Preview\\*$"
         (display-buffer-reuse-window))

        ;; Ilist
        ("^\\*Ilist\\*$"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (side . right)
         (window-width . 0.30))

        ;; Org Src edit
        ("^\\*Org Src .*\\*$")

        ;; Clean Eshell
        ("^\\*eshell\\*$")

        ;; Clean Vterm
        ("^\\*vterm\\*$")

        ;; IELM
        ("^\\*ielm\\*$")

        ;; Org
        ("^\\*Org .*")

        ;; SDCV - dictionary
        ("^\\*SDCV\\*$")

        ;; org-roam-ql
        ("^\\*org-roam - .*")

        ;; org-roam-mode
        ("^\\*org-roam\\*$"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (side . right)
         (window-width . 0.35))

        ;; Magit (status)
        ("^magit: .*"
         (display-buffer-reuse-window display-buffer-same-window))

        ;; Magit log
        ("^magit-log.*"
         (display-buffer-reuse-window display-buffer-same-window))

        ;; Magit refs
        ("^magit-refs:.*"
         (display-buffer-reuse-window display-buffer-same-window))

        ;; Magit process
        ("^magit-process:.*"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))

        ;; Docker containers
        ("^\\*docker-containers\\*.*"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))

        ;; Docker images
        ("^\\*docker-images\\*.*"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))

        ;; Docker inspect
        ("^\\* docker inspect .*")

        ;; Code completion window
        ("^\\*CodeCompletion\\*$"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (side . right)
         (window-width . 0.40))

        ;; Other buffers with name like "*Name*"
        ("^\\*.*\\*<.*>$"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))

        ;; Other buffers with name like "*Name*"
        ("^\\*.*\\*$"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))))
#+end_src

** Открытие буфера, простое и с разделением окна

Удобно открыть существующий буфер, разделив при этом активное окно.

Привяжем горячие клавиши на такое открытие буфера.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "b j" '(projectile-switch-to-buffer-other-window :which-key "Switch buffer in project with other window")
    "b J" '(ivy-switch-buffer-other-window :which-key "Switch buffer with other window"))
    ;; "b J" '(counsel-switch-buffer-other-window :which-key "Switch buffer with other window"))
#+end_src

** Перенос буферов между окнами

Взято из Spacemacs для переноса буферов между окнами по клавишам <leader>-b-<Num>.

#+begin_src emacs-lisp :tangle yes
(defun my/move-buffer-to-window (windownum follow-focus-p)
  "Moves a buffer to a window, using the my numbering. follow-focus-p
controls whether focus moves to new window (with buffer), or stays on current"
  (interactive)
  (if (> windownum (length (window-list-1 nil nil t)))
      (message "No window numbered %s" windownum)
    (let ((b (current-buffer))
          (w1 (selected-window))
          (w2 (winum-get-window-by-number windownum)))
      (unless (eq w1 w2)
        (set-window-buffer w2 b)
        (switch-to-prev-buffer)
        (unrecord-window-buffer w1 b))
      (when follow-focus-p
        (select-window (winum-get-window-by-number windownum))))))

(defun my/swap-buffers-to-window (windownum follow-focus-p)
  "Swaps visible buffers between active window and selected window.
follow-focus-p controls whether focus moves to new window (with buffer), or
stays on current"
  (interactive)
  (if (> windownum (length (window-list-1 nil nil t)))
      (message "No window numbered %s" windownum)
    (let* ((b1 (current-buffer))
           (w1 (selected-window))
           (w2 (winum-get-window-by-number windownum))
           (b2 (window-buffer w2)))
      (unless (eq w1 w2)
        (set-window-buffer w1 b2)
        (set-window-buffer w2 b1)
        (unrecord-window-buffer w1 b1)
        (unrecord-window-buffer w2 b2)))
    (when follow-focus-p (winum-select-window-by-number windownum))))

(dotimes (i 9)
  (let ((n (+ i 1)))
    (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
             ,(format "Move buffer to the window with number %i." n)
             (interactive "P")
             (if arg
                 (my/swap-buffers-to-window ,n t)
               (my/move-buffer-to-window ,n t))))
    (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
             (interactive)
             (my/move-buffer-to-window ,n t)))
    (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
             (interactive)
             (my/swap-buffers-to-window ,n t)))
    ))
#+end_src

Привязываем горячие клавиши для переноса буферов.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "b 1" '(move-buffer-window-no-follow-1 :which-key "Move buffer to window 1")
    "b 2" '(move-buffer-window-no-follow-2 :which-key "Move buffer to window 2")
    "b 3" '(move-buffer-window-no-follow-3 :which-key "Move buffer to window 3")
    "b 4" '(move-buffer-window-no-follow-4 :which-key "Move buffer to window 4")
    "b 5" '(move-buffer-window-no-follow-5 :which-key "Move buffer to window 5")
    "b 6" '(move-buffer-window-no-follow-6 :which-key "Move buffer to window 6")
    "b 7" '(move-buffer-window-no-follow-7 :which-key "Move buffer to window 7")
    "b 8" '(move-buffer-window-no-follow-8 :which-key "Move buffer to window 8")
    "b 9" '(move-buffer-window-no-follow-9 :which-key "Move buffer to window 9"))
#+end_src

** Переключение показа по центру окна

Здесь воспользуемся пакетом centered-window.

#+begin_src emacs-lisp :tangle yes
(use-package centered-window
	:ensure t)
#+end_src

На широком окне неудобно читать длинные строчки.
Запилим корячие клавиши переключения =centered-window-mode=.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t m" #'centered-window-mode)
#+end_src

** Показ буферов, разобранных по проектам

Удобно видеть список буферов, разобранный по проектам.

Загрузим пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-projectile
    :ensure t)
(use-package ibuffer-vc
    :ensure t)
#+end_src

Повесим хуки со страницы пакета ibuffer-projectile.

#+begin_src emacs-lisp :tangle yes
(add-hook 'ibuffer-hook
          (lambda ()
              (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))
#+end_src

Красивый список вызывается командой =ibuffer=.
В evil-mode запилим его вызов на команду ":bd".

#+begin_src emacs-lisp :tangle yes
(evil-ex-define-cmd "buffers" #'ibuffer)
#+end_src

** Scratch буфер

В Doom были удобные черновики (scratch), которые не только создавались
уникальными для каждого проекта, но и автоматически сохраняли свое
содержимое.  Напишем им подобные.

Начнем с функции для создания именованного scratch-буфера с
автосохранением в файл.  Сохранять содержимое scratch-буферов будем в
эту директорию.

#+begin_src emacs-lisp :tangle yes
(setq my/scratch-dir (file-name-concat user-emacs-directory ".cache" "scratches"))
(make-directory my/scratch-dir t)
#+end_src

Создаем суффикс для имени буфера. Если активен проект - будет имя
проекта, иначе имя рабочего пространства.

#+begin_src emacs-lisp :tangle yes
(defun my/--make-buffer-suffix ()
    (let* ((project-path (projectile-project-root))
           (persp-name (my/--get-current-persp-name))
           (name (if project-path
                     (concat "PROJ-" (my/make-project-name project-path))
                     persp-name)))
        name))
#+end_src

Теперь сама функция. Она принимает на вход имя буфера и какой-либо
идентификатор, по которому строится имя файла для автосохранения.
Возвращает созданный буфер.

#+begin_src emacs-lisp :tangle yes
(defun my/scratch-buffer-create (name id)
    (let* ((buffer-name (format "*scratch:%s*" name))
           (file-name (expand-file-name
                       (file-name-concat my/scratch-dir
                                         (concat (md5 (format "%s" id)) ".txt"))))
           (buffer (get-buffer buffer-name)))
        (unless buffer
            (setq buffer (get-buffer-create buffer-name))
            (when (file-exists-p file-name)
                (with-current-buffer buffer
                    (insert-file-contents file-name))))
        (with-current-buffer buffer
            (setq-local buffer-auto-save-file-name file-name))
        buffer))
#+end_src

Теперь сделаем создание конкретных scratch-буферов.  Начнем с общего
scratch-буфера (на замену стандартному "*scratch*").

#+begin_src emacs-lisp :tangle yes
(defun my/make-scratch-main ()
    (interactive)
    (let* ((name "main")
           (buffer (my/scratch-buffer-create name name)))
        (pop-to-buffer buffer)
        buffer))
#+end_src

И создание scratch-буфера для текущего проекта или рабочего пространства.

#+begin_src emacs-lisp :tangle yes
(defun my/make-scratch-perspective ()
    (interactive)
    (let* ((name (my/--make-buffer-suffix))
           (id (or (projectile-project-root)
                   (my/--get-current-persp-name)))
           (buffer (my/scratch-buffer-create name id)))
        (pop-to-buffer buffer)
        buffer))
#+end_src

Привычные из Doom горячие клавиши для scratch-буферов.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "x" '(my/make-scratch-main :which-key "Scratch main")
    "p x" '(my/make-scratch-perspective :which-key "Scratch project"))
#+end_src

* Работа с файлами

** Клавиши для работы с файлами

Здесь определим набор клавиш для привычных действий с файлами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "f" '(:ignore t :which-key "files")
               "f s" '(save-buffer :which-key "Save file or buffer")
               "f S" '(write-buffer :which-key "Save file as")
               "f d" '(counsel-find-file :which-key "Open directory or file")
               "f f" '(counsel-find-file :which-key "Open file")
               "f r" '(counsel-recentf :which-key "Open recent file")
               "o -" '(dired-jump :which-key "Open directory and select file"))
#+end_src

** Режим ранее открытых файлов

Этот режим надо включать на старте. Тогда ранее открытые файлы будут
запоминаться.

#+begin_src emacs-lisp :tangle yes
(recentf-mode 1)
#+end_src

** Восстановление позиции курсора в открытом файле

#+begin_src emacs-lisp :tangle yes
(use-package saveplace
    :ensure t
    :config
    (save-place-mode 1))
#+end_src

** Автоматическое обновление буферов при внешнем изменении их содержимого

Этот параметр позволит обновлять буфера, если файлы, с ними связанные, были
изменены вне Emacs:

#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode 1)
#+end_src

Аналогично этот параметр позволит автоматически обьновлять такие буфера, как
Dired:

#+begin_src emacs-lisp :tangle yes
(setq global-auto-revert-non-file-buffers t)
#+end_src

** Открытие файла с разделением окна

Открытие файла с разделением окна, вертикальным и горизонтальным.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "f i" '(spacemacs/find-file-vsplit :which-key "Open file vsplit")
    "f n" '(spacemacs/find-file-split :which-key "Open file split"))
#+end_src

** Копирование в буфер обмена текущего имени файла

При копировании имени файла в буфер обмена выводим его название.
Также имя файла дублируем в системные буфера обмена.

#+begin_src emacs-lisp :tangle yes
  (defun my/yank-buffer-filename ()
	  (interactive)
	  (let ((text (buffer-file-name)))
		  (evil-set-register ?\" text)
		  (evil-set-register ?+ text)
		  (evil-set-register ?* text)
		  (evil-set-register ?0 text)
		  (message text)))
#+end_src

Горячие клавиши для копирования в буфер имени текущего файла.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "f y" #'my/yank-buffer-filename)
#+end_src

** Удаление лишних пробелов при сохранении файла

Удобно, когда при сохранении файла удаляются лишние пробелы в конце
строк. Так и поступим, но сделаем исключение для /markdown/, поскольку
там пробелы в конце строк имеют значение.

#+begin_src emacs-lisp :tangle yes
(defun my/delete-trailing-whitespace ()
    (unless (equal major-mode 'markdown-mode)
        (delete-trailing-whitespace)))

(add-hook 'before-save-hook #'my/delete-trailing-whitespace)
#+end_src

** Dired. Настройка файлового менеджера

Установим автоматическое обновление содержимого окон Dired.

#+begin_src emacs-lisp :tangle yes
(setq dired-auto-revert-buffer #'dired-buffer-stale-p)
#+end_src

Копирование файлов удобно делать в директорию, что открыта в ближайшем
dired-окне. Для этого надо установить соответствующий флажок.

#+begin_src emacs-lisp :tangle yes
(setq dired-dwim-target t)
#+end_src

Вид списка файлов определяется выхлопом команды ls, параметры которой
хранятся в переменной. Сделаем полный вид с опцией --human-readable.

#+begin_src emacs-lisp :tangle yes
(setq dired-listing-switches "-lah")
#+end_src

Файлы в Dired сортируются опциями команды "ls".
Из коробки по-умолчанию стоит сортировка по размеру ("SXU").
Изменим ее на сортировку по имени ("XSU"):

#+begin_src emacs-lisp :tangle yes
(setq dired-ls-sorting-switches "XSU")
#+end_src

Теперь раскрасим представление файлов. Делаем это пакетом dired-k.
(С флажком dired-k-style='git файлы будут иметь git-пометки.)

#+begin_src emacs-lisp :tangle yes
(use-package dired-k
    :ensure t
    :config
    (setq dired-k-human-readable t
          dired-k-style 'git)
    (add-hook 'dired-initial-position-hook 'dired-k)
    (add-hook 'dired-after-readin-hook #'dired-k-no-revert)
    )
#+end_src

Уберем перенос длинных строк для dired-mode, поскольку он неудобен.

#+begin_src emacs-lisp :tangle yes
(add-hook 'dired-mode-hook 'my/--unwrap-words)
#+end_src

** История сохраненных файлов

Бывает нужно для ручной синхронизации файлов на машинах.

Хранить истории будем в файле.

#+begin_src emacs-lisp :tangle yes
(defun my/files-history-save-file ()
    (expand-file-name
     (file-name-concat user-emacs-directory
                       (concat "files-saving-history-"
                               (if (bound-and-true-p server-name)
                                   server-name
                                   "server")
                               ".el"))))
#+end_src

Создадим хэш-таблицу сохраненных файлов: имя-файла - время сохранения.
А еще создадим такую же хэш-таблицу, но для директорий.

#+begin_src emacs-lisp :tangle yes
(defvar my/files-saving-history (make-hash-table :test 'equal))
(defvar my/directories-saving-history (make-hash-table :test 'equal))
#+end_src

Напишем функции загрузки и сохранения историй в файл.
Функция чтения отработает только в случае пустых историй.

#+begin_src emacs-lisp :tangle yes
(defun my/soft-load-histories-from-file ()
    (when (and (or (hash-table-empty-p my/files-saving-history)
                   (hash-table-empty-p my/directories-saving-history))
               (file-exists-p (my/files-history-save-file)))
        (with-temp-buffer
            (insert-file-contents (my/files-history-save-file))
            (goto-char 0)
            (setq my/directories-saving-history (read (current-buffer))
                  my/files-saving-history (read (current-buffer))))))

(defun my/save-histories-to-file ()
    (with-temp-buffer
        (prin1 my/directories-saving-history (current-buffer))
        (prin1 my/files-saving-history (current-buffer))
        (write-region (buffer-end -1) (buffer-end +1) (my/files-history-save-file))))
#+end_src

Добавлять файлы и директории в историю будем этой функцией.

#+begin_src emacs-lisp :tangle yes
(defun my/append-file-to-saving-history ()
    (let* ((buffer (or (buffer-base-buffer) (current-buffer)))
           (filename (buffer-file-name buffer))
           (time-value (format-time-string "%Y-%m-%d %H:%M:%S")))
        (when (and buffer filename time-value
                   (file-exists-p filename))
            (puthash filename time-value
                     my/files-saving-history)
            (puthash (file-name-directory filename) time-value
                     my/directories-saving-history))))
#+end_src

Ниже функция сортирует историю сохранений по датам и выдает результат списком.

#+begin_src emacs-lisp :tangle yes
(defun my/sort-files-saving-history (fd-saving-history)
    (let (saving-histry)
        (maphash (lambda (key val)
                     (push (list val key) saving-histry))
                 fd-saving-history)
        (sort saving-histry
              (lambda (pair1 pair2)
                  (string> (car pair1) (car pair2))))))
#+end_src

Теперь будем выбирать, какую историю показывать: файлов или
директорий?  Заведем соответствующую переключалку. На практике нужной
оказалась история директорий, а история файлов почти не используется.

#+begin_src emacs-lisp :tangle yes
(defvar my/fd-saving-history 'directories)

(defun my/fd-saving-history (&optional ARG)
    "Select mode for show siving history.
ARG may be 'files, 'directories, 'toggle or nil.
Return history hash-map."
    (setq my/fd-saving-history (cond ((or (eq ARG 'directories)
                                          (and (eq ARG 'toggle)
                                               (eq my/fd-saving-history 'files)))
                                      'directories)
                                     ((or (eq ARG 'files)
                                          (and (eq ARG 'toggle)
                                               (eq my/fd-saving-history 'directories)))
                                      'files)
                                     (t
                                      my/fd-saving-history)))
    (cond ((eq my/fd-saving-history 'files)
           my/files-saving-history)
          ((eq my/fd-saving-history 'directories)
           my/directories-saving-history)))
#+end_src

Эта функция создает/обновляет буфер с историей сохранений, используя результат предыдущей функции.
Сутки разделяем пустой строкой.
Буфер переводим в org-mode и тексты файлов даем со ссылками.
Название буфера сохранено в переменную [[elisp:(message my/files-saving-history-buffer-name)][my/files-saving-history-buffer-name]].

#+begin_src emacs-lisp :tangle yes
(defvar my/files-saving-history-buffer-name "*files-saving-history*")

(defun my/update-buffer-for-files-saving-history (fd-saving-history)
    (interactive)
    (let* ((history-buffer (get-buffer-create my/files-saving-history-buffer-name))
           (history (my/sort-files-saving-history fd-saving-history))
           (date-result nil)

           (insert-row (lambda (pair)
                           (let* ((date-time (car pair))
                                  (date (car (split-string date-time " +")))
                                  (filename (cadr pair)))
                               (when (and date-result (not (equal date date-result)))
                                   (insert "\n"))
                               (insert (concat date-time "  [[" filename "]]\n"))
                               (setq date-result date)))))

           (with-current-buffer history-buffer
               (read-only-mode -1)
               (erase-buffer)
               (mapc insert-row history)
               (org-mode)
               (goto-char 0)
               (org-next-link)
               (read-only-mode 1))))
#+end_src

Дополнение хэш-таблицы и обновление буфера истории повесим на 'after-save-hook.
Теперь каждый сохраненный файл оставляет свой след.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-save-hook
          (lambda ()
              (my/soft-load-histories-from-file)
              (my/append-file-to-saving-history)
              (my/update-buffer-for-files-saving-history (my/fd-saving-history))
              (my/save-histories-to-file)))
#+end_src

Горячие клавиши для переключения между показом файлов и директорий.
Первое нажатие вытягивает буфер с историей наверх.
Остальные нажатия уже переключают показ.

#+begin_src emacs-lisp :tangle yes
(defun my/toggle-files-saving-history ()
    (interactive)
    (my/soft-load-histories-from-file)
    (if (equal my/files-saving-history-buffer-name
               (buffer-name (current-buffer)))
        (my/update-buffer-for-files-saving-history (my/fd-saving-history 'toggle))
        (switch-to-buffer my/files-saving-history-buffer-name))
    (when (string-empty-p (buffer-string))
        (my/update-buffer-for-files-saving-history (my/fd-saving-history)))
    (message (symbol-name my/fd-saving-history)))

(my/leader-def nil 'override
    "t h" #'my/toggle-files-saving-history)
#+end_src

** Открытие файла средствами операционной системы

Очень неудобно, когда Emacs пытается открывать и показывать сам такие файлы,
как PDF, ODT, DOCX и т.п. (речь о dired).
Чтобы иметь возможность открывать файлы средствами операционной системы
напишем функцию, под капотом у которой будет =gio open=.

#+begin_src emacs-lisp :tangle yes
(defun my/open-file-by-shell ()
    (interactive)
    (let ((filename (dired-get-filename)))
        (when filename
            (call-process "gio" nil 0 nil "open" filename))))
#+end_src

Горячие клавиши повесим на режим dired-mode.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'dired-mode-map
    "RET" #'my/open-file-by-shell)
#+end_src

** Логирование всплывающих сообщений

Предполагается, что в системе настроено логирование всплывающих сообщений типа
: $ notify-send "Test message" "Some text"
и помещено в файл

#+begin_src emacs-lisp :tangle yes
(setq my/notify-log-filename (file-name-concat (getenv "HOME") "/.log/notify.log"))
#+end_src

Функция ниже создает буфер, где в реальном времени отображаются последние
всплывшие сообщения.

#+begin_src emacs-lisp :tangle yes
(defun my/notify-log-open-notify-log ()
    (interactive)
    (let ((buffer-name "*notify-log*"))
        (if (get-buffer buffer-name)
                (switch-to-buffer buffer-name)
            (start-process "notify-log" buffer-name "tail" "-n 50" "-f" my/notify-log-filename)
            (switch-to-buffer buffer-name)
            (special-mode)
            ;; Highlighitng works only manually. :(
            (font-lock-mode 1)
            (font-lock-fontify-region (point-min) (point-max)))))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t k" #'my/notify-log-open-notify-log)
#+end_src

** Поиск текста и файла по директории

Функция поиска текста по текущей директории.

#+begin_src emacs-lisp :tangle yes
(defun my/search-in-directory ()
    (interactive)
    (counsel-rg))
#+end_src

Поиск файла по директории.

#+begin_src emacs-lisp :tangle yes
(defun my/find-file-in-directory ()
    (interactive)
    (counsel-file-jump))
#+end_src

Назначаем горячие клавиши для поиска.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "s d" '(my/search-in-directory :which-key "Search in directory")
               "f F" '(my/find-file-in-directory :which-key "Open file in directory"))
#+end_src

** Графический диалог открытия файла

Сохранено, как способ открытия диалогового окна с выбором файла.

#+begin_src emacs-lisp :tangle yes
(defun my/find-file-with-dialog ()
    (interactive)
    (let ((last-nonmenu-event nil)
          (use-dialog-box t)
          (use-file-dialog t))
        (call-interactively #'find-file)))
#+end_src

** GPG-костыли

При очередном обновлении системы стало зависать сохранение GPG-файлов.
Ниже костыль для поправки неисправности.

#+begin_src emacs-lisp :tangle yes
(fset 'epg-wait-for-status 'ignore)
#+end_src

Запилим его в функцию, чтобы каждый раз не искать по конфигу:

#+begin_src emacs-lisp :tangle yes
(defun my/gpg-repair-saving ()
    (interactive)
    (fset 'epg-wait-for-status 'ignore))
#+end_src

* Рабочие пространства (workspaces, perspectives)

** Установка и настройка рабочих пространств

Здесь происходит организация рабочих пространств в редакторе.
Делается на основе модуля persp-mode (перспективы).

Рабочее пространство отвечает за запоминание расположения окон и
видимость своих буферов.  При смене рабочих пространств происходит
восстановление расположения окон для активированного пространства.

Если рабочее пространство создается новое, нужно показать начальный
экран (dashboard).

Установим пакет и назовем "нулевую" перспективу "main".

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "persp-mode"
    (setq wg-morph-on nil)
    (setq persp-autokill-buffer-on-remove 'kill-weak)
    (setq persp-auto-save-opt 0)
    (setq persp-auto-resume-time 0)
    (add-hook 'window-setup-hook #'(lambda () (persp-mode 1))))

(use-package persp-mode
    :ensure t
    :init
    (setq persp-nil-name "main")
    :config)

;; (use-package persp-projectile
;;     :ensure t)
#+end_src

** Клавиши для работы с рабочими пространствами

Все функции пакета доступны по префиксу "Ctrl-c p".
Но для удобства определю клавиши, к которым привык в Doom.

#+begin_src emacs-lisp :tangle yes
(defun my/persp-frame-switch ()
    (interactive)
    (let ((names (copy-list persp-names-cache)))
        (call-interactively 'persp-frame-switch)
        (unless (member (my/--get-current-persp-name) names)
            (switch-to-buffer "*dashboard*")
            (delete-other-windows))))

(my/leader-def nil 'override
               "TAB" '(:ignore t :which-key "workspaces")
               "TAB ." '(my/persp-frame-switch
                         :which-key "Switch or create workspace")
               "TAB a" '(persp-add-buffer :which-key "Add buffer to workspace")
               "TAB r" '(persp-rename :which-key "Rename workspace")
               "TAB d" '(persp-kill :which-key "Delete workspace")
               "," '(persp-switch-to-buffer :which-key "Switch buffer in workspace")
               "TAB k" '(persp-remove-buffer :which-key "Remove buffer from workspace"))
#+end_src

Отдельно сделаем показ имени активной перспективы.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "TAB v" '(my/show-perspective-name :which-key "Show workspace name"))

(defun my/show-perspective-name ()
    (interactive)
    (message (my/--get-current-persp-name)))

(defun my/--get-current-persp-name ()
    (if (bound-and-true-p persp-mode)
        (safe-persp-name (get-current-persp))
        "main"))
#+end_src

** Открытие новых рабочих пространств в новых фреймах
   :PROPERTIES:
   :ID:       9061c49b-5d1a-47a7-a419-a9787254e99f
   :END:

Чтобы сократить количество телодвижений, сделаем открытие фрейма
одновременно с созданием или выбором рабочего пространства
(перспективы).  В заголовок фрейма поместим имя перспективы.

#+begin_src emacs-lisp :tangle yes
(defun my/make-frame-and-switch-perpective (persp-name)
    (interactive (list (ivy-read "Enter workspace name: "
                                 persp-names-cache
                                 :initial-input (my/--get-current-persp-name))))
    (when persp-name
        (let* ((frame-text (my/make-title-bar-text persp-name))
               (frame (my/get-frame-by-name frame-text)))
            (if frame
                (select-frame-set-input-focus frame)
                (my/prepare-frame-for-workspace persp-name
                                                (make-frame))))))

(defun my/prepare-frame-for-workspace (persp-name frame &optional safe-frame-title)
    (let ((names (copy-list persp-names-cache)))
        (select-frame-set-input-focus frame)
        (unless safe-frame-title
            (my/set-title-bar persp-name))
        (persp-frame-switch persp-name)
        (unless (member persp-name names)
            (switch-to-buffer "*dashboard*")
            (delete-other-windows))
        (message (concat "Workspace '" persp-name "' is selected."))))
#+end_src

Выбрать/создать перспективу с изменением заголовка удобно сделать и
для текущего активного фрейма.  Это пригодится после вызова нового
emacs-клиента.

#+begin_src emacs-lisp :tangle yes
(defun my/set-title-bar-and-workspace-interactive (persp-name)
    (interactive (list (read-string "Enter workspace name: ")))
    (when persp-name
        (my/prepare-frame-for-workspace persp-name
                                        (selected-frame))))
#+end_src

Определим горячие клавиши для работы с рабочими пространствами и
фреймами для них.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o F" '(my/make-frame-and-switch-perpective :which-key "Make frame and switch workspace")
    "n I" '(my/set-title-bar-and-workspace-interactive :which-key "Set title for frame and workspace"))
#+end_src

* Проекты (projects)

** Установка и настройка работы с проектами (Projectile)

Проекты определяют работу с файлами в пределах директории проекта.
Рабочие пространства никак не конфликтуют с проектами - их удобно
использовать совместно, например:
- Создать рабочее пространство и переключать внутри него несколько проектов.
- Под каждый проект создать свое рабочее пространство и переключаться между ними.
- Для каждого проекта завести не только свое рабочее пространство, но и свой
  отдельный фрейм.
И так далее, как будет удобней для работы.

Пакет =projectile= - крайне удобное средство для работы с проектами.
Директории проектов распознаются по наличию в них поддиректории .git
или файла .projectile. Среди прочего можно:
- Открывать файлы проекта по частичному совпадению в имени и пути.
- Тем же сособом можно переключаться между проектами.
- Назначать на ходу команды компиляции, запуска и отладки проекта и
  пользоваться ими.
- В файле .projectile можно назначать параметры отдельно для каждого
  проекта.

Загрузим необходимые пакеты и сразу запретим Counsel предварительный
показ буферов.

#+begin_src emacs-lisp :tangle yes
(use-package projectile
    :ensure t
    :config
    (projectile-mode 1)
    (add-to-list 'projectile-project-root-files-bottom-up ".projectile")
    (projectile-load-known-projects))
(use-package counsel-projectile
    :ensure t)
(use-package ibuffer-projectile
    :ensure t
    :config
    (setq counsel-projectile-preview-buffers nil))
(use-package ibuffer-vc
    :ensure t)
#+end_src

Сам Projectile запоминать ранее открытые проекты не будет. Сделаем это за него.
Сперва определим функцию для запоминания текущего проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/projectile-save-current-project (dir)
    (when (projectile-discover-projects-in-directory dir)
        (projectile-save-known-projects)))
#+end_src

Теперь перехватим соответствующие hook'и, где проверим наличие проекта в текущей
директории (живет в переменой default-directory).

#+begin_src emacs-lisp :tangle yes
(let ((hooks (list 'find-file-hook
                   'dired-mode-hook
                   'projectile-find-file-hook
                   'projectile-find-dir-hook)))
    (mapc (lambda (hook)
              (add-hook hook
                        (lambda ()
                            (my/projectile-save-current-project default-directory))))
          hooks))
#+end_src

** Совместная работа проектов и рабочих пространств

Для работы с проектом в отдельном Emacs-клиенте мне нужны следующие действия:
1. Запустить нового Emacs-клиента (или, как вариант, открыть отдельный фрейм).
2. Завести новое рабочее пространство по имени проекта.
3. Открыть проект и выбрать в нем файл.
4. Фрейму назначить одноименный заголовок, чтобы отличать его среди других фреймов.
Шаги 2, 3 и 4 можно собрать в одно действие. Сделаем это ниже.

Понадобится функция для создания имени текущего проекта.  Имя берется
по названию директории проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/make-project-name (&optional project-path)
    (unless project-path
        (setq project-path (projectile-project-root)))
    (when project-path
        (car (last
              (remove "" (split-string project-path "/"))))))
#+end_src

Теперь собираем все описанные выше действия в одну функцию.

#+begin_src emacs-lisp :tangle yes
(defun my/switch-project-with-workspace (&optional safe-frame-title)
    (interactive)
    (let ((temporary-name (format "*%s*" (md5 "*temporary-name-workspace*"))))
        (persp-frame-switch temporary-name)
        (call-interactively #'projectile-switch-project)
        (let ((project-name (my/make-project-name))
              (buffer (current-buffer)))
            (if (member project-name persp-names-cache)
                (progn (persp-frame-switch project-name)
                       (switch-to-buffer buffer)
                       (persp-kill (list temporary-name)))
                (persp-rename project-name))
            (my/prepare-frame-for-workspace project-name
                                            (selected-frame)
                                            safe-frame-title))))
#+end_src

Определим горячие клавиши для работы с проектами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "p" '(:ignore t :which-key "projects")
    "P" '(:ignore t :which-key "projects-ws")
    "p p" '(projectile-switch-project :which-key "Simple switch project")
    "p P" '(my/switch-project-with-workspace-safe-title :which-key "Light switch proj+ws")
    "P P" '(my/switch-project-with-workspace :which-key "Switch project+workspace")
    "p f" '(counsel-projectile-find-file :which-key "Open file in project")
    "p i" '(projectile-invalidate-cache :which-key "Invalidate cahce")
    ;; "p c" #'project-compile
    "p c" '(projectile-compile-project :which-key "Compile in project")
    "p R" '(projectile-run-project :which-key "Run project")
    "p T" '(projectile-test-project :which-key "Test project")
    "/" '(counsel-projectile-rg :which-key "Search project"))

(defun my/switch-project-with-workspace-safe-title ()
    (interactive)
    (my/switch-project-with-workspace t))
#+end_src

** Исключение файлов из поиска по проектам

Здесь исключим всякий файловый мусор, дабы не мешался при поиске по проектам.
Тут собраны в основном исключения для Python-проектов.

#+begin_src emacs-lisp :tangle yes
(setq grep-find-ignored-directories '("SCCS" "RCS" "CVS" "MCVS" ".src" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "__pycache__" "build" "develop-eggs" "dist" "dist_local" "eggs" ".eggs" "sdist" ".pytest_cache" "env" "venv" "ENV" "env.bak" "venv.bak" ".mypy_cache" "build" ".ccls-cache")
      grep-find-ignored-files (append grep-find-ignored-files '("TAGS" "tags"))
      helm-grep-ignored-directories '("SCCS/" "RCS/" "CVS/" "MCVS/" ".svn/" ".git/" ".hg/" ".bzr/" "_MTN/" "_darcs/" "{arch}/" ".gvfs/" "__pycache__/" "build/" "develop-eggs/" "dist/" "dist_local/" "eggs/" ".eggs/" "sdist/" ".pytest_cache/" "env/" "venv/" "ENV/" "env.bak/" "venv.bak/" ".mypy_cache/" "build/" ".ccls-cache")
      projectile-globally-ignored-directories '("~/.emacs.d/.local/" "~/.emacs.d/.local/" "~/.emacs.d/.local/" ".idea" ".vscode" ".ensime_cache" ".eunit" ".git" ".hg" ".fslckout" "_FOSSIL_" ".bzr" "_darcs" ".tox" ".svn" ".stack-work" ".ccls-cache" ".cache" ".clangd" "__pycache__" "build" "develop-eggs" "dist" "dist_local" "eggs" ".eggs" "sdist" ".pytest_cache" "env" "venv" "ENV" "env.bak" "venv.bak" ".mypy_cache" "build" ".ccls-cache")
      projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o" ".coverage" ".cache" ".ipynb_checkpoints" ".egg" ".pyo" ".pyd" ".cover" ".egg-info" "TAGS" "tags")
      projectile-globally-ignored-files '(".DS_Store" "TAGS" "tags")
)
#+end_src

И еще докинем исключения для списков ранее открытых файлов.

#+begin_src emacs-lisp :tangle yes
(setq recentf-exclude '("/\\(\\(\\(COMMIT\\|NOTES\\|PULLREQ\\|MERGEREQ\\|TAG\\)_EDIT\\|MERGE_\\|\\)MSG\\|\\(BRANCH\\|EDIT\\)_DESCRIPTION\\)\\'" "ssh:" "SSH:")
      )
#+end_src

* Демоны

** Свой хук на создание первого клиентского фрейма

При старте нового клиента вызывается хук
=server-after-make-frame-hook=.  Но есть неприятность, возможно
связанная с =with-editor=: при создании коммита через Magit тоже
поднимается server-after-make-frame-hook.  Понять, что это "был
Magit", можно по имени текущего буфера - =" *server*"= (определил
экспериментально).

Чтобы не отлавливать этот момент каждый раз, сделаем свой хук
=my/server-after-make-frame-hook=, и в дальнейшем будем пользоваться
им.

#+begin_src emacs-lisp :tangle yes
(add-hook 'server-after-make-frame-hook
          (lambda (&optional frame)
              (unless (equal "*server*"
                             (string-trim (buffer-name (current-buffer))))
                  (run-hooks 'my/server-after-make-frame-hook))))
#+end_src

** Задание цветовых тем для известных демонов

Мне удобно для работы запускать несколько демонов Emacs.
Визуально их различаю цветовыми темами. Например:
- демон "notes" - теплая тема,
- демон "dev"   - холодная тема,
- демон "rest"  - холодная тема с прозрачностью.
Так сложнее визуально перепутать клиентские фреймы для каждого из
демонов.

Установим каждому демону тему на старте.

#+begin_src emacs-lisp :tangle yes
(pcase (daemonp)
    ("notes"
     (load-theme 'doom-molokai t))

    ("dev"
     (load-theme 'doom-one t))

    ("rest"
     (setq my/transparency-level 1)
     (load-theme 'doom-one t)))
#+end_src

А тема по-умолчанию задается [[id:40986685-fc80-45b7-ab77-4cac074fea9f][выше]].

** Задание имен для рабочих пространств и фреймов на старте первого клиентского фрейма

При старте демонов "Notes" (записи) или "rest" (REST), мне удобно
сразу переименовать первый клиентский фрейм и создать одноименное
рабочее пространство.  Автоматизируем эти действия, немного
подстраховавшись на случай запуска [[id:cc0595b8-0628-4bd8-b398-ddfc80b95a01][клиентских сценариев]].

#+begin_src emacs-lisp :tangle yes
(defun my/actions-on-first-client-frame ()
    (let ((set-title-and-workspace
           (lambda (name)
               (when (and (not (member name persp-names-cache))
                          (= 1 (length persp-names-cache)))
                   (my/prepare-windows-in-new-frame 'charge)
                   (my/set-title-bar-and-workspace-interactive name)))))
        (pcase (daemonp)
            ("notes"
             (funcall set-title-and-workspace "Notes"))
            ("rest"
             (funcall set-title-and-workspace "REST")))))

(add-hook 'my/server-after-make-frame-hook #'my/actions-on-first-client-frame)
#+end_src

** Ярлыки для работы с известными демонами

Клиентов к демонам запускаю по desktop-ярлыкам из
[[/usr/share/applications/]].

Если при вызове клиента демон не был запущен, то он запускается, так
что на старте системы думать о Emacs-демонах не приходится. Для этого
есть параметр "-a":
: $ emacsclient -a "" -c -s my_daemon_name

Пример ярлыка для клиента от демона "notes" (файл emacs_notes.desktop):

#+begin_src conf
[Desktop Entry]
Name=Emacs Notes
GenericName=Text Editor
Comment=Edit text
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -a "" -c -s notes
Icon=emacs
Type=Application
Terminal=false
Categories=Development;TextEditor;
StartupWMClass=Emacs
Keywords=Text;Editor;
#+end_src

* Org

** Начальная инициализация всей org-кухни

До загрузки Org поправим баг с невозможностью раскрытия схлопнутых
заголовков. Для этого предварительно установим переменную
=org-fold-core-style=:

#+begin_src emacs-lisp :tangle yes
(setq org-fold-core-style 'overlays)
#+end_src

Некоторые мелочи, как само собой разумеющееся:
- поддержка идентификаторов,
- автоотступ по заголовкам,
- вычисление org-babel блоков без вопросов
и т.п..

#+begin_src emacs-lisp :tangle yes
(use-package org
    :ensure t
    :config
    (require 'org-id)
    (add-hook 'org-mode-hook (lambda ()
                                 (setq org-adapt-indentation t)))
    (setq org-confirm-babel-evaluate nil)
    (setq org-confirm-elisp-link-function nil))
#+end_src

Подгрузим поддержку evil для org-mode, включая Агенду.

#+begin_src emacs-lisp :tangle yes
(use-package evil-org
    :ensure t
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

Текст на месте сворачивания.

#+begin_src emacs-lisp :tangle yes
(setq org-ellipsis " ••• "  ;; " ▼"  ;; " ↴ "  ;; " ••• "
      org-cliplink-ellipsis "•••"
      org-columns-ellipses "••")
#+end_src

** Клавиши для работы в org-mode

Подготовимся и дополним функцию org-id-copy. Добавим туда еще одно
свойство CUSTOM_ID для перекрестных ссылок между файлами. Также
исправим баг, где при значении переменной org-fold-core-style,
установленной в 'overlays, возникали неудобства со схлопыванием
drawer'ов.

#+begin_src emacs-lisp :tangle yes
(defun my/org-id-copy ()
    (interactive)
    (let ((org-fold-core-style 'text-properties))
        (when-let (id (org-id-get nil 'create))
            (org-set-property "CUSTOM_ID" id)
            (org-kill-new id))))
#+end_src

Вернем привычные горячие клавиши из Doom для evil-mode.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'org-mode-map
    "[ s" #'evil-prev-flyspell-error
    "] s" #'evil-next-flyspell-error
    "S-M-[" #'org-backward-element
    "S-M-]" #'org-forward-element
    "g h" #'org-up-element
    "g l" #'org-down-element
    "g k" nil
    "g j" nil
    "[ [" #'evil-backward-section-begin
    "[ ]" #'evil-backward-section-end
    "] ]" #'evil-forward-section-begin
    "] ]" #'evil-forward-section-end
    "C-S-h" #'org-shiftleft
    "C-S-l" #'org-shiftright
    "M-h" #'org-metaleft
    "M-l" #'org-metaright
    "M-k" #'org-metaup
    "M-j" #'org-metadown
    "M-RET" #'org-meta-return)
(my/evil-define-key '(insert) 'org-mode-map
    "M-h" #'org-metaleft
    "M-l" #'org-metaright)
(my/localleader-def '(normal visual motion) 'org-mode-map
    "l l" #'org-insert-link
    "l t" #'org-toggle-link-display
    "y" #'my/org-id-copy)
;; It's a magic and shaman's dances:
(my/evil-define-key '(normal visual motion) 'org-mode-map
    "[ c" #'org-babel-previous-src-block
    "] c" #'org-babel-next-src-block)
;; It's a magic and shaman's dances:
(my/evil-define-key '(normal visual motion) 'org-mode-map
    "[ l" #'org-previous-link
    "] l" #'org-next-link)
(my/localleader-def nil 'org-mode-map
    "e" #'org-export-dispatch)
(define-key org-mode-map (kbd "C-c C-j") #'counsel-org-goto)
#+end_src

Отрубим мешающиеся клавиши, что затирают творение выше.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'evil-collection-unimpaired-mode-map
	"[ l" nil
	"] l" nil)
(define-key org-mode-map (kbd "C-,") nil)
#+end_src

** Переход по ссылкам

Вопреки описаниям (а, может, я не так все понимаю) переход к файлу по
тексту из него приводит к сообщению, что текст не найден и не создать
ли новый заголовок с таким текстом.  Это неудобно, но можно сделать
нечеткую проверку текста, тогда переходы начинают находиться.
Делается это через переменную =org-link-search-must-match-exact-headline=,
значение по-умолчанию которой - query-to-create. Мы де сделаем nil.

#+begin_src emacs-lisp :tangle yes
(setq org-link-search-must-match-exact-headline nil)
#+end_src

** Функция показа и скрытия картинки в org-mode

Очень удобная функция (взята из Doom). Используем ее в следующих
параграфах.

#+begin_src emacs-lisp :tangle yes
(defun my/org-toggle-inline-images-in-subtree (object &optional refresh)
    "Refresh inline image previews in the current heading/tree."
    (let* ((beg (or (org-element-property :begin object)
                    (if (org-before-first-heading-p)
                        (save-excursion (point-min))
                        (save-excursion (org-back-to-heading) (point)))))
           (end (or (org-element-property :end object)
                    (if (org-before-first-heading-p)
                        (save-excursion (org-next-visible-heading 1) (point))
                        (save-excursion (org-end-of-subtree) (point)))))
           (overlays (cl-remove-if-not (lambda (ov)
                                           (overlay-get ov 'org-image-overlay))
                                       (ignore-errors (overlays-in beg end)))))
        (dolist (ov overlays nil)
            (delete-overlay ov)
            (setq org-inline-image-overlays (delete ov org-inline-image-overlays)))
        (when (or refresh (not overlays))
            (org-display-inline-images t t beg end)
            t)))
#+end_src

** Разнообразная реакция на Enter (RET)

При нажатии Enter попробуем узнать тип объекта под курсором и в
зависимости от него вызвать соответствующую функцию.

Определим функцию для определения типа объекта под курсором.  Функция
возвращает информацию о типе org-объекта, которая может быть одним из
символов:
- button
- citation, citation-reference
- headline
- clock
- footnote-reference
- footnote-definition
- planning, timestamp
- table, table-row
- table-cell
- babel-call
- statistics-cookie
- src-block, inline-src-block
- latex-fragment, latex-environment
- link
- link-image
- item
- paragraph

#+begin_src emacs-lisp :tangle yes
(defun my/object-type-at-point ()
    (if (button-at (point))
        'button
        (let* ((context (org-element-context))
               (type (org-element-type context)))
            (while (and context
                        (memq type '(verbatim
                                     code
                                     bold
                                     italic
                                     underline
                                     strike-through
                                     subscript
                                     superscript)))
                (setq context (org-element-property :parent context)
                      type (org-element-type context)))
            (my/org--correct-object-type type context))))

(defun my/org--correct-object-type (type context)
    (pcase type
        (`link
         (if (my/org--link-image-p context) 'link-image type))
        (_
         type)))

(defun my/org--link-image-p (context)
    (let* ((lineage (org-element-lineage context '(link) t))
           (path (org-element-property :path lineage)))
        (or (equal (org-element-property :type lineage) "img")
            (and path (image-type-from-file-name path)))))
#+end_src

Теперь воткнем функцию-обработчик клавиши Enter. Содержимое
обработчика будет пополняться по мере надобности.

#+begin_src emacs-lisp :tangle yes
(defun my/dwim-at-point (&optional arg)
    (interactive "P")
    (let ((type (my/object-type-at-point)))
        (pcase type

            (`link
             (org-open-at-point arg))

            (`link-image
             (my/org-toggle-inline-images-in-subtree (org-element-at-point)))

            ((or `latex-fragment `latex-environment)
             (org-latex-preview arg))

            (`item
             (let ((match (and (org-at-item-checkbox-p)
                               (match-string 1))))
                 (org-toggle-checkbox (if (equal match "[ ]") '(16)))))  ; Set '-' to checkbox.
            ((or `table `table-row)
             (if (org-at-TBLFM-p)
                 (org-table-calc-current-TBLFM)
                 (ignore-errors
                     (save-excursion
                         (goto-char (org-element-property :contents-begin context))
                         (org-call-with-arg 'org-table-recalculate (or arg t))))))

            (`table-cell
             (org-table-blank-field)
             (org-table-recalculate arg)
             (when (and (string-empty-p (string-trim (org-table-get-field)))
                        (bound-and-true-p evil-local-mode))
                 (evil-change-state 'insert)))

            (_
             (org-ctrl-c-ctrl-c arg))
            )))
#+end_src

Определяем поведение клавиши Enter для evil.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'org-mode-map
               "RET" #'my/dwim-at-point)
#+end_src

** Разнообразная реакция на двойное нажатие мышки

Пропишем аналогичное поведение на двойное нажатие мышки.
Выделение слова стоит оставить не тронутым.

#+begin_src emacs-lisp :tangle yes
(defun my/dwim-at-mouse (&optional arg)
    (interactive "P")
    (let ((type (my/object-type-at-point)))
        (pcase type

            (`link-image
             (my/org-toggle-inline-images-in-subtree (org-element-at-point)))

            ((or `latex-fragment `latex-environment)
             (org-latex-preview arg))

            (`item
             (let ((match (and (org-at-item-checkbox-p)
                               (match-string 1))))
                 (org-toggle-checkbox (if (equal match "[ ]") '(16)))))  ; Set '-' to checkbox.

            ((or `table `table-row `table-cell)
             (org-ctrl-c-ctrl-c))

            (_
             nil)
            )))
#+end_src

Определяем поведение двойного нажатия мышки.

#+begin_src emacs-lisp :tangle yes
(define-key org-mode-map [down-double-mouse-1] #'my/dwim-at-mouse)
#+end_src

Двойное нажатие мышки не отменяет одиночного, поэтому при двойном
нажатии по ссылке картинка будет открыта в другом буфере.  Чтобы так не
получилось в org-mode, сделаем обертку над функцией =org-open-at-mouse=.

#+begin_src emacs-lisp :tangle yes
(defun my/cancel-mouse-action (func &rest args)
    (if (equal major-mode 'org-mode)
        (pcase (my/object-type-at-point)
            ((or `link-image `item)
             nil)
            (_
             (apply func args)))
        (apply func args)))

(advice-add #'org-open-at-mouse :around #'my/cancel-mouse-action)
(advice-add #'evil-mouse-drag-region :around #'my/cancel-mouse-action)
#+end_src

** Открытие org-ссылки в том же окне

Открывать org-ссылку в другом окне оказалось очень неудобно. Сделаем
открытие ссылки в том же окне, где и сам org-файл. Правило это
задается в списке =org-link-frame-select=. Заменим
вызов 'find-file-other-window на 'find-file.

#+begin_src emacs-lisp :tangle yes
(let* ((pair (assq 'file org-link-frame-setup)))
    (setcdr pair 'find-file))
#+end_src

** Директория для org-файлов и прочей org-кухни

If you use `org' and don't want your org files in the default location below, change `org-directory'. It must be set before org loads!

#+begin_src emacs-lisp :tangle yes
(setq org-directory (file-name-concat (getenv "HOME") "/org"))
#+end_src

** Подгрузка остальных пакетов

#+begin_src emacs-lisp :tangle yes
(use-package org-cliplink
    :ensure t)
;; (use-package orgit
;;     :ensure t)
(use-package ox-clip
    :ensure t)
(use-package toc-org
    :ensure t)
(use-package know-your-http-well
    :ensure t)
#+end_src

** Запуск скриптов в org-babel src-блоках
   :PROPERTIES:
   :ID:       c98e419e-f7e9-456d-b8f3-5037f0af775b
   :END:

Подготовим функцию для регистрации org-babel блока. Как только для
соответствующего языка будет загружена его поддержка, то эту функцию
можно будет вызвать:
: (my/--register-org-babel 'rust)

#+begin_src emacs-lisp :tangle yes
(defun my/--register-org-babel (type)
    (let ((langs (cons `(,type . t) org-babel-load-languages)))
        (org-babel-do-load-languages 'org-babel-load-languages
                                     langs)))
#+end_src

А об остальных сущностях позаботимся сейчас. Подгружаем пакеты для
запуска скриптов в org-babel блоках.

#+begin_src emacs-lisp :tangle yes
(use-package ob-async
    :ensure t
    :defer t)

(org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     ))
#+end_src

** Поддержка показа картинок в результатах выполнения org-babel блоков

Удобно сделать показ картинок в результатах src-блоков без указания
имени файла картинки.  Для создания временного файла есть функция
=org-babel-temp-file=, воспользуемся ей.  Макрос ниже создает лямбду,
которая будет оборачивать через =advice-add= функции типа
=org-babel-execute:<тип_блока>=.

#+begin_src emacs-lisp :tangle yes
(defmacro my/org-babel-execute (prefix)
    `(lambda (func &rest args)
         (let* ((body (car args))
                (params (cadr args))
                (out-file-p (cdr (assq :file params)))
                (out-file (or out-file-p
                              (org-babel-temp-file ,(format "%s-" (symbol-name prefix)) ".png")))
                (new-params (if out-file-p
                                params
                                (cons `(:file . ,out-file) params)))
                (result (apply func (list body new-params))))
             (if out-file-p
                 result
                 out-file))))
#+end_src

** Перенос длинных строк по словам

В org-mode удобно видеть перенос строк по словам.

Чтобы сделать простой перенос строк, надо вызвать функцию
=toggle-truncate-lines=, а чтобы перенос строк был по словам, надо
добавить к ней вызов =toggle-word-wrap=.  Определим функцию, которая
объединяет эти два вызова.

#+begin_src emacs-lisp :tangle yes
(defun my/set-word-wrap (&optional arg)
	(interactive)
	(toggle-word-wrap arg)
	(toggle-truncate-lines arg))
#+end_src

Теперь добавим обработчик для режима org-mode. Но надо быть
осторожным: если где-то будет добавлен такой же обработчик на
text-mode, то он отменит перенос строк. :)

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'my/set-word-wrap)
#+end_src

А на функцию выше повесим горячие клавиши (пригодится).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t w" #'my/set-word-wrap)
#+end_src

** Поддержка org-календаря

Определим клавиши навигации по org-календарю на привычные "hjkl".

#+begin_src emacs-lisp :tangle yes
(define-key org-read-date-minibuffer-local-map (kbd "M-h") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-day 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-l") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-day 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-k") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-week 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-j") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-week 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-H") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-month 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-L") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-month 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-K") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-year 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-J") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-year 1))))
#+end_src

** Карсивые метки списков

Поставим красивые метки списков (bullets) посредством пакета =org-bullets=.

#+begin_src emacs-lisp :tangle yes
(use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

** Отступы в src-блоках

Убираем бесячий автоотступ при сохранении src-блоков.

#+begin_src emacs-lisp :tangle yes
(setq org-src-preserve-indentation t
      org-src-tab-acts-natively t)
#+end_src

** Автоматическое схлопывание org-babel блоков

Есть способ схлопывать все org-babel блоки на открытии org-файла.
Делается это или глобально через установку переменной =org-hide-block-startup=,
или через установку таких вот взамоисключающих заголовков в нужных org-файлах:

: #+STARTUP: hideblocks
: #+STARTUP: nohideblocks

Для выборочного схлопывания/показа блоков напишем обрботчик даух новых аргументов:
- =:hidden=  - блок показывается схлопнутым,
- =:visible= - блок блок показывается развернутым.
Эти аргументы можно применять в сочетании с командами выше (=nohideblocks=, =hideblocks=).

#+begin_src emacs-lisp :tangle yes
(defun my/individual-visibility-source-blocks ()
    "Fold blocks with argument :hidden in the current buffer."
    (interactive)
    (let ((block-types '(center-block comment-block dynamic-block example-block
                         export-block quote-block special-block src-block verse-block)))
        (org-block-map
         (lambda ()
             (let ((element (org-element-at-point)))
                 (when (member (org-element-type element) block-types)
                     (let ((arguments (cl-third (org-babel-get-src-block-info t))))
                         (cond ((cl-assoc ':hidden arguments)
                                (org-hide-block-toggle t nil element))
                               ((cl-assoc ':visible arguments)
                                (org-hide-block-toggle 'off nil element))))))))))
#+end_src

Обработчик, представленный выше, будет срабатывать при открытии org-документа.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'my/individual-visibility-source-blocks)
#+end_src

Скрытие блоков слетает на применении org-cycle,
поэтому запилим горячие клавиши для принудительного схлопывания/показа:
- org-babel блоков с аргументами =:hidden= или =:visible=,
- всех org-babel блоков в буфере.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "s" '(:ingore t :which-key "fold")
                    "s o" '(my/individual-visibility-source-blocks
                            :which-key "Fold :hidden src-blocks")
                    "s O" '(org-hide-block-all
                            :which-key "Fold all stc-blocks except :visual"))
#+end_src

** Параметры экспортирования из org-mode

Более полно про параметры экспорта можно прочитать на [[https://orgmode.org/manual/Export-Settings.html][странице документации]].

Убираем TeX-овые над/подстрочные шрифты.
Включить для отдельных документов можно опцией: "#+options: ^:t"

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-sub-superscripts nil)
#+end_src

Убираем автоматические номера из заголовков.
Включить для отдельных документов можно опцией: "#+options: num:t"

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-section-numbers nil)
#+end_src

Соблюдаем все переносы строк, что и в исходном org-файле.
Включить для отдельных документов можно опцией: "#+options: \n:t"
(Пришел к тому, что надо убрать.)

#+begin_example emacs-lisp :tangle yes
(setq org-export-preserve-breaks t)
#+end_example

Убираем автора из экспорта.
Включить для отдельных документов можно опцией: "#+options: author:t"

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-author nil)
#+end_src

Убираем оглавление путем указания ему неопределенного места.
Включить для отдельных документов можно опцией: "#+options: toc:t"
Подробнее смотри на [[https://orgmode.org/manual/Table-of-Contents.html][странице документации по оглавлению]].

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-toc nil)
#+end_src

** Ручная вставка оглавления (toc)

Автоматическое создание оглавления при экспорте отключено в предыдущем
параграфе. Однако, можно вставлять вручную оглавление с работающими
ссылками, если это нужно. Отвечает за это пакет =toc-org= и функция из
него =toc-org-mode=.

Штука эта работает как с org, так и с markdown.

При включении режима =toc-org-mode= для оглавления достаточно
поставить заголовку тег =:toc:= и сохранить файл. После этого
оглавление со ссылками возникнет автоматически:
: * Оглавление  :toc:
или
: # Оглавление  :toc:

Настроим режим =toc-org-mode= на соответствующие режимы.

#+begin_src emacs-lisp :tangle yes
(if (require 'toc-org nil t)
    (progn (add-hook 'org-mode-hook 'toc-org-mode)
           (add-hook 'markdown-mode-hook 'toc-org-mode)
           (my/evil-define-key '(normal visual mition) 'markdown-mode-map
                               "RET" 'toc-org-markdown-follow-thing-at-point))
    (warn "toc-org not found"))
#+end_src

Глубина заголовков в оглавлении.

#+begin_src emacs-lisp :tangle yes
(setq toc-org-max-depth 10)
#+end_src

** Вычисление babel-блоков при экспорте

Запрещаем вычисление блоков при экспорте.  (Не сбрасывать
org-export-babel-evaluate в nil - будут игнорирроваться все
заголовки!)

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook
          (lambda ()
              (setq org-babel-default-header-args
                    (cons '(:eval . "never-export")
                          (assq-delete-all :eval
                                           org-babel-default-header-args)))))
#+end_src

В качестве альтернативы можно использовать одно из двух:
- или ставим в каждом заголовке
  : :eval never-export
- или один раз прописываем в начале файла
  : #+PROPERTY: header-args :eval never-export.

** Экспорт в PDF через Latex

Русский шрифт заработает совместно с установкой:

#+begin_example bash
# Ubuntu:
sudo apt install texlive-lang-cyrillic
# Arch Linux:
sudo pacman -S texlive-langcyrillic
sudo pacman -S texlive-latexextra
#+end_example

Так можно задавать нужные заголовки прямо в org-файле.

#+begin_quote
#+latex_header: \usepackage[utf8x]{inputenc}
#+latex_header: \usepackage[T2A]{fontenc}
#+latex_header: \usepackage[russian,english]{babel}
#+end_quote

Поместим настройки выше в переменную =org-latex-default-packages-alist=

#+begin_src emacs-lisp :tangle yes
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t
         ("pdflatex"))
        ("" "graphicx" t nil)
        ("" "grffile" t nil)
        ("" "longtable" nil nil)
        ("" "wrapfig" nil nil)
        ("" "rotating" nil nil)
        ("normalem" "ulem" t nil)
        ("" "amsmath" t nil)
        ("" "textcomp" t nil)
        ("" "amssymb" t nil)
        ("" "capt-of" nil nil)
        ("" "hyperref" nil nil)
        ("utf8x" "inputenc" nil nil)
        ("T2A" "fontenc" nil nil)
        ("russian,english" "babel" nil nil)))
#+end_src

** Экспорт в Markdown

Экспорт в markdown может быть сделан следующими функциями:
- Встроенными в org:
  + =org-md-export-as-markdown=,
  + =org-md-export-to-markdown=.
  Недостаток их в том, что таблицы экспортируются в HTML-виде.
- Из пакета ox-gfm:
  + =org-gfm-export-to-markdown=,
  + =org-gfm-export-as-markdown=.
  Здесь таблички имеют текстовый вид, но их верстка едет.

Все же будем пользоваться пакетом =ox-gfm=.

#+begin_src emacs-lisp :tangle yes
(use-package ox-gfm
    :ensure t)
#+end_src

** LaTeX preview. Формулы проямо в org-тексте

Здесь не будет настроек, а только памятка, чтобы вспоминать, как этим
пользоваться.

Сперва требуется установить =dvipng= (я установил еще вдогонку
=preview-latex-style=):
#+begin_example bash
# Ubuntu:
# sudo apt install dvipng preview-latex-style
# Arch Linux: устанавливается вместе с пакетами texlive.
sudo pacman -S texlive
#+end_example

Этого достаточно! Теперь можно вставлять прямо в org-текст TeX'овские
штуки:

| вторая степень          | $$x^2$$            |
| корень из дискриминанта | $$\sqrt{b^2-4ac}$$ |

Чтобы показать это надо или выделить текст с формулами, или навести
курсор на нужную формулу, после чего вызвать функцию =(org-latex-preview)=
(стандартные клавиши - =C-v C-x C-l= и просто =RET= для Doom).

Чтобы формулы показывались сразу при открытии org-файла, нужно в
заголовке startup указать значение =latexpreview=.

При экспорте в LaTeX+PDF все формулы будут преобразованы в
соответствующие изображения.

И еще маленькое удобство: при экспорте во что угодно спецсимволы типа
\lambda, \Sigma изображаются соответстущими символами греческого
алфавита.

** LaTeX preview. Ручное изменение размеров формул (костыль)

На одном из ноутов формулы стали не выше текстовой строки.  Полагаю,
что софт ловит физический размер экрана и строит формулы по нему
(больше разрешение - меньше формула).

Сделаем костыль по увеличению и уменьшению формул.

#+begin_src emacs-lisp :tangle yes
(defun my/latex-preview-scale-set (scale)
    (if (> scale 0.0)
            (setq org-format-latex-options (plist-put org-format-latex-options
                                                      :scale (float scale)))
        (plist-get org-format-latex-options :scale)))

(defun my/latex-preview-scale-inc ()
    (let ((prev-scale (plist-get org-format-latex-options :scale)))
        (my/latex-preview-scale-set (+ prev-scale 1.0))))

(defun my/latex-preview-scale-dec ()
    (let ((prev-scale (plist-get org-format-latex-options :scale)))
        (my/latex-preview-scale-set (- prev-scale 1.0))))
#+end_src

Вешаем на горячие клавиши и приделываем сообщения. Поскольку быстрее всего сразу
назначить величину масштаба (например 4), то первой предусмотрим такую операцию.
Остальные две - увеличить и уменьшить.

#+begin_src emacs-lisp :tangle yes
(defun my/set-scale-for-latex-preview (scale)
	(interactive (list (read-string "Enter LaTeX preview scale: ")))
	(my/latex-preview-scale-set (float (string-to-number scale)))
	(message "Latex scale = %f"
			 (plist-get org-format-latex-options :scale)))

(defun my/increace-scale-for-latex-preview ()
	(interactive)
	(my/latex-preview-scale-inc)
	(message "Latex scale = %f"
			 (plist-get org-format-latex-options :scale)))

(defun my/decreace-scale-for-latex-preview ()
	(interactive)
	(my/latex-preview-scale-dec)
	(message "Latex scale = %f"
			 (plist-get org-format-latex-options :scale)))

(my/localleader-def nil 'org-mode-map
                    "j" '(:ignore t :which-key "latex")
                    "j s" #'my/set-scale-for-latex-preview
                    "j k" #'my/increace-scale-for-latex-preview
                    "j j" #'my/decreace-scale-for-latex-preview)
#+end_src

** Копирование ссылки в буфер обмена

Быстрое вытаскивание ссылки из org-текста. Ссылка копируется сразу в три регистра: `+', `*' и `"'.

#+begin_src emacs-lisp :tangle yes
(defun my/org-copy-link-url ()
    (interactive)
    (kill-new (org-element-property :raw-link (org-element-context)))
    (let ((text (evil-get-register ?\")))
        (evil-set-register ?+ text)
        (evil-set-register ?* text)
        (evil-set-register ?0 text)
        (message text)))
#+end_src

Горячие клавиши для копирования ссылки.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "l" '(:ignore t :which-key "links"))
(my/localleader-def nil 'org-mode-map
                    "l y" #'my/org-copy-link-url)
#+end_src

** Преобразование URL в ссылку с именем задачи или файла

Часто в org-документах перевожу URL задач из Jira типа:
: https://....ru/jira/TASK-123
в ссылки, подобные этой:
: [[https://....ru/jira/TASK-123][TASK-123]]

Чтобы сократить время на редактирование таких ссылок, сделаем функцию.
Она принимает контекст org-элемента под курсором и в случае, если это URL,
создает ссылку, как показано выше.

Функция делает то же самое и для ссылок на файлы.

Параметром является ссылка на функцию преобразования сырой ссылки. Нужно это для
создания ссылки на открытие файла системой.

#+begin_src emacs-lisp :tangle yes
(defun my/make-task-link--common (&optional raw-link-converter)
    (let* ((element (org-element-context))
           (type (org-element-property :type element))
           (raw-link (org-element-property :raw-link element))
           (link (if raw-link-converter
                         (funcall raw-link-converter type raw-link)
                     raw-link))
           (is-url (org-url-p raw-link)))
        (when (or is-url
                  (equal type "file"))
            (let* ((start (org-element-property :begin element))
                   (end (org-element-property :end element))
                   (path (org-element-property :path element))
                   (parts (seq-filter (lambda (str)
                                          (not (string-empty-p str)))
                                      (split-string path "/")))
                   (task-name (car (last parts))))
                (delete-region start end)
                (insert (concat "[[" link "][" task-name "]]" (if is-url " " "")))
                (goto-char start)))))
#+end_src

Для файлов может быть полезна ссылка сразу на его открытие в системе
(gio open).  Напишем функцию преобразования пути файла в его
открытие. Здесь еще важно заменить "~" на динамическое определение
домашней директории.

#+begin_src emacs-lisp :tangle yes
(defun my/make-link-for-call--convert-file-raw-link-for-call (type raw-link)
    (if (equal type "file")
        (concat "elisp:(call-process \"gio\" nil 0 nil \"open\" "
                "(expand-file-name \"" raw-link "\"))")
        raw-link))
#+end_src

Пара конечных функций для горячих клавиш ("ссылка" и "открытие файла").

#+begin_src emacs-lisp :tangle yes
(defun my/make-task-link ()
    (interactive)
    (my/make-task-link--common))

(defun my/make-link-for-call ()
    (interactive)
    (my/make-task-link--common #'my/make-link-for-call--convert-file-raw-link-for-call))
#+end_src

Добавляем горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
    "l m" #'my/make-task-link
    "l M" #'my/make-link-for-call)
#+end_src

** Открытие картинок (и файлов) по ссылке в том же буфере

Сделаем возможность открыть показанную в org-буфере картинку
отдельно. Это может быть нужно для более детального ее рассмотрения в
большем масштабе, чем в исходном буфере.

#+begin_src emacs-lisp :tangle yes
(defun my/open-picture-in-same-window ()
    (interactive)
    (when-let* ((element (org-element-context))
                (file-p (equal "file" (org-element-property :type element)))
                (raw-link (org-element-property :raw-link element))
                (file (if (string= "file" (car (split-string raw-link ":")))
                          (substring raw-link (length "file:"))
                          raw-link)))
        (find-file file)))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "RET" '(my/open-picture-in-same-window
                            :which-key "Open file or picture"))
#+end_src

** Клавиши для работы с таблицами

Восстановим привычную раскладку из Doom для работы с таблицей.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
    "b i c" #'org-table-insert-column
    "b i h" #'org-table-insert-hline
    "b i H" #'org-table-hline-and-move
    "b i r" #'org-table-insert-row
    "b d c" #'org-table-delete-column
    "b d r" #'org-table-kill-row
    "b -" #'org-table-insert-hline
    "b a" #'org-table-align
    "b c" #'org-table-create-or-convert-from-region
    "b e" #'org-table-edit-field
    "b f" #'org-table-edit-formulas
    "b g" #'org-table-toggle-column-width
    "b h" #'org-table-field-info
    "b r" #'org-table-recalculate
    "b R" #'org-table-recalculate-buffer-tables
    "b s" #'org-table-sort-lines
    "b t f" #'org-table-toggle-formula-debugger
    "b t o" #'org-table-toggle-coordinate-overlays)
#+end_src

Назначим описание этой группы клавиш.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
    "b" '(:ignore t :which-key "tables")
    "b d" '(:ignore t :which-key "delete")
    "b i" '(:ignore t :which-key "insert")
    "b t" '(:ignore t :which-key "toggle"))
#+end_src

** Показ картинок-результатов выполнения org-babel блоков

Картинки отрисовываются сразу после загрузки org-файла.
Вручную этим можно управлять такими инструкциями:
: #+STARTUP: inlineimages
: #+STARTUP: noinlineimages

#+begin_src emacs-lisp :tangle yes
(setq org-startup-with-inline-images t)
#+end_src

А также сразу после выполнения org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src

Чтобы можно было задавать размер картинки через #+attr_org:
: #+attr_org: :width 800
нужно сбросить переменную в nil.

#+begin_src emacs-lisp :tangle yes
(setq org-image-actual-width nil)
#+end_src

** Показ времени выполнения babel-блока

Здесь вычисляется время выполнения babel-блока.
Результат пойдет в регистры ="= и, внимание!, =t=.

#+begin_src emacs-lisp :tangle yes
(defun my/time-call-decorator (time-call &rest args)
    "Decorator for execiting of org-mode babel.

The decorator measures time of babel execution,
shows it in message and put the result into registers `\"' and `t'."
    ;; (message "Ohai %s" args)
    (let ((start-time (float-time))
          (delta 0.0)
          (formatted-delta "")
          (result (apply time-call args)))
        (setq delta (- (float-time) start-time))
        (setq formatted-delta (format "%f sec" delta))
        (evil-set-register ?\" formatted-delta)
        (evil-set-register ?t formatted-delta)
        (message "Execution time is %f seconds" delta)
        result))
#+end_src

В elisp есть подобие декоратора к функции.
Делается посредством функции =advice-add=.
Ниже в ее параметрах используется параметр =:around=.
Чтобы убрать декоратор, есть функция =advice-remove=.

Вешаем декоратор для подсчета времени на функцию =org-babel-execute-src-block=.

#+begin_src emacs-lisp :tangle yes
(advice-add 'org-babel-execute-src-block :around #'my/time-call-decorator)
#+end_src

Чтобы убрать декоратор к вычислению babel, надо выполнить это:

#+begin_example
(advice-remove 'org-babel-execute-src-block #'my/time-call-decorator)
#+end_example

** Org-modern. Красивое представление org

Красивое представление org-файлов может пригодится для показа
презентаций.

#+begin_src emacs-lisp :tangle yes
(use-package org-modern
    :ensure t)
#+end_src

** Слайды и презентации

Для показа интерактивных презентаций воспользуемся пакетом
=org-tree-slide=.

#+begin_src emacs-lisp :tangle yes
(use-package org-tree-slide
	:ensure t
    :config
    (setq org-tree-slide-header nil
          org-tree-slide-slide-in-effect t
          org-tree-slide-content-margin-top 2))
#+end_src

Однако, в чистом виде слайды выглядят некрасиво. Будем облагораживать
вид презентаций вручную.

Для скрытия и показа меток стиля текста сделаем функцию. Она установит
переменную =org-hide-emphasis-makers= и перезагрузит буфер.

#+begin_src emacs-lisp :tangle yes
(defun my/org-hide-emphasis-makers (arg)
    (setq org-hide-emphasis-markers arg)
    (revert-buffer :ignore-auto :noconfirm))
#+end_src

Определим функции, которые скрывают и показывают операторные скобки
`#+begin_...' - `#+end_...' через изменение цвета текста. Цвет
запоминается на время в стек и из него же достается для восстановления
исходного состояния.

#+begin_src emacs-lisp :tangle yes
(setq my/begin:end-block-delimiters nil)

(defun my/hide-begin:end-block-delimiters ()
    (let ((begin-color (face-foreground 'org-block-begin-line nil 'default))
          (end-color (face-foreground 'org-block-end-line nil 'default)))
        (setq my/begin:end-block-delimiters
              (cons `(,begin-color . ,end-color) my/begin:end-block-delimiters))
        (set-face-attribute 'org-block-begin-line nil
                            :foreground (face-background 'org-block-begin-line nil 'default))
        (set-face-attribute 'org-block-end-line nil
                            :foreground (face-background 'org-block-end-line nil 'default))))

(defun my/show-begin:end-block-delimiters ()
    (let ((colors (car my/begin:end-block-delimiters)))
        (setq my/begin:end-block-delimiters (cdr my/begin:end-block-delimiters))
        (set-face-attribute 'org-block-begin-line nil :foreground (or (car colors) 'unspecified))
        (set-face-attribute 'org-block-end-line nil :foreground (or (cdr colors) 'unspecifie))))
#+end_src

Теперь определим функции, которые:
- отцентрируют текст (пакет =centered-window-mode=),
- скроют отвлекающие от слайда внимание элементы.

#+begin_src emacs-lisp :tangle yes
(defun my/slide-view-on ()
    "Prepare window for org-tree-slide-mode."
    (interactive)
    (if (eq major-mode 'org-mode)
        (progn
            (set-frame-parameter nil 'internal-border-width 80)
            (my/org-hide-emphasis-makers t)
            (my/hide-begin:end-block-delimiters)
            (org-modern-mode 1)
            (my/display-line-numbers -1)
            (vi-tilde-fringe-mode -1)
            (my/set-word-wrap)
            (my/hide-header-line)
            ;; (highlight-indent-guides-mode -1)
            ;; (centered-window-mode 1)
            (org-tree-slide-mode 1))
        (message "For org-mode only!")))

(defun my/slide-view-off ()
    "Returt window state from org-tree-slide-mode."
    (interactive)
    (if (eq major-mode 'org-mode)
        (progn
            (set-frame-parameter nil 'internal-border-width 0)
            (my/org-hide-emphasis-makers nil)
            ;; (centered-window-mode -1)
            ;; (highlight-indent-guides-mode 1)
            (my/show-header-line)
            (org-modern-mode -1)
            (my/show-begin:end-block-delimiters)
            (my/display-line-numbers 1)
            (vi-tilde-fringe-mode 1)
            (my/set-word-wrap)
            (org-tree-slide-mode -1))
        (message "For org-mode only!")))
#+end_src

Сделаем переключатель режима презентации и обычного режима редактирования.

#+begin_src emacs-lisp :tangle yes
(setq my/slide-view-state nil)

(defun my/slide-view-toggle ()
    "Toggle window state for org-tree-slide-mode."
    (interactive)
    (setq my/slide-view-state (not my/slide-view-state))
    (if my/slide-view-state
            (my/slide-view-on)
        (my/slide-view-off)))
#+end_src

Повесим переключение в режим показа презентации на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'org-mode-map
    "t c" #'my/slide-view-toggle)
#+end_src

А это из документации к org-tree-slide, листаем слайды.

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "org-tree-slide"
    (define-key org-tree-slide-mode-map (kbd "<f9>") 'org-tree-slide-move-previous-tree)
    (define-key org-tree-slide-mode-map (kbd "<f10>") 'org-tree-slide-move-next-tree))
#+end_src

** Новый буфер в режиме org-mode

Очень часто открываю новый буфер, после чего устанавливаюему режим org-mode. Автоматизируем эти действия.

#+begin_src emacs-lisp :tangle yes
(defun my/open-new-buffer-in-org-mode ()
    (interactive)
    (let ((buffer (generate-new-buffer "*new Org-mode*")))
        (set-window-buffer nil buffer)
        (with-current-buffer buffer
            (org-mode))))
#+end_src

И горячие клавиши к созданию нового org-буфера.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "b o" #'my/open-new-buffer-in-org-mode)
#+end_src

** Работа с параграфом в отдельном буфере (indirect buffer)

Иногда бывает удобно поработать с параграфом в отдельном буфере. Так
скрывается все лишнее, как для работы, так и для показа.  Для такой
работы есть встроенная в ORG функция =org-tree-to-indirect-buffer=.
Достаточно лишь назначить на нее горячие клавиши по-удобней.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'org-mode-map
                    "C-<tab>" #'org-tree-to-indirect-buffer)
#+end_src

** Agenda

Настраиваем Агенду.

#+begin_src emacs-lisp :tangle yes
(require 'org-agenda)
(setq-default org-agenda-deadline-faces '((1.001 . error)
                                          (1.0 . org-warning)
                                          (0.5 . org-upcoming-deadline)
                                          (0.0 . org-upcoming-distant-deadline))
              org-agenda-window-setup 'current-window
              org-agenda-skip-unavailable-files t
              org-agenda-span 'month
              org-agenda-start-on-weekday nil
              org-agenda-start-day "-3d"
              org-agenda-inhibit-startup t)
(evil-define-key '(normal visual motion) org-agenda-mode-map (kbd my/leader) nil)
(when my/evil
    ;; (add-hook 'org-agenda-mode-hook #'evil-force-normal-state)
    (evil-set-initial-state 'org-agenda-mode 'normal))
#+end_src

Здесь автоматизированы мои действия по созданию рабочего пространства
с agenda'ой:
1. Создаем рабочее пространство с именем ="Agenda"=.
2. Открываем в нем саму agenda'у.
Повесим эти действия на горячие клавиши.

(Еще то же самое можно сделать с вкладками (tab), но с рабочим
пространством оказалось удобней работать.)

#+begin_src emacs-lisp :tangle yes
(setq my/agenda-persp-name "Agenda")

(defun my/new-persp-with-agenda-list ()
    (interactive)
    (persp-frame-switch my/agenda-persp-name)
    (org-agenda-list)
    (delete-other-windows))

(defun my/switch-to-persp-with-agenda ()
    (interactive)
    (if (member my/agenda-persp-name persp-names-cache)
        (persp-frame-switch my/agenda-persp-name)
        (my/new-persp-with-agenda-list)))

(defun my/new-tab-with-agenda-list ()
    (interactive)
    (my/new-tab-with-name "agenda")
    (org-agenda-list)
    (delete-other-windows))

(my/leader-def nil 'override
               "o" '(:ignore t :which-key "open")
               "o a" '(:ignore t :which-key "agenda")
               "o A" '(org-agenda :which-key "Agenda")
               "o a a" '(org-agenda :which-key "Agenda")
               "o a s" '(my/switch-to-persp-with-agenda :which-key "Switch to Agenda space")
               "o a n" #'my/new-persp-with-agenda-list
               "o a t" #'my/new-tab-with-agenda-list)
#+end_src

Докатим привычные горячие клавиши из Doom для работы с TODO.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "d" '(:ignore t :which-key "tasks"))
(my/localleader-def nil 'org-mode-map
                    "t" #'org-todo
                    "d s" #'org-schedule
                    "d d" #'org-deadline)
#+end_src

Отдельно сделаем агенду на задачи в открытом файле.  Здесь просто
добавляем пункт в меню агенды "c".

#+begin_src emacs-lisp :tangle yes
(setq org-agenda-custom-commands

      '(("n" "Agenda and all TODOs"
         ((agenda #1="")
          (alltodo #1#)))

        ("c" "Agenda from current file" agenda ""
         ((org-agenda-files (list (buffer-file-name)))))))
#+end_src

** Agenda. Статусы задач

Здесь определяются нужные мне статусы задач.

#+begin_src emacs-lisp :tangle yes
(setq my/org-todo-keywords
      '((sequence "TODO(t)" "IN-WORK(w)" "PAUSE(p)" "|" "DONE(d)" "CANCELED(c)" "SOMETIME(s)")))
(setq org-todo-keywords my/org-todo-keywords)
(defun my/set-org-todo-keywords ()  ; Принудительное восстановление статусов задач.
    (interactive)
    (setq org-todo-keywords my/org-todo-keywords))
#+end_src

Навесим теперь статусы, куда сработают.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-agenda-mode-hook #'my/set-org-todo-keywords)
(my/set-org-todo-keywords)
#+end_src

** Journal

Ведение дневника и ежедневных заметок.

Установим пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package org-journal
    :ensure t
    :config
    (setq org-journal-dir (file-name-concat org-directory "/journal")))
#+end_src

И горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "n j" '(:ignore t :which-key "journal")
               "n j j" #'org-journal-new-entry
               "n j J" #'org-journal-new-scheduled-entry
               "n j d" #'org-journal-new-date-entry
               "n j s" #'org-journal-search-forever)
#+end_src

** Drag-n-drop в dired-mode (org-download)

Перетаскиваем мышкой картинки извне в dired-mode.

#+begin_src emacs-lisp :tangle yes
(use-package org-download
    :ensure t)
(add-hook 'dired-mode-hook 'org-download-enable)
#+end_src

* Org-roam
** Установка

Боремся с рассинхроном пакетов при их обновлении.

#+begin_src emacs-lisp :tangle yes
(provide 'seq-25)
#+end_src

Загрузка пакета и начальная инициализация.

#+begin_src emacs-lisp :tangle yes
(use-package org-roam
    :ensure t
    :init
    (setq org-roam-directory (file-truename "~/org/roam/"))
    (mkdir org-roam-directory t)
    (setq org-roam-v2-ack t)
    (setq org-roam-database-connector 'sqlite-builtin)
    :config
    (define-key org-roam-preview-map (kbd my/leader) nil)
    (define-key org-roam-node-map (kbd my/leader) nil)
    (define-key org-roam-mode-map (kbd my/leader) nil)
    (add-hook 'org-roam-mode-hook #'my/set-word-wrap)
    (setq org-roam-node-display-template (concat (propertize "${tags:40}  "
                                                             'face
                                                             'org-tag)
                                                 "${title:-1} "))
    ;;(setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:20}" 'face 'org-tag)))
    (org-roam-db-autosync-mode 1)
    (require 'org-roam-protocol))
#+end_src

Поработаем над буфером показа ссылок на открытую карточку. Исключим
повторяющиеся ссылки. Введем фильтр по тегам с простой логикой:
: tag1 tag2 !tag3
означает: содержит теги "tag1" и "tag2" и не содержит "tag3".

Также разделим фильтр на две части, положительную и отрицательную,
посредством символа `~'.  На все, что останется за `~', будет наложено
отрицание:
: tag1 !tag2 ~ tag3 !tag4
Это нужно для применения 'or' логики вместо 'and'. Пример фильтра, где
нужен или "tag1", или "tag2", или оба сразу:
: ~ !tag1 !tag2
Наворачивать что-то более сложное пока не вижу смысла. :)

Логику эту будем держать строкой в переменной my/org-roam--filter-tags.

#+begin_src emacs-lisp :tangle yes
(setq org-roam-mode-sections '(my/org-roam--filter-tags-section
                               (org-roam-backlinks-section
                                :unique t
                                :show-backlink-p my/org-roam--show-backlink-by-tags-p)
                               org-roam-reflinks-section))

(defvar my/org-roam--filter-tags ""
  "String with tags separated by spaces.
To inverse filter logic use '!' before tag:
    'tag1 tag2 !tag3'
To split positive and negative parts use '~' char:
    'tag1 !tag2 ~ tag3 !tag4'
For example: 'or' logic instead of 'and' logic:
    '~ !tag1 !tag2'")

(defun my/org-roam--filter-tags-section (node)
    (when (not (string-empty-p my/org-roam--filter-tags))
        (magit-insert-section (org-roam-backlinks)
            (magit-insert-heading (concat "FILTER: "
                                          my/org-roam--filter-tags)))))

(defun my/org-roam--show-backlink-by-tags-p (backlink)
    (let* ((parts (split-string my/org-roam--filter-tags "~"))
           (part-positive (string-trim (car parts)))
           (part-negative (string-trim (string-join (cdr parts) " ")))
           (tags-positive (split-string part-positive))
           (tags-negative (split-string part-negative))
           (node (org-roam-backlink-source-node backlink))
           (node-tags (org-roam-node-tags node)))
        (and (my/org-roam--check-tags tags-positive node-tags nil)
             (my/org-roam--check-tags tags-negative node-tags t))))

(defun my/org-roam--check-tags (tags node-tags is-not)
    (or (not tags)
        (xor is-not
             (reduce (lambda (a b)
                         (and a b))
                     (mapcar (lambda (tag-name)
                                 (my/org-roam--tag-member tag-name node-tags))
                             tags)))))

(defun my/org-roam--tag-member (tag-name tags)
    (if (string-prefix-p "!" tag-name)
        (not (member (substring tag-name 1) tags))
        (member tag-name tags)))
#+end_src

Для работы с фильтрами по тегам осталось сделать ввод значения
для my/org-roam--filter-tags и обновить буфер "*org-roam*".

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam-filter-backlinks-by-tags (tags-string)
	(interactive (list (read-string "Enter tags: "
                                    my/org-roam--filter-tags)))
    (setq my/org-roam--filter-tags tags-string)
    (when-let ((buffer (get-buffer org-roam-buffer)))
        (with-current-buffer buffer
            (org-roam-buffer-refresh))))
#+end_src

Переопределим реакцию по нажатию Enter на раздел в org-roam-mode.
Нужно, чтобы работало наоборот с префиксным аргументом и без него.

#+begin_src emacs-lisp :tangle yes
(advice-add #'org-roam-node-visit
            :around
            (lambda (func node &optional other-window force)
                (if other-window
                    (funcall func node nil force)
                    (funcall func node t force))))

(advice-add #'org-roam-preview-visit
            :around
            (lambda (func file point &optional other-window)
                (if other-window
                    (funcall func file point nil)
                    (funcall func file point t))))
#+end_src

Открываем узел сразу на весь фрейм и с окном ссылок.

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam-node-find ()
    (interactive)
    (my/hack-dir-locals)
    (org-roam-node-find (my/org-roam--same-window-p))
    ;; (unless (get-buffer-window org-roam-buffer)
    ;;     (org-roam-buffer-toggle))
    )

(defun my/org-roam-node-insert ()
    (interactive)
    (my/hack-dir-locals)
    (org-roam-node-insert)
    ;; (unless (get-buffer-window org-roam-buffer)
    ;;     (org-roam-buffer-toggle))
    )

(defun my/org-roam-buffer-toggle ()
    (interactive)
    (my/hack-dir-locals)
    (org-roam-buffer-toggle)
    (when (get-buffer-window org-roam-buffer)
        (when-let ((buffer (get-buffer org-roam-buffer)))
            (switch-to-buffer-other-window buffer))))

(defun my/org-roam--same-window-p ()
    (if (get-buffer-window org-roam-buffer)
        nil
        t))

(defun my/hack-dir-locals ()
    (hack-dir-local-variables)
    (hack-dir-local-variables-non-file-buffer))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "r" '(:ignore t :which-key "org-roam")
               "r s" #'org-roam-db-sync
               "r r" #'my/org-roam-buffer-toggle
               "r f" #'my/org-roam-node-find
               "r c" #'org-roam-capture
               "r j" #'org-roam-dailies-capture-today
               "r J" #'org-roam-dailies-capture-date
               "r t" '(my/org-roam-filter-backlinks-by-tags
                       :which-key "Filter backlinks by tags")
               "r q" 'org-roam-ql-search
               "r n" #'my/org-roam-show-vault-dir
               "r v" '(:ignore t :which-key "vault")
               "r v i" '(my/org-roam-vault-init :which-key "Init vault in directory")
               "r v s" '(my/org-roam-register-vault-subdirectory
                           :which-key "Register subdirectory"))
(my/leader-def nil 'org-mode-map
               "r i" #'my/org-roam-node-insert
               "r o" '(my/org-roam-convert-to-node :which-key "Convert to node")
               "r a" '(:ignore t :which-key "add")
               "r a a" #'org-roam-alias-add
               "r a r" #'org-roam-ref-add
               "r a t" #'org-roam-tag-add
               "r d" '(:ignore t :which-key "remove")
               "r d a" #'org-roam-alias-remove
               "r d r" #'org-roam-ref-remove
               "r d t" #'org-roam-tag-remove)
#+end_src

** Исключение тегов из наследования

Некоторые теги неудобно наследовать. Например тег документов-списков
"<list": если его ноды находятся в его же файле, то все они этот тег
унаследуют.

В этой пометим все не наследуемые теги префиксом '<'. Код ниже
исключает такие теги из наследования.

#+begin_src emacs-lisp :tangle yes
(defun my/remove-hash-tags (tags)
    (mapcar
     (lambda (tag-list)
         (cl-remove ?< tag-list :key #'string-to-char :test #'char-equal))
     tags))

(advice-add 'org-remove-uninherited-tags :filter-args #'my/remove-hash-tags)
#+end_src

Точечно выводить теги из наследования можно через переменную
: org-tags-exclude-from-inheritance
Например:
: (setq org-tags-exclude-from-inheritance
:       (append '("tag1" "next_tag")
:               org-tags-exclude-from-inheritance))

** Шаблоны
   :PROPERTIES:
   :ID:       eb0ed05e-acc3-40b7-afd2-0cbf8f8e0ad7
   :CUSTOM_ID: eb0ed05e-acc3-40b7-afd2-0cbf8f8e0ad7
   :END:

Для удобства соберем все шаблоны в одном параграфе. Сначала сделаем
шаблоны для хранилища по-умолчанию.

Для основных документов вставим дату в поле `#+date:' - так мне
привычней.

#+begin_src emacs-lisp :tangle yes
(setq org-roam-capture-templates
      `(("d" "default" plain "%?"
             :target
             (file+head "main-roam/%<%Y%m%d%H%M%S>-${slug}.org"
                        ,(concat "#+title: ${title}" "\n"
                                 "#+date: %<%Y-%m-%d>" "\n"
                                 "#+filetags: :@main:" "\n"))
             :empty-lines-before 1
             :unnarrowed t)))
#+end_src

Настроим тег файла =@daily= для daily-заметок, чтобы можно было
фильтровать по ним. Тег заголовкам =@unsorted= тоже ставим
по-умолчанию - предполагаем, что он будет снят после проработки текста
заметки. Сами заголовки делаем отдельными узлами. А еще добавим время
создания заголовка (думаю, это может иногда пригодиться).

#+begin_src emacs-lisp :tangle yes
(setq org-roam-dailies-capture-templates
      `(("d" "default"
             entry ,(concat "* (%<%H:%M>) %? :@unsorted:" "\n"
                            "${my/org-roam--id-copy}" "\n")
             :target
             (file+head "%<%Y-%m-%d>.org"
                        ,(concat "#+title: %<%Y-%m-%d>" "\n"
                                 "#+startup: content" "\n"
                                 "#+filetags: :@daily:" "\n"))
             :empty-lines-before 1)))

(defun my/org-roam--id-copy (node)
    (let ((node-id (org-id-new))
          (level "  "))
        (concat level ":PROPERTIES:" "\n"
                level ":ID: " node-id "\n"
                level ":CUSTOM_ID: " node-id "\n"
                level ":END:")))
#+end_src

Переходим к шаблонам для инициализации хранилищ в других директориях.

Загоним все содержимое будущих .dir-locals.el в шаблон. Здесь вносим
код для изменения путей к хранилищу, а шаблоны копируем из основных.

#+begin_src emacs-lisp :tangle yes
(defvar my/org-roam-vault-dir-locals
  `((nil . ((eval
             . (setq-local org-roam-directory
                           (expand-file-name (locate-dominating-file
                                              default-directory ".dir-locals.el"))))
            (eval
             . (setq-local org-roam-db-location
                           (expand-file-name "org-roam.db" org-roam-directory)))
            (eval
             . (setq-local org-id-locations-file
                           (expand-file-name ".org-id-locations" org-roam-directory)))
            (org-roam-dailies-capture-templates
             . ,org-roam-dailies-capture-templates)
            (org-roam-capture-templates
             . ,org-roam-capture-templates)))))
#+end_src

Для создания заметок в поддиректориях мне понадобятся теги с именем
этой поддиректории. Это поможет быстро фильтровать заметки по
содержимому поддиректорий. Также в шаблоне потребуется буква ключ для
меню создания заметки, и этот ключ должен быть уникальным. Выбор буквы
для ключа автоматизируем.

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam--make-subdirectory-template (subdirectory-name)
    (let* ((subdirectory-name (string-replace " " "-"
                                              subdirectory-name))
           (subdirectory-name (string-replace "data" "datta"
                                              subdirectory-name))  ;; bug fix
           (occupied-keys (mapcar 'car org-roam-capture-templates))
           (key (my/org-roam--choose-directory-key subdirectory-name
                                                   occupied-keys))
           (template-file-name (my/org-roam--make-template-file subdirectory-name
                                                                key)))
        `(,key
          ,subdirectory-name
          plain (file ,template-file-name)
          :target
          (file+head ,(concat subdirectory-name "/%<%Y%m%d%H%M%S>-${slug}.org")
                     ,(concat "#+title: ${title}" "\n"
                              "#+date: %<%Y-%m-%d>" "\n"
                              "#+filetags: :@" subdirectory-name ":" "\n"))
          :unnarrowed t
          :empty-lines-before 1)))

(defun my/org-roam--choose-directory-key (directory-name occupied-keys)
    (let* ((occupied-keys (append occupied-keys '(" " "/" "-" "_")))
           (reversed-path (apply 'concat
                                 (reverse (split-string directory-name "/"))))
           (dir-name-letters (my/org-roam--split-by-letters reversed-path))
           (dir-and-letters (append dir-name-letters
                                    (my/org-roam--minus-list my/org-roam--letters
                                                             dir-name-letters)))
           (result (my/org-roam--minus-list dir-and-letters
                                            occupied-keys)))
        (if result (car result) "X")))

(defun my/org-roam--split-by-letters (text)
    (mapcar 'char-to-string
            (string-to-list text)))

(defconst my/org-roam--letters
  (my/org-roam--split-by-letters (concat "abcdefghijklmnopqrstuvwxyz"
                                         "ABCDEFGHIJKLMNOPQRSTUVWXYZ")))

(defun my/org-roam--minus-list (list-1 list-2)
    (seq-filter (lambda (x)
                    (not (member x list-2)))
                list-1))

(defun my/org-roam--make-template-file (subdirectory-name key)
    (let* ((subdirectory-name (string-replace "/" "--" subdirectory-name))
           (template-file-name-expand (file-name-concat org-roam-directory
                                                        "/templates/"
                                                        subdirectory-name
                                                        "(" key ")" ".org"))
           (template-file-name (replace-regexp-in-string (concat "^" (getenv "HOME"))
                                                         "~"
                                                         template-file-name-expand)))
        (make-empty-file template-file-name t)
        template-file-name))
#+end_src

** Поддержка работы в разных хранилищах (vault) и разных поддиректориях (subdirectory)

Здесь собираются настройки необходимые для работы с разными базами
(хранилицами) для Org-Roam.  Базы не должны пересекаться, поскольку
одна может быть для работы, другая для - личной картотекой и т.п..

Чтобы меньше путаться, в каком хранилище сейчас находимся, напишем
вывод в минибуфер директории текущего хранилища.

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam-show-vault-dir ()
    (interactive)
    (message (concat "Current vault: "
                     (my/org-roam--pretty-path org-roam-directory))))

(defun my/org-roam--pretty-path (path)
    (replace-regexp-in-string (concat "^" (getenv "HOME"))
                              "~"
                              path))
#+end_src

Инициализировать хранилища будем, как указано в официальной
документации: "50.2.5 Per-Directory Local Variables".

Инициализация состоит в создании в директории будущего хранилища
файлика .dir-locals.el. В нем укажем все необходимое для работы с
Org-Roam. Для этого весь код по созданию файлика с полезным содержимым
перенесем в функцию.

Но пополнять содержимое .dir-locals.el будем через фцнкцию
add-dir-local-variable, так мы не нарушим другие данные в
.dir-locals.el. Заниматься инициализацией хранилища будет функция
my/org-roam-vault-init.

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam-vault-init (org-roam-vault-path)
    (interactive "DDirectory for Org-Roam vault: ")
    (find-file org-roam-vault-path)
    (when (yes-or-no-p (concat "Do your want to init a vault in '"
                               (my/org-roam--pretty-path org-roam-vault-path)
                               "'? "))
        (my/org-roam--fill-dir-locals my/org-roam-vault-dir-locals)
        (my/org-roam--save-dir-locals-and-show-the-buffer org-roam-vault-path)
        (make-directory (file-name-concat org-roam-vault-path
                                          "/" org-roam-dailies-directory)
                        t)
        (org-roam-db-sync)))

(defun my/org-roam--fill-dir-locals (dir-locals)
    (mapc (lambda (mode-vars)
              (let ((mode (car mode-vars))
                    (variables (cdr mode-vars)))
                  (my/org-roam--add-dir-local-variables mode variables)))
          dir-locals))

(defun my/org-roam--add-dir-local-variables (mode variables)
    (mapc (lambda (var-val)
              (add-dir-local-variable mode (car var-val) (cdr var-val)))
          (reverse variables)))

(defun my/org-roam--save-dir-locals-and-show-the-buffer (org-roam-vault-path)
    (let ((dir-locals-name ".dir-locals.el")
          (current-buffer-name (buffer-name)))
        (when (eq (compare-strings current-buffer-name 0 (length dir-locals-name)
                                   dir-locals-name nil nil)
                  t)
            (save-buffer))))
            ;; (kill-buffer current-buffer-name)
            ;; (find-file org-roam-vault-path))))
#+end_src

Далее будем шаманить с добавлением поддиректорий. Вручную
регистрировать поддиректорию долго. Это в основном из-за того, что
приходится вспоминать, как это делать.

Для упрощения работы с поддиректориями заведем шаблон и функцию,
которая будет добавлять его в Org-Roam.

Шаблон будет содержать тег с названием поддиректории, а буква-ключ
выбирается автоматом (по-возможности из букв имени поддиректории.
Все это собираем в функцию [[id:eb0ed05e-acc3-40b7-afd2-0cbf8f8e0ad7][my/org-roam--make-subdirectory-template]].

Теперь сделаем функцию, которая в хранилище регистрирует поддиректорию
по одному только ее названию.

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam-register-vault-subdirectory (subdirectory-name)
    (interactive
     (list (read-string (concat "Enter subdirectory name for vault '"
                                (my/org-roam--pretty-path org-roam-directory)
                                "': "))))
    (find-file org-roam-directory)
    (my/org-roam--fill-dir-locals
     `((nil . ((org-roam-capture-templates
                . ,(cons (my/org-roam--make-subdirectory-template subdirectory-name)
                         org-roam-capture-templates))))))
    (find-file (file-name-concat org-roam-directory "/.dir-locals.el"))
    (my/org-roam--save-dir-locals-and-show-the-buffer org-roam-directory))
#+end_src

Ниже напишем код для превращения обычного файла в узел Org-Roam. Для
этого надо в его начало поместить свойство ~:ID:~.

#+begin_src emacs-lisp :tangle yes
(defun my/org-roam-convert-to-node ()
    (interactive)
    (goto-char 0)
    (insert (concat ":PROPERTIES:" "\n"
                    ":ID: " (org-id-new) "\n"
                    ":END:" "\n"))
    (org-cycle-hide-drawers 'all))
#+end_src

** Org-roam-ui

Рисует красивый граф org-roam-узлов подобный Obsidian'у. Открывает для
этого браузер.

#+begin_src emacs-lisp :tangle yes
(use-package org-roam-ui
    :ensure t
    ;; :straight
    ;; (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "r g" '(:ignore t :which-key "ui-mode")
               "r g g" #'org-roam-ui-mode
               "r g f" #'org-roam-ui-follow-mode)
#+end_src

** Org-roam-db-query (только информация)

Здесь размещу только информацию о строении БД для Org-Roam, чтобы ее
не искать и не собирать.

Так можно делать SQL-запросы на elisp в БД Org-Roam.
#+begin_example emacs-lisp
(org-roam-db-query [:select * :from nodes])
(org-roam-db-query [:select :distinct [type] :from links])
#+end_example

Теперь о том, что запрашивать. :) Сперва о том, какие таблицы есть в БД:

- aliases ::
  #+begin_src sql :eval no
  CREATE TABLE aliases (node_id NOT NULL,
                        alias,
                        FOREIGN KEY (node_id) REFERENCES nodes (id) ON DELETE CASCADE);
  CREATE INDEX alias_node_id ON aliases (node_id );
  #+end_src
- citations ::
  #+begin_src sql :eval no
  CREATE TABLE citations (node_id NOT NULL,
                          cite_key NOT NULL,
                          pos NOT NULL,
                          properties,
                          FOREIGN KEY (node_id) REFERENCES nodes (id) ON DELETE CASCADE);
  #+end_src
- files ::
  #+begin_src sql :eval no
  CREATE TABLE files (file UNIQUE PRIMARY KEY,
                      title,
                      hash NOT NULL,
                      atime NOT NULL,
                      mtime NOT NULL);
  #+end_src
- links ::
  #+begin_src sql :eval no
  CREATE TABLE links (pos NOT NULL,
                      source NOT NULL,
                      dest NOT NULL,
                      type NOT NULL,
                      properties NOT NULL,
                      FOREIGN KEY (source) REFERENCES nodes (id) ON DELETE CASCADE);
  #+end_src
  А вот какие типы ссылок бывают (целиком определяются по инструкции к Org):
  |--------+---------------------------------------------------|
  | Тип    | Комментарий                                       |
  |--------+---------------------------------------------------|
  | elisp  |                                                   |
  | file   |                                                   |
  | fuzzy  |                                                   |
  | https  |                                                   |
  | http   |                                                   |
  | id     | На этом типе Org-Roam строит ссылки между узлами. |
  | info   |                                                   |
  | mailto |                                                   |
  |--------+---------------------------------------------------|
- nodes ::
  #+begin_src sql :eval no
  CREATE TABLE nodes (id NOT NULL PRIMARY KEY,
                      file NOT NULL,
                      level NOT NULL,
                      pos NOT NULL,
                      todo,
                      priority,
                      scheduled text,
                      deadline text,
                      title,
                      properties,
                      olp,
                      FOREIGN KEY (file) REFERENCES files (file) ON DELETE CASCADE);
  #+end_src
- refs ::
  #+begin_src sql :eval no
  CREATE TABLE refs (node_id NOT NULL,
                     ref NOT NULL,
                     type NOT NULL,
                     FOREIGN KEY (node_id) REFERENCES nodes (id) ON DELETE CASCADE);
  CREATE INDEX refs_node_id ON refs (node_id );
  #+end_src
- tags ::
  #+begin_src sql :eval no
  CREATE TABLE tags (node_id NOT NULL,
                     tag,
                     FOREIGN KEY (node_id) REFERENCES nodes (id) ON DELETE CASCADE);
  CREATE INDEX tags_node_id ON tags (node_id );
  #+end_src

** Org-ql. Поиск по org-файлам

Строим запросы по org сродни SQL. Может использоваться, как бэкэнд для
показа агенды.

#+begin_src emacs-lisp :tangle yes
(provide 'seq-25)
(use-package org-ql
    :quelpa (org-ql :fetcher github :repo "alphapapa/org-ql"
                    :files (:defaults (:exclude "helm-org-ql.el"))))
(use-package helm-org-ql
    :quelpa (helm-org-ql :fetcher github :repo "alphapapa/org-ql"
                         :files ("helm-org-ql.el")))
#+end_src

** Org-roam-ql. Поиск по файлам org-roam

Выглядит перспективно:
- https://github.com/ahmed-shariff/org-roam-ql

_Пример_ использования (общий select):
#+begin_example emacs-lisp
(org-roam-ql-nodes '([:select [id] :from nodes]))
#+end_example

_Пример_ использования с поиском (результат выведет в отдельном окне):
#+begin_example emacs-lisp
(org-roam-ql-search '(and (todo "TODO") (tags "tag1" "tag2") "*org-roam*"))
#+end_example
Функция =org-roam-ql-search= повешена на горячие клавиши.

_Пример_ для памяти с динамическим блоком. Табличка внутри begin/end
заполнится сама:
#+begin_quote org
,#+begin: org-roam-ql :query (todo "DONE") :columns (title tags) :take 5 :no-link nil
|     | Title | Tags |
|-----+-------+------|
| ... | ...   | ...  |
,#+end:
#+end_quote

Ниже (опять для памяти) описание параметров динамического блока из
документации:

Similar to org-ql, org-roam-ql also provides a dynamic block. The
header parameters are as follows:
- ~:query~ - A valid SOURCE-OR-QUERY
- ~:columns~ - A list of columns to display. Each column name is a slot
  name of org-roam-nodes. For any function/accessor with a name of the
  form org-roam-node-<name>, which takes an org-roam-node as a
  parameter, <name> can also be used column name. For example, if
  there is a function named org-roam-node-short-title, short-title can
  be used as a column name, this will result in a column with the
  title short-title where the content of each row is the result of
  calling the respective function.
- ~:sort~ - Name of a registered sort functions. See org-roam-ql-search
  for more info on the values for sort functions.
- ~:take~ (optional) - If a positive integer N, take the first N
  elements, if a negative -N, take the last N nodes.
- ~:no-link~ (optional) - If a non-nil value is set, the first column
  containing the links will be dropped.
If no-link is not provided as a parameter, the first column is a link
to the node. Since it is an id link, it will be a backlink to the
node.

Сейчас работают следующие функции сортировки (параметр ~:sort~) в
динамических блоках:
#+begin_src emacs-lisp :tangle no :colnames '("Функция сортировки" Комментарий) :exports results :hidden
(mapcar (lambda (dict)
            `(,(symbol-name (plist-get dict :symbol))
              ,(plist-get dict :description)))
        my/org-roam--sort-fn-list)
#+end_src

#+RESULTS:
| Функция сортировки | Комментарий                                                                    |
|--------------------+--------------------------------------------------------------------------------|
| title              | Sort by title.                                                                 |
| title-r            | Reverse sort by title.                                                         |
| file-mtime         | Sort by file mtime.                                                            |
| file-mtime-r       | Reverse sort by file mtime.                                                    |
| file-atime         | Sort by file atime.                                                            |
| file-atime-r       | Recerse sort by file atime.                                                    |
| file-title         | Sort by file title.                                                            |
| file-title-r       | Reverse sort by file title.                                                    |
| title-date         | Sort by date in title.                                                         |
| title-date-r       | Reverse sort by date in title like "...<YYYY-mm-dd..." or "...(YYYY-mm-dd...". |

Устанавливаем эту хорошую штуку.

#+begin_src emacs-lisp :tangle yes
(use-package org-roam-ql
    :ensure t
    :after (org-roam))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package org-roam-ql-ql
    :ensure t
    :after (org-ql org-roam-ql)
    :config
    (org-roam-ql-ql-init))
#+end_src

Настройка функций сортировки.

#+begin_src emacs-lisp :tangle yes
(setq my/org-roam--sort-fn-list
      '((:symbol title
         :description "Sort by title."
         :predicate (lambda (node1 node2)
                        (string< (org-roam-node-title node1)
                                 (org-roam-node-title node2))))
        (:symbol title-r
         :description "Reverse sort by title."
         :predicate (lambda (node1 node2)
                        (not (string< (org-roam-node-title node1)
                                      (org-roam-node-title node2)))))
        (:symbol file-mtime
         :description "Sort by file mtime."
         :predicate (lambda (node1 node2)
                        (my/time< (org-roam-node-file-mtime node1)
                                  (org-roam-node-file-mtime node2))))
        (:symbol file-mtime-r
         :description "Reverse sort by file mtime."
         :predicate (lambda (node1 node2)
                        (not (my/time< (org-roam-node-file-mtime node1)
                                       (org-roam-node-file-mtime node2)))))
        (:symbol file-atime
         :description "Sort by file atime."
         :predicate (lambda (node1 node2)
                        (my/time< (org-roam-node-file-atime node1)
                                  (org-roam-node-file-atime node2))))
        (:symbol file-atime-r
         :description "Recerse sort by file atime."
         :predicate (lambda (node1 node2)
                        (not (my/time< (org-roam-node-file-atime node1)
                                       (org-roam-node-file-atime node2)))))
        (:symbol file-title
         :description "Sort by file title."
         :predicate (lambda (node1 node2)
                        (string< (org-roam-node-file-title node1)
                                 (org-roam-node-file-title node2))))
        (:symbol file-title-r
         :description "Reverse sort by file title."
         :predicate (lambda (node1 node2)
                        (not (string< (org-roam-node-file-title node1)
                                      (org-roam-node-file-title node2)))))
        (:symbol title-date
         :description "Sort by date in title."
         :predicate (lambda (node1 node2)
                        (my/title-date< (org-roam-node-title node1)
                                        (org-roam-node-title node2))))
        (:symbol title-date-r
         :description "Reverse sort by date in title like \"...<YYYY-mm-dd...\" or \"...(YYYY-mm-dd...\"."
         :predicate (lambda (node1 node2)
                        (my/title-date> (org-roam-node-title node1)
                                        (org-roam-node-title node2))))
        ))

(defun my/time< (time1 time2)
    (string< (format-time-string "%Y-%m-%dT%H:%M:%S" time1)
             (format-time-string "%Y-%m-%dT%H:%M:%S" time2)))

(defun my/title-date< (title1 title2)
    (let ((date1 (my/match-date title1))
          (date2 (my/match-date title2)))
        (cond ((and date1 date2)
               (string< date1 date2))
              ((and (not date1) date2)
               nil)
              (t t))))

(defun my/title-date> (title1 title2)
    (let ((date1 (my/match-date title1))
          (date2 (my/match-date title2)))
        (cond ((and date1 date2)
               (string> date1 date2))
              ((and date1 (not date2))
               nil)
              (t t))))

(defun my/match-date (str)
    (when-let
        (pos (string-match
              "[\\<|\\(][0-9][0-9][0-9][0-9]\-[0-9][0-9]\-[0-9][0-9].+[\\>|\\)]"
              str))
        (substring str (1+ pos) (+ pos 11))))

(dolist (dict my/org-roam--sort-fn-list)
    (org-roam-ql-register-sort-fn (plist-get dict :symbol)
                                  (plist-get dict :predicate)))
#+end_src

* Терминалы

** eshell

Настроим приглашение для eshell (с модной буквой 'λ').

#+begin_src emacs-lisp :tangle yes
(setq eshell-prompt-function
      (lambda ()
          (concat (eshell/pwd)
                  " " (my/git-current-branch)
                  " λ ")))

(setq eshell-prompt-regexp "^.* λ ")  ;; Necessary for eshell-prompt-function!

(defun my/git-current-branch ()
    "Return current git-branch or empty string."
    (let ((branch (shell-command-to-string
                   "git branch 2>/dev/null | grep \'^*\' | cut -d '*' -f 2 | sed -e 's/^ *//' | tr -d \'\\n\'")))
        (if (string-empty-p branch)
                ""
            (concat "[" branch "]"))))
#+end_src

Вызов терминала eshell. Терминал создается по возможности свой для
каждого рабочего пространства. Если буфер с таким терминалом уже
создан, то он показывается в окне или окно с таким терминалом
скрывается.

#+begin_src emacs-lisp :tangle yes
(defun my/popup-eshell-toggle ()
    (interactive)
    (let* ((buffer-name (format "*eshell-popup:%s*"
                                (my/--make-buffer-suffix)))
           (buffer (get-buffer buffer-name))
           (window))
        (unless buffer
            (setq buffer (get-buffer-create buffer-name))
            (with-current-buffer buffer
                (eshell-mode)))
        (if-let ((window (get-buffer-window buffer)))
            (delete-window window)
            (pop-to-buffer buffer))))
#+end_src

Запилим горячие клавиши на вызов окошка eshell.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o e" #'my/popup-eshell-toggle
    "o E" #'eshell)
#+end_src

** shell

Делаю, как подстраховку для vterm (не нравится, как он работает на
удаленных машинах).

Вызов терминала shell. Терминал создается по возможности свой для
каждого рабочего пространства. Если буфер с таким терминалом уже
создан, то он показывается в окне.

#+begin_src emacs-lisp :tangle yes
(defun my/popup-shell-toggle ()
    (interactive)
    (let* ((buffer-name (format "*shell-popup:%s*"
                                (my/--make-buffer-suffix)))
           (buffer (get-buffer buffer-name)))
        (if buffer
            (pop-to-buffer buffer)
            (setq buffer (get-buffer-create buffer-name))
            (with-current-buffer buffer
                (shell-mode)
                (shell)
                (pop-to-buffer buffer)))))
#+end_src

Запилим горячие клавиши на вызов окошка shell.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o s" #'my/popup-shell-toggle
    "o S" #'shell)
#+end_src

** vterm

Установим пакет. После установки будет запрос на компиляцию Vterm.

#+begin_src emacs-lisp :tangle yes
(use-package vterm
    :ensure t)
#+end_src

Вызов терминала vterm. Терминал создается по возможности свой для
каждого рабочего пространства. Если буфер с таким терминалом уже
создан, то он показывается в окне или окно с таким терминалом
скрывается.

#+begin_src emacs-lisp :tangle yes
(defun my/popup-vterm-toggle ()
    (interactive)
    (let* ((buffer (my/--get-vterm-buffer-create)))
        (if-let ((window (get-buffer-window buffer)))
            (delete-window window)
            (pop-to-buffer buffer))))

(defun my/--get-vterm-buffer-create ()
    (let* ((buffer-name (format "*vterm-popup:%s*"
                                (my/--make-buffer-suffix)))
           (buffer (get-buffer buffer-name))
           (window))
        (unless buffer
            (setq buffer (get-buffer-create buffer-name))
            (with-current-buffer buffer
                (vterm-mode)))
        buffer))
#+end_src

Чтобы удобнее было работать с проектами, создадим новую вкладку с именем "term", в которую поместим буфер с терминалом vterm.

#+begin_src emacs-lisp :tangle yes
(defun my/open-term-in-new-tab ()
    (interactive)
    (let ((persp-name (my/--get-current-persp-name))
          (buffer (my/--get-vterm-buffer-create)))
        (tab-bar-new-tab)
        (tab-bar-rename-tab (format "vterm:%s" persp-name))
        (tab-bar-mode -1)
        (switch-to-buffer buffer)
        (when my/evil
            (evil-normal-state)
            (evil-emacs-state))))
#+end_src

Привычные горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o t" #'my/popup-vterm-toggle
    "o T" #'vterm
    "o v" #'my/open-term-in-new-tab)
#+end_src

** Асинхронный вызов системных команд (async-shell-command)

При работе а разных рабочих пространствах нужно разделить выхлопы от
функции async-shell-command.  Для этого и напишем код ниже: под каждое
рабочее пространство будет свой буфер выхлопа.

#+begin_src emacs-lisp :tangle yes
(defmacro my/--wrapper-acync-shell-command (out-buffer-name-prefix)
    `(lambda (func command &optional output-buffer error-buffer)
         (let* ((out-buffer (format ,(concat "*" out-buffer-name-prefix ":%s*")
                                    (my/--get-current-persp-name))))
             (funcall func command out-buffer error-buffer))))

(advice-add #'async-shell-command
            :around
            (my/--wrapper-acync-shell-command "Async Shell Command"))

;; (advice-add #'shell-command
;;             :around
;;             (my/--wrapper-acync-shell-command "Shell Command"))
#+end_src

* Удаленный доступ (tramp)

** Клавиши для функций tramp

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "e t" '(:ignore t :which-key "TRAMP")
               "e t t" #'tramp-cleanup-this-connection
               "e t a" #'tramp-cleanup-all-connections)
#+end_src

** Ошибка "Too many authentication failures"

Здесь помещена попытка преодолеть ошибку удаленного подключения по
ssh: "Too many authentication failures".

Если такая ошибка возникает при ssh-соединении, она лечится через
запись в файле [[~/.ssh/config]] типа такой:
: Host 123.45.67.89
:      	  IdentitiesOnly=yes
:         IdentityFile ~/.ssh/my-secret-key_rsa
:         Port 22
:         User my-user-name

Осталось этот файлик подцепить Emacs'ом. Попробуем это сделать, как
показано в официальной документации [[https://www.gnu.org/software/tramp/#SEC_Contents][TRAMP 2.6.1 User Manual]].

#+begin_src emacs-lisp :tangle yes
(tramp-set-completion-function "ssh"
                               '((tramp-parse-sconfig "/etc/ssh/ssh_config")
                                 (tramp-parse-sconfig "~/.ssh/config")))
#+end_src

* Инструменты внешние

** Treemacs

Дерево проектов. Полезная штука для анализа незнакомого кода. Немного глючит, но
со временем выравнивается.

#+begin_src emacs-lisp :tangle yes
(use-package treemacs
    :ensure t)
(use-package treemacs-projectile
    :ensure t)
#+end_src

Горячие клавиши для вызова дерева проектов.  Добавим переход в окно
treemacs при показе текущего файла в дереве проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/treemacs-find-file-and-select-tree-window ()
    (interactive)
    (treemacs-find-file)
    (treemacs-select-window))

(my/leader-def nil 'override
    "o p" #'treemacs
    "o P" #'my/treemacs-find-file-and-select-tree-window
    "o w" #'treemacs-add-project-to-workspace)

(my/evil-define-key 'normal 'treemacs-mode-map
    ">" #'treemacs-increase-width
    "<" #'treemacs-decrease-width)
#+end_src

Вызов меню для treemacs.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key 'normal 'treemacs-mode-map
    "?" #'treemacs-common-helpful-hydra)

#+end_src

** Magit

Один из самых лучших и удобных клиентов для Git.

Загрузим необходимые пакеты и определим некоторые базовые клавиши.

#+begin_src emacs-lisp :tangle yes
(provide 'seq-25)
(use-package magit
    :ensure t
    :config
    ;; Define some keys:
    (setq magit-diff-refine-hunk t)
    (my/leader-def nil 'override
                   "g" '(:ignore t :which-key "git")
                   "g g" #'magit-status
                   "g b" #'magit-branch-checkout
                   "g /" #'magit-dispatch))
(use-package magit-gitflow
    :ensure t)
(use-package magit-popup
    :ensure t)
(use-package magit-todos
    :ensure t)
#+end_src

Полная подсветка изменений в ediff-buffers (включая части строк).

#+begin_src emacs-lisp :tangle yes
(setq magit-diff-refine-hunk 'all)
#+end_src

Переход по символьным ссылкам при из открытии сделаем по-умолчанию
(хоть это и VC, а не Magit).

#+begin_src emacs-lisp :tangle yes
(setq vc-follow-symlinks t)
#+end_src

Запилим горячие клавиши на полезные операции. Итак:

Горячие клавиши для лога текущей ветки.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g u" #'magit-log-head)
#+end_src

Горячие клавиши для лога файла в активном буфере.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g h" #'magit-log-buffer-file)
#+end_src

Горячие клавиши для просмотра логов от git-команд.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g p" #'magit-process-buffer)
(my/leader-def 'normal 'magit-diff-mode-map
    "g p" #'magit-process-buffer)
#+end_src

Горячие клавиши для выкачки информации по всем веткам (magit-fetch-all).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g a" #'magit-fetch-all)
#+end_src

Блеймер (подробный)

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g B" #'magit-blame-addition)
#+end_src

Не блеймер и не Magit, но смысл тот же. Показываем информацию по
каждой строке в отдельном буфере (=vc-annotate=).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g n" #'vc-annotate)
#+end_src

Клавиши с цифрами из ~magit-...-mode~ мешают Evil, к тому же имеют дубль с
Alt. Отменим их, а заодно освободим клавиши движения "h", "j", "k" и "l".

#+begin_src emacs-lisp :tangle yes
(defun my/magit--restore-evil-keys (mode-map)
    (mapc (lambda (key)
              (define-key mode-map (kbd key) nil))
          '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"
            "$"
            "h" "j" "k" "l")))

(when my/evil
    (mapc 'my/magit--restore-evil-keys
          (list magit-blame-mode-map
                magit-blame-read-only-mode-map
                magit-blob-mode-map
                magit-cherry-mode-map
                magit-diff-mode-map
                magit-gitflow-mode-map
                magit-log-mode-map
                magit-log-select-mode-map
                magit-merge-preview-mode-map
                magit-mode-map
                magit-popup-help-mode-map
                magit-popup-mode-map
                magit-process-mode-map
                magit-reflog-mode-map
                magit-refs-mode-map
                magit-repolist-mode-map
                magit-revision-mode-map
                magit-section-mode-map
                magit-stashes-mode-map
                magit-stash-mode-map
                magit-status-mode-map
                magit-submodule-list-mode-map
                magit-todos-list-mode-map
                )))
#+end_src

** Git-timemachine

Пакет позволяет листать открытый файл по ревизиям.

#+begin_src emacs-lisp :tangle yes
(use-package git-timemachine
    :ensure t)
#+end_src

Горячие клавиши. Из них предопределены:
- Ctrl-k - git-timemachine-show-previous-revision
- Ctrl-j - git-timemachine-show-next-revision
Нужно лишь переключиться в режим через функцию:
: git-timemachine-toggle

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "g t" 'git-timemachine-toggle)
#+end_src

** Подсветка разницы с HEAD в каждой строке (git-gutter)

Метки строк по состоянию в Git добавим через пакет =Git-gutter=.

#+begin_src emacs-lisp :tangle yes
(use-package git-gutter-fringe
	  :ensure t
	  :config
	  ;; (global-git-gutter-mode t)
      (setq git-gutter:update-interval 1))
#+end_src

Костыльнем выключение git-gutter-mode для бинарных файлов, иначе он
замучает вопросами про кодировку.

#+begin_src emacs-lisp :tangle yes
(add-hook 'find-file-hook
          (lambda ()
              (unless (my/--is-current-buffer-binary)
                  (git-gutter-mode 1))))

(defun my/--is-current-buffer-binary ()
    (when-let (name (buffer-name))
        (let ((extension (file-name-extension name)))
            (or (eq major-mode 'image-mode)
                (member extension '("gpg" "pdf"))))))
#+end_src

** Blamer (смотрелка заголовков последних коммитов в коде)

Пример скопирован [[https://github.com/Artawower/blamer.el][отсюда]]. Запомню его тут, чтобы долго не искать.

#+begin_example emacs-lisp :tangle yes
(use-package blamer
  :bind (("s-i" . blamer-show-commit-info))
  :defer 20
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                    :background nil
                    :height 140
                    :italic t)))
  :config
  (global-blamer-mode 1))
#+end_example

Теперь сделаем свою конфигурацию.

#+begin_src emacs-lisp :tangle yes
(use-package blamer
    :ensure t
    :config
    (global-blamer-mode -1))
#+end_src

Посадим на горячие клавиши переключение blamer-mode.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g m" #'blamer-mode)
#+end_src

** Docker

Установка пакетов для работы с docker.

#+begin_src emacs-lisp :tangle yes
(use-package docker
    :ensure t)
;; (use-package docker-tramp  ;; Obsolete.
;;     :ensure t)
(require 'tramp-container)
(use-package dockerfile-mode
    :ensure t)
#+end_src

Горячие клавиши для работы с docker. Тут хватает только вызова
основной функции, а далее по меню все понятно.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o D" #'docker)
#+end_src

** Календарь, как его представление

Включение модуля "calendar" позволяет смотреть свои дела из Agenda в виде календаря.

#+begin_src emacs-lisp :tangle yes
(use-package calfw
	:ensure t
	:config
	(setq cfw:face-item-separator-color nil
		  cfw:render-line-breaker 'cfw:render-line-breaker-none
		  cfw:fchar-junction ?╋
		  cfw:fchar-vertical-line ?┃
		  cfw:fchar-horizontal-line ?━
		  cfw:fchar-left-junction ?┣
		  cfw:fchar-right-junction ?┫
		  cfw:fchar-top-junction ?┯
		  cfw:fchar-top-left-corner ?┏
		  cfw:fchar-top-right-corner ?┓))

(use-package calfw-org
	:ensure t)
(use-package calfw-cal
	:ensure t
	:commands (cfw:cal-create-source))

(use-package calfw-ical
	:ensure t
	:commands (cfw:ical-create-source))

;; (use-package org-gcal
;; 	:defer t)
#+end_src

Отключим показ ненужных праздников:

#+begin_src emacs-lisp :tangle yes
(setq cfw:display-calendar-holidays nil)
#+end_src

Ниже запилим сочетания клавиш.

Вызов буфера с cfw-календарем:

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o a c" #'cfw:open-org-calendar)
#+end_src

Вызов Agenda для выбранного дня:

#+begin_src emacs-lisp :tangle yes
(define-key cfw:calendar-mode-map "d" #'cfw:org-open-agenda-day)
#+end_src

Как и для агенды, отдельно сделаем календарь на задачи в открытом
файле.

#+begin_src emacs-lisp :tangle yes
(defun my/cfw:open-org-calendar-current-file ()
    (interactive)
    (let ((org-agenda-files (list (buffer-file-name))))
        (cfw:open-org-calendar)))

(my/leader-def nil 'override
               "o a C" '(my/cfw:open-org-calendar-current-file :which-key "Calendar for current file"))
#+end_src

** COMMENT Litable

Живой emacs-lisp. Что-то вроде live-py-mode для Python.
В emacs-lisp буфере вызываем =(litable-mode)= и работаем.

#+begin_src emacs-lisp :tangle yes
(use-package litable
    :ensure t)
#+end_src

** Tldr. Примеры запуска утилит из командной строки

Пакет дает примеры запуска программ. Спасает от долгих исследований
man-страниц.

Полезные команды:
- =tldr= - выводит примеры для указанной утилиты.
- =tldr-update-docs= - обновление документации по утилитам.

#+begin_src emacs-lisp :tangle yes
(use-package tldr
    :ensure t)
#+end_src

* Инструменты свои

** Словарик под StarDict

Как установить словарик с нуля?

1. Установить утилиту sdcv:
   : sudo pacman -S sdcv
2. В Emacs добавить два пакета:
   - sdcv
   - posframe
3. Скачать словари из http://download.huzheng.org/dict.org/ .

Установим необходимые пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package sdcv
    :ensure t)
(use-package posframe
    :ensure t)
#+end_src

Общий путь, где лежит словарик.

#+begin_src emacs-lisp :tangle yes
(setq my/sdcv-path (file-name-concat my/config-dir "/dictionaries/Lingvo-stardict"))
#+end_src

Чтобы утилита sdcv видела словари, выставим к ним путь в переменную среды.

#+begin_src emacs-lisp :tangle yes
(setenv "STARDICT_DATA_DIR" my/sdcv-path)
(require 'sdcv)
(setq sdcv-dictionary-data-dir my/sdcv-path)
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "s g" '(sdcv-search-input :which-key "Dictionary search word by input")
    "s w" '(sdcv-search-pointer :which-key "Dictionary search at point"))
#+end_src

** Калькулятор на Python

Из удобств установлен пакетик =live-py-mode=. Установим его.

#+begin_src emacs-lisp :tangle yes
(use-package live-py-mode
    :ensure t)
#+end_src

При запуске =M-x live-py-mode= в открытом py-файле (ассоциация буфера
с файлом - это важно, при этом сам файл на диске может и
отсутствовать) окошко делится пополам, и в правом окне видим
результаты python-выражений из левого окна. Получился такой удобный
python-калькулятор (и не только).

Запилим функцию для быстрого создания калькулятора из всего
вышесказанного.

Ниже имя файла для буфера с 'калькулятором' и имя фрейма для него.

#+begin_src emacs-lisp :tangle yes
(setq my/calculator-python-filename "_calculator-python.py"
      my/calculator-python-framename "*-calculator-python-*")

(defun my/calculator--get-python-filename ()
    (let ((filename (file-name-concat (temporary-file-directory)
                                      "/" my/calculator-python-filename)))
        (string-replace "//" "/" filename)))
#+end_src

Позаботимся о вставке выделенного текста в буфер 'калькулятора'.

#+begin_src emacs-lisp :tangle yes
(defun my/get-selection-and-deselect ()
    "Return selected text in current buffer or empty string."
    (if (region-active-p)
            (let ((selection (buffer-substring-no-properties (region-beginning) (region-end))))
                (deactivate-mark)
                selection)
        ""))
#+end_src

'Калькулятор' создается в отдельном фрейме.  Если перед этим в
активном буфере был выделен текст, то этот текст будет добавлен в
буфер 'калькулятора'.  Результат кода ниже - функция, которая
открывает или закрывает фрейм с калькулятором (если тот был открыт).

#+begin_src emacs-lisp :tangle yes
(defun my/calculator-python-open (&optional frame)
    "Open a frame with 'calulator' on live-py-mode."
    (interactive)
    (let* ((selection (my/get-selection-and-deselect))
           (buffer (find-file-noselect (my/calculator--get-python-filename)))
           (frame (or frame (make-frame))))
        (select-frame-set-input-focus frame)
        (set-frame-name my/calculator-python-framename)
        (switch-to-buffer buffer)
        (live-py-mode)
        (when (not (string-empty-p selection))
            (goto-char (point-max))
            (if (> (point-max) 1)
                    (progn (insert "\n\n")
                           (save-excursion (insert "# -----\n")
                                           (insert selection)))
                (save-excursion (insert selection))))
        (set-buffer-modified-p nil)))

(defun my/calculator-python-close (frame)
    "Delete the frame. Raise calculator buffer and set it to unmodified."
    (select-frame-set-input-focus frame)
    (switch-to-buffer my/calculator-python-filename)
    (live-py-mode -1)
    (set-buffer-modified-p nil)
    (let ((text (buffer-string)))
        (delete-frame nil t)
        (with-current-buffer (find-file-noselect (my/calculator--get-python-filename))
            (erase-buffer)
            (insert text)
            (set-buffer-modified-p nil))))

(defun my/calculator-python-toggle ()
    "Open or close frame with 'calulator' on live-py-mode."
    (interactive)
    (let ((frame (my/get-frame-by-name my/calculator-python-framename)))
        (if frame
                (my/calculator-python-close frame)
            (my/calculator-python-open))))
#+end_src

Горячие клавиши для python-калькулятора.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o c" '(my/calculator-python-toggle :which-key "Calculator live on Python"))
#+end_src

* Сценарии для emacsclient
  :PROPERTIES:
  :ID:       cc0595b8-0628-4bd8-b398-ddfc80b95a01
  :END:

Здесь собраны сценарии, которые удобно вызвать по желанию на старте
emacsclient.

Вешаем в системе на горячие клавиши команду типа этой и пользуемся:
: emacsclient -a "" -c -e '(my/emacsclient-<одна-из-функций-ниже>)' -s notes

** Вызов словарика

Покажем окно со словарем и приглашением к вводу слова.  Если в
системном буфере обмена был какой-то текст, то он будет подставлен в
словарь.

#+begin_src emacs-lisp :tangle yes
(defun my/emacsclient-dictionary ()
    (interactive)
    (my/prepare-windows-in-new-frame 'charge)
    (let* ((name "Dictionary")
           (register+ (or (evil-get-register ?+ t) ""))
           (register* (or (evil-get-register ?* t) ""))
           (text "hello"))
        (setq register+ (if (string-empty-p register+) nil register+)
              register* (if (string-empty-p register*) nil register*)
              text (or register* register+ text))
        (my/set-title-bar-and-workspace-interactive name)
        (sdcv-search-input text)
        (switch-to-buffer "*SDCV*")
        (delete-other-windows)))
#+end_src

** Список закладок

Показывается окно со списком закладок. Можно использовать как быстрый
доступ к информации.

#+begin_src emacs-lisp :tangle yes
(defun my/emacsclient-bookmarks ()
    (interactive)
    (my/prepare-windows-in-new-frame 'charge)
    (let* ((name "Bookmarks"))
        (my/set-title-bar-and-workspace-interactive name)
        (call-interactively 'bookmark-bmenu-list)
        (switch-to-buffer "*Bookmark List*")
        (call-interactively 'bookmark-jump)))
#+end_src

** Вызов живого калькулятора на Python

#+begin_src emacs-lisp :tangle yes
(defun my/emacsclient-calculator ()
    (interactive)
    (my/prepare-windows-in-new-frame 'charge)
    (let* ((name "Calculator"))
        (my/set-title-bar-and-workspace-interactive name)
        (my/calculator-python-open (selected-frame))))
#+end_src

* Панель на старте с логотипом (dashboard)

** Выбор случайной картинки для стартового логотипа
   :PROPERTIES:
   :ID:       3a0a5684-d453-4d37-bd1a-0a65ae9591ef
   :END:

В репозитории этого конфига есть папочка с картинками. В нее можно добавлять
новые картинки, и на старте Emacs одна из них случайно будет помещена на
логотип. Обозначим эту директорию.

#+begin_src emacs-lisp :tangle yes
(setq my/dashboard-banner-dir (file-name-concat my/config-dir "/banners"))
#+end_src

Теперь напишем функцию выбора случайной картинки.

#+begin_src emacs-lisp :tangle yes
(defun my/select-random-banner ()
    (let* ((pictures (directory-files my/dashboard-banner-dir nil ".png"))
           (pictures-sorted (sort pictures #'string-lessp))
           (filename (nth (random (length pictures))
                          pictures-sorted)))
        (file-name-concat my/dashboard-banner-dir "/" filename)))
#+end_src

А чтобы на старте редактора случайность не вела себя странно,
проинициализируем датчик случайных чисел текущим временем.

#+begin_src emacs-lisp :tangle yes
(cl-make-random-state)
#+end_src

** Настройка панели

Заменим начальный экран более модной панелью.
Картинку логотипа [[id:3a0a5684-d453-4d37-bd1a-0a65ae9591ef][выберем случайно]].

#+begin_src emacs-lisp :tangle yes
(use-package dashboard
    :ensure t
    :config
    (setq dashboard-center-content t
          dashboard-startup-banner (my/select-random-banner)
          initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    (dashboard-setup-startup-hook))
#+end_src

Определим, какие секции будут видны на начальном экране.  Из них могли
бы быть агенда, ранее открытые файлы и проекты.  Но пусть там не будет
ничего, лишь картинка и приветствие. :)

#+begin_src emacs-lisp :tangle yes
(setq dashboard-items nil)
;; (setq dashboard-items '((projects . 6)
;;                         (recents .  6)))
#+end_src

Приветствие. Здесь, подобно Doom, повесим подсказку по клавишам.

#+begin_src emacs-lisp :tangle yes
(defun my/get-function-key (func-symbol)
    (if-let ((key (where-is-internal func-symbol nil t)))
        (string-replace "<moniton-state>" ""
                        (key-description key))
        ""))

(setq dashboard-banner-logo-title
      (concat "\n\n"
              "                  Welcome to Emacs!"
              "\n\n\n"
              (format "Open file                                  %s\n"
                      (my/get-function-key 'counsel-find-file))
              (format "Recent file                                %s\n"
                      (my/get-function-key 'counsel-recentf))
              "\n"
              (format "Open project                               %s\n"
                      (my/get-function-key 'projectile-switch-project))
              (format "Open project with workspace                %s\n"
                      (my/get-function-key 'my/switch-project-with-workspace-safe-title))
              "\n"
              (format "Switch workspace                           %s\n"
                      (my/get-function-key 'my/persp-frame-switch))
              (format "Switch workspace in new frame              %s\n"
                      (my/get-function-key 'my/make-frame-and-switch-perpective))
              "\n"
              (format "Change frame title                         %s\n"
                      (my/get-function-key 'my/set-title-bar-interactive))
              (format "Change frame title with workspace          %s\n"
                      (my/get-function-key 'my/set-title-bar-and-workspace-interactive))
              ))
#+end_src

* LLM. Всевозможные клиенты

** Чтение ключей из gpg-файлов

Ключи можно положить в gpg-файлы и читать их оттуда. Ниже функция для
чтения текста (ключа) из gpg-файла.

#+begin_src emacs-lisp :tangle yes
(defun my/llm-read-api-key (api-key filename)
    (if (and api-key
             (stringp api-key)
             (not (string-empty-p api-key)))
        api-key
        (my/llm-read-gpg-file filename)))

(defun my/llm-read-gpg-file (filename)
    (when (and (string-equal "gpg" (file-name-extension filename))
               (file-exists-p filename))
        (with-temp-buffer
            (insert-file-contents filename)
            (string-trim (buffer-string)))))
#+end_src

** Общие клавиши

Меню для работы с LLM'ками.

 #+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "l" '(:ignore t :which-key "LLM"))
 #+end_src

** Ollama-buddy (клиент для Ollama)

Клиент для Ollama. Сервер для Ollama при этом должен быть
запущен. Через docker это можно сделать так:
: docker pull ollama/ollama
: docker run -d --restart always -v ~/.ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama
Или установив ollama локально, запустить командой:
: ollama serve

Ссылка на докер с соответствующей информацией:
- https://hub.docker.com/r/ollama/ollama

Сокращенная подсказка на старте:
| Действие                           | Родные  | Свои                   |
|------------------------------------+---------+------------------------|
| Ask me anything!                   | C-c C-c | M-RET                  |
| Change model                       | C-c m   | SPC l o m m            |
| Cancel request                     | C-c k   | SPC l o k, SPC l o m k |
| Browse prompt history              | M-p/M-n |                        |
| Advanced interface (show all tips) | C-c A   | SPC l o A              |

Полная подсказка:
| Действие                            | Родные                | Свои                   |
|-------------------------------------+-----------------------+------------------------|
| Ask me anything!                    | C-c C-c               | M-RET                  |
| Show Help/Token-usage/System-prompt | C-c h/U/C-s           | SPC l o v h/U/S        |
| Model Change/Info/Cancel            | C-c m/i/k             | SPC l o m m/i/k        |
| Cancel request                      | C-c k                 | SPC l o k, SPC l o m k |
| Prompt history                      | M-p/M-n               |                        |
| Session New/Load/Save/List/Delete   | C-c N/L/S/Q/Z         | SPC l o s N/L/S/Q/Z    |
| History Toggle/Clear/Show/Edit      | C-c H/X/V/E           | SCP l o h H/X/V/E      |
| Prompt to multiple models           | C-c M                 | SPC l o M              |
| Parameter Edit/Show/Help/Reset      | C-c P/G/I/K           | SPC l o p P/G/I/K      |
| System Prompt/Clear                 | C-u/+C-u +C-u C-c C-c | SPC l o y p/c          |
| Toggle JSON/Token/Params/Format     | C-c D/T/F/C-o         | SPC l o t D/T/F/O      |
| Basic interface (simpler display)   | C-c A                 | SPC l o A              |

Устанавливаем клиента.

#+begin_src emacs-lisp :tangle yes
(use-package ollama-buddy
    :ensure t)
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "l o" '(:ignore t :which-key "Ollama Buddy")
               "l o o" '(ollama-buddy-menu :which-key "Ollama Menu")
               "l o O" '(ollama-buddy-transient-menu :which-key "Ollama Transient menu"))
(my/leader-def nil 'ollama-buddy-mode-map
               "l o A" '(ollama-buddy-toggle-interface-level
                       :which-key "Toggle interface (basic/advance)")
               "l o M" '(ollama-buddy--multishot-prompt
                       :which-key "Prompt to multiple models")
               "l o v" '(:ignore t :which-key "Show")
               "l o v h" '(ollama-buddy--menu-help-assistant :which-key "Help")
               "l o v U" '(ollama-buddy-display-token-stats :which-key "Token-usage")
               "l o v S" '(ollama-buddy-show-system-prompt :which-key "System-prompt")
               "l o m" '(:ignore t :which-key "Model")
               "l o m m" '(ollama-buddy--swap-model :which-key "Change model")
               "l o m k" '(ollama-buddy--cancel-request :which-key "Cancel request")
               "l o k" '(ollama-buddy--cancel-request :which-key "Cancel request")
               "l o s" '(:ignore t :which-key "Session")
               "l o s N" '(ollama-buddy-sessions-new :which-key "New")
               "l o s L" '(ollama-buddy-sessions-load :which-key "Load")
               "l o s S" '(ollama-buddy-sessions-save :which-key "Save")
               "l o s Q" '(ollama-buddy-sessions-list :which-key "List")
               "l o s Z" '(ollama-buddy-sessions-delete :which-key "Delete")
               "l o h" '(:ignore t :which-key "History")
               "l o h H" '(ollama-buddy-toggle-history :which-key "Toggle")
               "l o h X" '(ollama-buddy-clear-history :which-key "Clear")
               "l o h V" '(ollama-buddy-display-history :which-key "Show")
               "l o h E" '(ollama-buddy-history-edit :which-key "Edit")
               "l o p" '(:ignore t :which-key "Parameter")
               "l o p P" '(my/ollama-buddy-params-edit :which-key "Edit")
               "l o p G" '(ollama-buddy-params-display :which-key "Show")
               "l o p I" '(ollama-buddy-params-help :which-key "Help")
               "l o p K" '(ollama-buddy-params-reset :which-key "Reset")
               "l o y" '(:ignore t :which-key "System")
               "l o y p" '(ollama-buddy-set-system-prompt :which-key "Prompt (set)")
               "l o y c" '(ollama-buddy-reset-system-prompt :which-key "Clear (reset)")
               "l o t" '(:ignore t :which-key "Toggle")
               "l o t D" '(ollama-buddy-toggle-debug-mode :which-key "JSON")
               "l o t T" '(ollama-buddy-toggle-token-display :which-key "Token")
               "l o t F" '(evil-find-char-backward :which-key "Params")
               "l o t O" '(ollama-buddy-toggle-markdown-conversion :which-key "Format"))
(my/evil-define-key nil 'ollama-buddy-mode-map
                    "M-RET" '(ollama-buddy--send-prompt
                              :which-key "Ask me anything!"))

(defun my/ollama-buddy-params-edit ()
    (interactive)
    (call-interactively (keymap-lookup ollama-buddy-mode-map "C-c P")))
#+end_src

** GPTel (простой LLM-клиент для Emacs)

Работает с кучей API от разных LLM'ок, включая и Ollama.

Ссылки на страницы инструментов:
- GitHub: [[https://github.com/karthink/gptel?tab=readme-ov-file#usage][karthink / gptel]]
- GitHub: [[https://github.com/ultronozm/ai-org-chat.el][ultronozm / ai-org-chat.el]]
- GitHub: [[https://github.com/milanglacier/minuet-ai.el][milanglacier / minuet-ai.el]]
- GitHub: [[https://github.com/deepseek-ai/awesome-deepseek-integration?tab=readme-ov-file#table-of-contents][deepseek-ai / awesome-deepseek-integration]]

Устанавливаем пакет и делаем по умолчанию режим org-mode в окне
диалога. В целом, окно диалога и не нужно, достаточно выделить текст и
вызвать ~gptel-send~.

#+begin_src emacs-lisp :tangle yes
(use-package gptel
    :ensure t
    :custom
    (gptel-default-mode 'org-mode))
#+end_src

В дальнейшем использование curl по-умолчанию будет мешать, поэтому
сбросим его. В gptel-mode для моделей, отличных от GigaChat, этот
параметр будет локально восстановлен.

#+begin_src emacs-lisp :tangle yes
(setq gptel-use-curl nil)
#+end_src

Регистрации бекэндов сделаем через функции. Там решим проблему
обновления бекэндов под изменяющиеся среду моделей.

Функция ниже получает имя бекэнда и функцию его создания, принимающую
то же имя бекэнда. Оба аргумента запоминаются для будущего
переиспользования.

#+begin_src emacs-lisp :tangle yes
(setq my/gptel--backends-hash (make-hash-table :test 'equal))

(defun my/gptel--register-backend (backend-name make-backend-func)
    (puthash backend-name make-backend-func my/gptel--backends-hash)
    (funcall make-backend-func backend-name))
#+end_src

Теперь поддержим обновление бекэндов (например, когда меняется
параметр модели или в Ollama добавляется новая модель).

#+begin_src emacs-lisp :tangle yes
(defun my/gptel-refresh-backend (backend-name)
    (interactive (list (ivy-read "Enter backend name: "
                                 (hash-table-keys my/gptel--backends-hash)
                                 :initial-input (gptel-backend-name gptel-backend))))
    (when-let* ((make-backend-func (gethash backend-name my/gptel--backends-hash))
                (backend (funcall make-backend-func backend-name)))
        (when (equal (gptel-backend-name gptel-backend) backend-name)
            (setq gptel-backend backend)
            (setq gptel-model (my/find-symbol-with-same-name
                               gptel-model
                               (gptel-backend-models gptel-backend))))
        (my/gptel-set-curl-mode)))

(defun my/find-symbol-with-same-name (symbol sequence)
    (car (cl-remove-if-not (lambda (x)
                               (equal (symbol-name x) (symbol-name symbol)))
                           sequence)))
#+end_src

Общие настройки запроса в LLM (temperature и т.п.).

#+begin_src emacs-lisp :tangle yes
(defcustom my/gptel-def-request-params '(:temperature 0.1)
  "Default request parameters for LLM models (like temperature):
    key   - :temperature
    value - 0.1"
  :type '(plist
          :key-type (restricted-sexp :match-alternatives 'keywordp
                     :tag "Parameter (:keyword)")
          :value-type (choice integer float string))
  :group 'pgtel)

(defun my/customize-def-request-params ()
    (interactive)
    (customize-option 'my/gptel-def-request-params))
#+end_src

Беседы с LLM'ками удобно сохранять в org-файлах. После можно открыть
файл и продолжить беседу. Чтобы не устанавливать каждый раз руками
gptel-mode, в заголовок файла можно воткнуть команду (gptel-mode) для
автоматического исполнения при открытии. Сделаем функцию вставки
такого заголовка.

#+begin_src emacs-lisp :tangle yes
(defun my/gptel-convert-org-file-to-talk ()
    (interactive)
    (goto-char 0)
    (insert (concat "# Local Variables:" "\n"
                    "# chat-session-id: \"" (my/gptel--session-id) "\"" "\n"
                    "# eval: (gptel-mode)" "\n"
                    "# End:" "\n")))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "l g" '(:ignore t :which-key "GPTel client")
               "l g a" '(gptel-add :which-key "Add region to context")
               "l g D" '(gptel-context-remove-all :which-key "Remove all context")
               "l g e" '(gptel-mode :which-key "GPTel minor mode")
               "l g g" '(gptel :which-key "GPTel buffer")
               "l g G" '(gptel-menu :which-key "Menu")
               "l g k" '(gptel-abort :which-key "Abort request")
               "l g p" '(my/customize-def-request-params :which-key
                         "Set models paramerets")
               "l g r" '(gptel-rewrite :which-key "Rewrite")
               "l g s" '(gptel-send :which-key "Send request")
               "l g u" '(my/gptel-refresh-backend :which-key "Refresh backend"))

(my/leader-def nil 'org-mode-map
               "l g o" '(my/gptel-convert-org-file-to-talk
                         :which-key "GPTel mode header"))
#+end_src

** GPTel. Подключаем DeepSeek

Через customize устанавливаем API ключ DeepSeek в переменную
my/deepseek-api-key.

#+begin_src emacs-lisp :tangle yes
(defcustom my/deepseek-api-key-gpg-file ""
  "GPG-file with DeepSeek API key."
  :type 'file)

(setq my/deepseek-api-key nil)

(defun my/deepseek-get-api-key ()
    (setq my/deepseek-api-key (my/llm-read-api-key my/deepseek-api-key
                                                   my/deepseek-api-key-gpg-file)))

(my/gptel--register-backend "DeepSeek"
                            (lambda (backend-name)
                                (gptel-make-deepseek backend-name
                                    :stream t
                                    :key 'my/deepseek-get-api-key
                                    :request-params my/gptel-def-request-params)))
#+end_src

** GPTel. Подключаем Ollama

#+begin_src emacs-lisp :tangle yes
(defun my/gptel-get-ollama-models-names ()
    (let* ((response-data (my/gptel--get-ollama-models))
           (models-data (alist-get 'models response-data))
           (models-names (mapcar (lambda (model-struc)
                                     (make-symbol (alist-get 'model model-struc)))
                                 models-data)))
        models-names))

(defun my/gptel--get-ollama-models ()
    (condition-case err
        (let* ((url-request-method "GET")
               (url-mime-accept-string "application/json")
               (response-buffer (url-retrieve-synchronously
                                 "http://localhost:11434/api/tags")))
            (if response-buffer
                (with-current-buffer response-buffer
                    (goto-char (point-min))
                    (search-forward "\n\n" nil t)
                    (let ((json-data (json-read)))
                        (kill-buffer response-buffer)
                        json-data))
                nil))
        ('error ;; Обрабатываем любые ошибки
         (message "Error: %s" err)
         nil)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(my/gptel--register-backend "Ollama"
                            (lambda (backend-name)
                                (gptel-make-ollama backend-name
                                    :host "localhost:11434"
                                    :stream t
                                    :models (my/gptel-get-ollama-models-names)
                                    :request-params my/gptel-def-request-params)))
#+end_src

** GPTel. Подключаем GigaChat

*** Материалы (только информация и ссылки)

- Сбер.API :: [[https://developers.sber.ru/studio/login][Личный кабинет]]
  + Здесь можно зарегистрироваться в личном кабинете и создать проект
    GigaChap API.

- Сбер.API :: [[https://developers.sber.ru/docs/ru/gigachat/individuals-quickstart][Быстрый старт для физических лиц]]

- Сбер.API :: [[https://developers.sber.ru/docs/redirect/?uniq_id=gigaOpenApi][REST. Справочная информация в формате Yaml]]

- Сбер.API :: [[https://developers.sber.ru/docs/redirect/?uniq_id=gigaRpcProto][gRPC. Справочная информация в формате Yaml]]

- Сбер.API :: [[https://developers.sber.ru/docs/ru/gigachat/models][Документация / Разработчикам / Модели GigaChat]]

- GitHub :: [[https://github.com/ai-forever/gigachain][gigachain]]

- Сбер.API :: [[https://developers.sber.ru/docs/ru/gigachat/quickstart/ind-using-api][Документация / Разработчикам / Начало работы с API]]
  + Здесь можно посмотреть URL'ы для настроек Gtpel.
    #+begin_src shell :eval no :hidden
    curl -L -X POST 'https://gigachat.devices.sberbank.ru/api/v1/chat/completions' \
    -H 'Content-Type: application/json' \
    -H 'Accept: application/json' \
    -H 'Authorization: Bearer <токен_доступа>' \
    --data-raw '{
      "model": "GigaChat",
      "messages": [
        {
          "role": "user",
          "content": "Привет! Как дела?"
        }
      ],
      "stream": false,
      "repetition_penalty": 1
    }'
    #+end_src

*** Получение access token

В отличии от представленных в gptel моделей, GigaChat использует
oauth2. Поэтому перед отправкой запросов в API нужно получить access
token по API ключу.

Будем хранить данные access token в переменной
my/gptel-gigachat-access-token-struct. Она содержит структуру из
JSON-ответа от API.

#+begin_src emacs-lisp :tangle yes
(setq my/gptel-gigachat-access-token-struct nil)
#+end_src

Следующая функция проверяет на валидность структуру access token'а
(наличие и просрочка). Если токен не валиден, он запрашивается в API.

#+begin_src emacs-lisp :tangle yes
(defun my/gptel-gigachat-access-token ()
    (let* ((token-struct my/gptel-gigachat-access-token-struct)
           (now-time (truncate (* 1000.0 (float-time))))
           (expires-at (alist-get 'expires_at token-struct 0))
           (valid-p (> expires-at now-time)))
        (unless valid-p
            (setq my/gptel-gigachat-access-token-struct
                  (my/gptel--get-oauth-token-sync)))
        (alist-get 'access_token my/gptel-gigachat-access-token-struct)))
#+end_src

Вспомогательная функция. Получает access token из API и время его
работы.

#+begin_src emacs-lisp :tangle yes
(defun my/gptel--get-oauth-token-sync ()
    (let* ((url-request-method "POST")
           (url-request-extra-headers
            `(("Content-Type" . "application/x-www-form-urlencoded")
              ("Accept" . "application/json")
              ("RqUID" . ,(org-id-uuid))
              ("Authorization" . ,(concat "Basic "
                                          (my/gigachat-get-api-key)))))
           (url-request-data "scope=GIGACHAT_API_PERS")
           (response-buffer (url-retrieve-synchronously
                             "https://ngw.devices.sberbank.ru:9443/api/v2/oauth")))
        (with-current-buffer response-buffer
            (goto-char (point-min))
            (search-forward "\n\n" nil t)
            (let ((json-data (json-read)))
                (kill-buffer response-buffer)
                json-data))))
#+end_src

Обеспечим кеширование токенов. В API GigaChat'а оно задается через
передачу идентификатора сессии в заголовке запроса X-Session-ID. В
Emacs это удобно - можно хранить идентификаторы сессий в локальных
переменных буферов: одни буфер - одна сессия.

Функция ниже генерирует session-id (при отсутствии) и записывает его в
локальные переменные текущего буфера. Идентификатор возвращает.

#+begin_src emacs-lisp :tangle yes
(defun my/gptel--session-id ()
    (unless (boundp 'chat-session-id)
        (setq-local chat-session-id (org-id-uuid)))
    chat-session-id)
#+end_src

*** Настройки

Будем хранить API key для GigaChat в GPG-файле, путь к которому
зададим в custom-переменной =my/gigachat-api-key-gpg-file=.

При первом успешном чтении файла его содержимое поместим в переменную
my/gigachat-api-key и больше трогать файл не будем.

#+begin_src emacs-lisp :tangle yes
(defcustom my/gigachat-api-key-gpg-file ""
  "GPG-file with GigaChat API key."
  :type 'file)

(setq my/gigachat-api-key nil)

(defun my/gigachat-get-api-key ()
    (setq my/gigachat-api-key (my/llm-read-api-key my/gigachat-api-key
                                                   my/gigachat-api-key-gpg-file)))
#+end_src

Создаем структуру под GigaChat. Сделано по образцу кода из пакета
gptel.

#+begin_src emacs-lisp :tangle yes
(cl-defstruct (gptel-gigachat (:include gptel-openai)
                              (:copier nil)
                              (:constructor gptel--make-gigachat)))
#+end_src

Подготавливаем функцию инициализации модели по аналогии с
gptel-make-deepseek.

#+begin_src emacs-lisp :tangle yes
(cl-defun gptel-make-gigachat
    (name &key curl-args stream key request-params
            (header (lambda () (when-let* ((key (gptel--get-api-key)))
                                   `(("Authorization" . ,(concat "Bearer " key))
                                     ("X-Session-ID" . ,(my/gptel--session-id))
                                     ("Content-Type" . "application/json")
                                     ("Accept" . "application/json")))))
            (host "gigachat.devices.sberbank.ru")
            (protocol "https")
            (endpoint "/api/v1/chat/completions")
            (models '((GigaChat-2-Max
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Max
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-2
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-2-Max-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-2-Pro
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-2-Pro-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-2-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Max
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Max-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Plus
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Plus-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Pro
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-Pro-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19)
                      (GigaChat-preview
                       :capabilities (tool reasoning)
                       :context-window 64
                       :input-cost 0.55
                       :output-cost 2.19))))
    "Register a GigaChat backend for gptel with NAME"
    (declare (indent 1))
    (let ((backend (gptel--make-gigachat
                    :name name
                    :host host
                    :header header
                    :key key
                    :models (gptel--process-models models)
                    :protocol protocol
                    :endpoint endpoint
                    :stream stream
                    :request-params request-params
                    :curl-args curl-args
                    :url (if protocol
                             (concat protocol "://" host endpoint)
                             (concat host endpoint)))))
        (prog1 backend
            (setf (alist-get name gptel--known-backends
                             nil nil #'equal)
                  backend))))
#+end_src

Регистрируем модель GigaChat'а. Функция выдачи ключа для запросов -
my/gptel-gigachat-access-token.

#+begin_src emacs-lisp :tangle yes
(defun my/gptel--register-backend-gigachat (backend-name)
    (my/gptel--register-backend
     backend-name
     (lambda (backend-name)
         (gptel-make-gigachat
             backend-name
             :stream t
             :key 'my/gptel-gigachat-access-token
             :request-params my/gptel-def-request-params))))

(setq gptel-model 'GigaChat-2-Max
      gptel-log-level 'info  ;; 'debug
      gptel-backend (my/gptel--register-backend-gigachat "GigaChat"))
#+end_src

Мне не удалось посылать через GPTel запросы в GigaChat через curl. Но
без curl не работает стриминг ответа в буфере. Поэтому запретим
пользоваться curl'ом только для буферов с GigaChat.

#+begin_src emacs-lisp :tangle yes
(defun my/gptel-set-curl-mode ()
    (setq-local gptel-use-curl (not (equal "GigaChat"
                                           (gptel-backend-name gptel-backend)))))

(add-hook 'gptel-mode-hook 'my/gptel-set-curl-mode)
#+end_src

** Работа с кодом (автодополнение, оптимизация и прочее)

Это попытка поставить на службу LLM в качестве работы с кодом. Не
сложилось пока с copilot, minuet и прочими.

*** Буфер для результатов работы с кодом

Будем выделять в произвольном буфере код, после чего вызывать функцию
из набора ниже. Результат будем отображать в org-буфере слева. Выберем
имя для этого буфера и определим функцию для его показа.

#+begin_src emacs-lisp :tangle yes
(defvar my/llm-codework-out-buffer "*CodeCompletion*"
  "Buffer for code LLM results.")

(setq my/llm-codework-out-buffer-file
      (expand-file-name
       (file-name-concat user-emacs-directory
                         ".cache"
                         (concat (if-let ((daemon (daemonp)))
                                     (concat daemon "-")
                                     "")
                                 "code-completion.org"))))

(defun my/llm-codework-toggle-out-buffer ()
    (interactive)
    (if-let ((window (get-buffer-window my/llm-codework-out-buffer)))
        (delete-window window)
        (my/llm-codework-switch-to-out-buffer my/llm-codework-out-buffer)))

(defun my/llm-codework-switch-to-out-buffer (out-buffer)
    (let* ((created-p (get-buffer out-buffer))
           (buffer (get-buffer-create out-buffer)))
        (switch-to-buffer-other-window buffer)
        (unless created-p
            (setq-local buffer-auto-save-file-name my/llm-codework-out-buffer-file)
            (org-mode))))
#+end_src

Подготовим буфер к дальнейшему диалогу с ИИ. Для этого в промпт
положим все до родительского заголовка первого уровня. Реплики будут
строиться по заголовкам второго уровня (заголовок - вопрос,
содержимое - ответ). Последний заголовок вместе с содержимым будет
считаться одним вопросом.

Содержимое промпта оформим в виде диалога user-assistant. Функция ниже
возвращает такой диалог для дальнейшей передачи в =gptel-requiest=.

#+begin_src emacs-lisp :tangle yes
(defun my/llm-codework-out-buffer--make-theme-prompts ()
    (save-excursion
        (when (my/llm-codework-out-buffer--find-theme-paragraph)
            (let ((prompts ()))
                (my/llm-codework-out-buffer--map-children
                 (lambda (last-p)
                     (setq prompts (my/llm-codework-out-buffer--append-replica
                                    prompts
                                    last-p))))
                prompts))))

(defun my/llm-codework-out-buffer--find-theme-paragraph ()
    (org-back-to-heading-or-point-min)
    (while (and (org-current-level)
                (< 1 (org-current-level)))
        (org-up-heading-safe))
    (org-current-level))

(defun my/llm-codework-out-buffer--map-children (func)
    (when (org-goto-first-child)
        (funcall func (my/llm-codework-out-buffer--last-in-theme-p))
        (while (org-goto-sibling)
            (funcall func (my/llm-codework-out-buffer--last-in-theme-p)))))

(defun my/llm-codework-out-buffer--last-in-theme-p ()
    (save-excursion
        (not (org-goto-sibling))))

(defun my/llm-codework-out-buffer--get-type ()
    (when-let* ((header (org-get-heading))
                (level (org-current-level)))
        (cond ((not (equal level 2))
               nil)
              ((string= header "Source")
               'source)
              ((string= header "Answer")
               'answer)
              (t
               'any))))

(defun my/llm-codework-out-buffer--append-replica (prompts last-p)
    (let* ((type (my/llm-codework-out-buffer--get-type))
           (header (org-get-heading))
           (body (my/llm-codework-out-buffer--get-entry-text)))
        (pcase type
            ('source
             (setq prompts (append prompts (list body
                                                 nil))))
            ('answer
             (setq prompts (append prompts (list nil
                                                 body))))
            ('any
             (if last-p
                 (setq prompts (append prompts (list (concat header "\n\n" body)
                                                     nil)))
                 (setq prompts (append prompts (list header nil
                                                     nil body)))))))
    prompts)

(defun my/llm-codework-out-buffer--goto-end-of-theme ()
    (when (my/llm-codework-out-buffer--find-theme-paragraph)
        (let* ((element (org-element-at-point))
               (begin (org-element-property :contents-begin element))
               (end (org-element-property :contents-end element)))
            (goto-char end)
            end)))

(defun my/llm-codework-out-buffer--get-entry-text ()
    (when (org-at-heading-p)
        (let* ((element (org-element-at-point))
               (content (org-element-property :contents-begin element))
               (end (org-element-property :contents-end element)))
            (if (and content end)
                (buffer-substring-no-properties content end)
                ""))))
#+end_src

*** Функции работы с кодом

Для начала постоим системный промпт под работу с кодом.

#+begin_src emacs-lisp :tangle yes
(defcustom my/llm-codework-system
  "You are a large language model and a careful programmer. Provide code and only code as output without any additional text, prompt or note. All headers must be third level. In code safe orgignal indentation."
  "System prompt for change code."
  :type 'string)
#+end_src

Язык кода будем вытаскивать из названия major-mode буфера.

#+begin_src emacs-lisp :tangle yes
(defun my/get-lang ()
    (let ((lang (car (string-split (symbol-name major-mode) "-"))))
        (cond
          ((string= lang "emacs")
           "emacs-lisp")
          ((string= lang "org")
           "emacs-lisp")
          (t
           lang))))
#+end_src

Ниже находятся интерактивные функции для
- продолжения выделенного кода,
- вариантов продолжения выделенного кода,
- оптимизации выделенного кода,
- пояснения выделенного кода.

#+begin_src emacs-lisp :tangle yes
(defun my/llm-codework-complete ()
    (interactive)
    (let* ((lang (my/get-lang))
           (prompt "")
           (system (format "Complete or finish the following code written in %s that starts after the =<src_code_block>= tag and ends before the =</src_code_block>= tag. Do not modify or add comments to the original code. Use only objects and variables present in the source code; do not invent new ones. If you need more context to complete the task, request additional preceding code. Include both the original and completed code in your response."
                           lang)))
           ;; (system (format "Дополни или заверши приведенный ниже код на %s, который начинается после тега <src_code_block> и завершается перед тегом </src_code_block>. Исходный код не исправляй и не дополняй комментариями. В ответе используй только те объекты и переменные, которые есть в исходном коде, других не придумывай. Если для выполнения задачи тебе не хватает контекста, то ответом запроси нужный тебе предшествующий код. Результат приведи вместе с исходным кодом."
           ;;                 lang)))
        (my/llm-codework-base (format "(%s) Completion of Code" lang)
                              system
                              prompt)))

(defun my/llm-codework-completion-variants ()
    (interactive)
    (let* ((lang (my/get-lang))
           (prompt "")
           (system (format "Complete or finish the provided code snippet below written in %s which begins after the =<src_code_block>= tag and ends before the =</src_code_block>= tag. Do not correct or comment on the existing code. In your answer, use only those objects and variables already present in the given code—do not introduce any others. Present your result along with the original code. Provide 1-5 different versions of the solution and number them accordingly."
                           lang)))
        ;; (system (format "Дополни или заверши приведенный ниже код на %s, который начинается после тега <src_code_block> и завершается перед тегом </src_code_block>. Исходный код не исправляй и не дополняй комментариями. В ответе используй только те объекты и переменные, которые есть в исходном коде, других не придумывай. Результат приведи вместе с исходным кодом. Сделай таким образом от одного до пяти вариантов ответа и пронумеруй их."
        ;;                 lang)))
        (my/llm-codework-base (format "(%s) Completion Variants of Code" lang)
                              system
                              prompt)))

(defun my/llm-codework-optimize ()
    (interactive)
    (let* ((lang (my/get-lang))
           (prompt "")
           (system (format "Optimize the following %s code, starting from the =<src_code_block>= tag and ending at the =</src_code_block>= tag. Below, provide an explanation for your optimization. If no optimization is needed, state this in your response without changing the original code. You may utilize more efficient solutions or libraries. All explanations should be in Russian."
                           lang)))
        ;; (system (format "Оптимизируй код на %s, приведенный ниже, который начинается после тега <src_code_block> и завершается перед тегом </src_code_block>. Ниже приведи объяснение своей оптимизации. Если оптимизации не требуется, сообщи об этом в ответе, а не меняй исходный код. Можешь использовать более эффективные решения или библиотеки. Все пояснения приведи на русском языке."
        ;;                 lang)))
        (my/llm-codework-base (format "(%s) Optimization of Code" lang)
                              system
                              prompt)))

(defun my/llm-codework-explain ()
    (interactive)
    (let* ((lang (my/get-lang))
           (prompt "")
           (system (format "Explain the following %s code, which starts after the =<src_code_block>= tag and ends before the =</src_code_block>= tag. Provide the explanation in Russian."
                           lang)))
        ;; (system (format "Объясни код ниже на %s, который начинается после тега <src_code_block> и завершается перед тегом </src_code_block>. Объяснение дай на русском языке."
        ;;                 lang)))
        (my/llm-codework-base (format "(%s) Explanation of Code" lang)
                              system
                              prompt)))
#+end_src

Для дальнейших уточнений работы ИИ сделаем обработку последующих
вопросов. Вопросы строятся в заголовке второго уровня в буфере
результатов работы ИИ.

#+begin_src emacs-lisp :tangle yes
(defun my/llm-codework-inquire-further ()
    (interactive)
    (when (and (string= (buffer-name) my/llm-codework-out-buffer)
               (org-current-level)
               (equal 2 (org-current-level)))
        (let* ((lang (my/get-lang))
               (system "You are a large language model living in Emacs and a helpful assistant. Respond concisely.")
               (prompts (my/llm-codework-out-buffer--make-theme-prompts)))
            (my/llm-codework-out-buffer--goto-end-of-theme)
            (insert "\n\n\n")
            (goto-line (- (line-number-at-pos) 2))
            (gptel-request
                prompts
                :stream nil
                :system system))))
#+end_src

Помимо функций выше может потребоваться просто поместить выделенный
код с запросом в буфер результатов работы ИИ для дальнейшего его
исследования. Сделаем для этого функцию.

#+begin_src emacs-lisp :tangle yes
(defun my/llm-codework-remember ()
    (interactive)
    (when (use-region-p)
        (let* ((lang (my/get-lang))
               (text (my/llm-codework-get-region-code))
               (prompt (format "Remember code in %s. The code starts with the <src_code_block> tag and ends with the </src_code_block> tag. All explanations give in russian." lang)))
            (my/llm-codework-switch-to-out-buffer my/llm-codework-out-buffer)
            (goto-char (point-max))
            (unless (boundp 'my/header-count)
                (setq-local my/header-count 0))
            (insert (format "\n* %s. (%s) Research code\n\n"
                            (setq-local my/header-count (1+ my/header-count))
                            lang))
            (insert "** Source\n\n")
            (insert (my/llm-codework-make-request prompt text))
            (save-excursion
                (when (re-search-backward "^\\*\\* Source" nil t)
                    (org-cycle)))
            (insert "\n\n** "))))
#+end_src

Далее идут вспомогательные функции к функциям выше. Одна из них делает
запрос к LLM, пользуясь gptel, как бекэндом. Вторая принимает ответ и
размещает его в org-буфере справа.

#+begin_src emacs-lisp :tangle yes
(defun my/llm-codework-base (header system prompt)
    (when (use-region-p)
        (let* ((text (my/llm-codework-get-region-code))
               (request (my/llm-codework-make-request prompt text)))
            (my/llm-codework-switch-to-out-buffer my/llm-codework-out-buffer)
            (gptel-request
                request
                :stream nil
                :system system
                :callback (apply-partially 'my/llm-codework-callback
                                           header
                                           request
                                           my/llm-codework-out-buffer)))))

(defun my/llm-codework-get-region-code ()
    (when (use-region-p)
        (let* ((begin (use-region-beginning))
               (end (use-region-end)))
            (save-excursion
                (goto-char begin)
                (unless (equal begin (line-beginning-position))
                    (when-let ((indent (re-search-backward "^ +" nil t)))
                        (setq begin indent))))
            (string-trim-right (buffer-substring-no-properties begin end)))))

(defun my/llm-codework-make-request (prompt text)
    (concat prompt "\n\n<src_code_block>\n" text "\n</src_code_block>"))

(defun my/llm-codework-callback (header text out-buffer response _info)
    (when (and response
               (not (string-empty-p response)))
        (my/llm-codework-switch-to-out-buffer out-buffer)
        (unless (boundp 'my/header-count)
            (setq-local my/header-count 0))
        (goto-char (point-max))
        (insert (format "\n* %s. %s\n\n"
                        (setq-local my/header-count (1+ my/header-count))
                        (string-trim header)))
        (insert "** Source\n\n")
        (insert (string-trim-right text))
        (save-excursion
            (when (re-search-backward "^\\*\\* Source" nil t)
                (org-cycle)))
        (insert "\n\n** Answer\n\n")
        (insert (gptel--convert-markdown->org response))
        (insert "\n")))
#+end_src

*** Горячие клавиши

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "i" '(:ignore t :which-key "Code AI-changing")
               "i I" '(my/llm-codework-toggle-out-buffer
                       :which-key "Show out buffer")
               "i c" '(my/llm-codework-complete
                       :which-key "Complete code region")
               "i v" '(my/llm-codework-completion-variants
                       :which-key "completion variants of code region")
               "i o" '(my/llm-codework-optimize
                       :which-key "optimize code region")
               "i e" '(my/llm-codework-explain
                       :which-key "explain code region")
               "i r" '(my/llm-codework-remember
                       :which-key "remember code region")
               "i f" '(my/llm-codework-inquire-further
                       :which-key "Inquire further"))
#+end_src

* LSP сервер (vs Eglot)

** Установка

Грузим lsp-mode пакет. Инструкция тут: [[https://emacs-lsp.github.io/lsp-mode/page/installation/][LSP Mode - LSP support for Emacs]].

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
    :ensure t
    :custom
    (lsp-completion-provider :capf)
    (lsp-auto-guess-root nil)
    (lsp-keep-workspace-alive nil)
    )
#+end_src

Исправляем баг с lsp-terraform.

#+begin_src emacs-lisp :tangle yes
(delete 'lsp-terraform lsp-client-packages)
#+end_src

На странице пакета рекомендуют загрузить следующие пакеты:
- [[https://emacs-lsp.github.io/lsp-ui/#intro][lsp-ui]]        - for fancy sideline, popup documentation, VScode-like peek UI, etc.
- [[https://github.com/flycheck/flycheck][flycheck]]      - if you prefer the more popular flycheck over renewed flymake. lsp-mode will automatically pick it up.
- [[https://github.com/company-mode/company-mode][company-mode]]  - /(Installed)/ for completion popups.
- [[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]]  - for various tree based UI controls (symbols, errors overview, call hierarchy, etc.)
- [[https://github.com/emacs-lsp/helm-lsp][helm-lsp]]      - provides on type completion alternative of xref-apropos using helm.
- [[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]]       - provides on type completion alternative of xref-apropos using ivy.
- [[https://emacs-lsp.github.io/dap-mode][dap-mode]]      - if your language is supported by the debugger.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-ui
    :ensure t
    :init
    :config
    (add-hook 'lsp-mode-hook #'lsp-ui-mode)
    (setq lsp-ui-sideline-actions-icon lsp-ui-sideline-actions-icon-default))  ;; Лампочка 💡 в подсказках.
(use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode))
(use-package lsp-treemacs
    :ensure t)
;; (use-package helm-lsp
;;     :ensure t)
(use-package lsp-ivy
    :ensure t)
(use-package dap-mode
    :ensure t)
#+end_src

Отключим проверку на ошибки для emacs-lisp-mode.

#+begin_src emacs-lisp :tangle yes
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
              (flycheck-mode -1)))
#+end_src

** Общие настройки

Важный параметр для ускорения LSP для Haskell, начиная с
Emacs 29. Пишут, что по-умолчанию имеет очень маленькое значение (4к).
Предлагают [[https://emacs-lsp.github.io/lsp-mode/page/performance/][выставить 1Мб]] (действительно работает).

#+begin_src emacs-lisp :tangle yes
(setq read-process-output-max (* 1024 1024))
#+end_src

Информацию по списку LSP-серверов можно посмотреть [[https://emacs-lsp.github.io/lsp-mode/page/languages/][тут]].

Настройка визуальных особенностей LSP-серверов (взято [[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][отюда]]).
Оставлен такой комментарий, но работает и без этого замечания:
#+begin_quote
"Don't forget to set these variables *before* loading lsp-mode, otherwise they won't have effect"
#+end_quote

Symbol highlighting (подсветка имен).

#+begin_src emacs-lisp :tangle yes
(setq lsp-enable-symbol-highlighting t)
#+end_src

lsp-ui-doc - on hover dialogs. (всплывающие подсказки).
- cursor hover (keep mouse hover)
- mouse hover (keep cursor hover)
Здесь запретим самопоказ всплывающих подсказок по клавишным переходам
и оставим для перехода мышью.

Положение поставим верхнее ('top), а если будет не удобно, то можно
сделать рядом с курсором ('at-point).

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-doc-enable t)
(setq lsp-ui-doc-show-with-cursor nil)
(setq lsp-ui-doc-show-with-mouse t)
(setq lsp-ui-doc-position 'top)
#+end_src

Информацию об объекте можно показывать не только через lsp-ui в
сплывающем окне, но и через eldoc в минибуфере. Чтобы информация от
eldoc была полной, выставим соответствующий флажок.

#+begin_src emacs-lisp :tangle yes
(setq lsp-eldoc-render-all t)
#+end_src

Lenses (показ количества ссылок).

#+begin_src emacs-lisp :tangle yes
(setq lsp-lens-enable nil)
#+end_src

Headerline (где находимся - отображение в headline).

#+begin_src emacs-lisp :tangle yes
(setq lsp-headerline-breadcrumb-enable t)
#+end_src

Sideline code actions (действия над кодом (желтые лампочки)).
- whole sideline via
- code actions

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-sideline-enable t)
(setq lsp-ui-sideline-show-code-actions t)
#+end_src

Sideline hover symbols (какая-то информация по коду).
- disable whole sideline via
- hide only hover symbols

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-sideline-enable t)
(setq lsp-ui-sideline-show-hover nil)
#+end_src

Modeline code actions (действия над кодом в строке статуса).

#+begin_src emacs-lisp :tangle yes
(setq lsp-modeline-code-actions-enable t)
#+end_src

Разрешаем или запрещаем проверку на ошибки LSP-сервером.
(Для Python у LSP отвратительная проверка - отменим ее в пользу альтернативной.)

#+begin_src emacs-lisp :tangle yes
(setq lsp-diagnostics-disabled-modes (list 'python-mode))
#+end_src

Еще отменим LSP для imenu - тоже плохо справляется.

#+begin_src emacs-lisp :tangle yes
(setq lsp-enable-imenu nil)
#+end_src

Flycheck (or flymake if no flycheck is present).
Все значения можно найти [[https://emacs-lsp.github.io/lsp-mode/page/settings/diagnostics/][тут]] в этом списке:

: Type: (choice (const :tag Pick flycheck if present and fallback to flymake :auto)
:               (const :tag Pick flycheck :flycheck)
:               (const :tag Pick flymake :flymake)
:               (const :tag Use neither flymake nor lsp :none)
:               (const :tag Prefer flymake t)
:               (const :tag Prefer flycheck nil))

#+begin_src emacs-lisp :tangle yes
(setq lsp-diagnostics-provider :auto)  ;; may be ':auto
;; (setq lsp-diagnostics-provider :flycheck)  ;; may be ':auto
#+end_src

Sideline diagnostics (тексты ошибок).
- disable whole sideline via
- hide only errors

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-sideline-enable t)
(setq lsp-ui-sideline-show-diagnostics t)
#+end_src

# Eldoc (информация по объекту в строке состояния). Пока отключим ее,
# поскольку почти не пользуюсь ей, а выпадашкам от Ivy время от времени
# мешает.
#
# #+begin_src emacs-lisp :tangle yes
# (setq lsp-eldoc-enable-hover nil)
# #+end_src

Modeline diagnostics statistics (показ числа ошибок в строке состояния).

#+begin_src emacs-lisp :tangle yes
(setq lsp-modeline-diagnostics-enable t)
#+end_src

Signature help (показ типа объекта внизу экрана).

#+begin_src emacs-lisp :tangle yes
(setq lsp-signature-auto-activate '(:on-trigger-char :on-server-request))   ;; you could manually request them via `lsp-signature-activate
#+end_src

Signature help documentation (keep the signatures) (показ текста документации по объекту внизу экрана).

#+begin_src emacs-lisp :tangle yes
(setq lsp-signature-render-documentation t)
#+end_src

Completion (company-mode) (автодополнение с выпадашкой).

#+begin_src emacs-lisp :tangle yes
(setq lsp-completion-provider :capf)
#+end_src

Completion item detail (детали в выпадашке автодополнения).

#+begin_src emacs-lisp :tangle yes
(setq lsp-completion-show-detail t)
#+end_src

Completion item kind (тип объекта в выпадашке автодополнения).

#+begin_src emacs-lisp :tangle yes
(setq lsp-completion-show-kind t)
#+end_src

** Клавиши для работы

Повесим всплывающую подсказку на клавишу Enter, а в минибуфере - на "K".
Удаление минибуфера с подсказкой тоже удобно сделать по той же
клавише, что и ее вызов.

#+begin_src emacs-lisp :tangle yes
(defun my/eldoc ()
    (interactive)
    (if-let (eldoc-window (get-buffer-window "*eldoc*"))
        (delete-window eldoc-window)
        (eldoc t)))

(my/evil-define-key '(normal motion) 'lsp-mode-map  ;; 'prog-mode-map
    "RET" #'lsp-ui-doc-show
    "K" #'my/eldoc)
#+end_src

Есть функция =lsp-inlay-hints-mode= - показывает прямо в документе
типы объектов и прочее всякое. Запилим под нее клавиши, чтобы не
забывалась.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "c h" #'lsp-inlay-hints-mode)
#+end_src

Добавим ставшую привычной из Doom навигацию по коду.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'lsp-mode-map  ;; 'prog-mode-map
               "c" '(:ignore t :which-key "code"))
(my/leader-def nil 'lsp-mode-map  ;; 'prog-mode-map
               "c d" '(lsp-find-definition :which-key "Jump to definition")
               "c D" '(lsp-find-references :which-key "Jump to references"))
#+end_src

Для консистентности добавим такие же клавиши для eglot.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'eglot-mode-map  ;; 'prog-mode-map
               "c" '(:ignore t :which-key "code"))
(my/leader-def nil 'eglot-mode-map  ;; 'prog-mode-map
               "c d" '(xref-find-definitions :which-key "Jump to definition")
               "c D" '(xref-find-references :which-key "Jump to references"))
#+end_src

** Перезагрузка

В работе с LSP через TRUMP столкнулся с проблемой: "LSP :: Sending to
process failed with the following error: Process pyright-remote not
running". Простые перезагрузки LSP-сервера не помогают. Нашел решение:
перед перезагрузкой сбросить переменную =lsp--session= в nil. Запилим
это решение.

#+begin_src emacs-lisp :tangle yes
(defun my/lsp-restart ()
    (interactive)
    (my/--lsp-reset-session-cache)
    ;; (call-interactively 'lsp-workspace-restart)
    (lsp-shutdown-workspace)
    (lsp))

(defun my/lsp-shutdown-workspace ()
    (interactive)
    (my/--lsp-reset-session-cache)
    (lsp-shutdown-workspace))

(defun my/--lsp-reset-session-cache ()
    (when (boundp 'lsp--session)
        (setq lsp--session nil)))

(defun my/lsp ()
    (interactive)
    (my/--lsp-reset-session-cache)
    (lsp))
#+end_src

И горячие клавиши для работ

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "c l" '(:ignore t :which-key "LSP utils")
               "c l l" '(lsp :which-key "Run LSP server")
               "c l L" '(my/lsp :which-key "Run LSP server, clear cache")
               "c l s" '(my/lsp-shutdown-workspace :which-key "Shutdown LSP workspace")
               "c l r" '(my/lsp-restart :which-key "Restart LSP workspace"))
#+end_src

** Copilot

С некоторых пор в lsp появился пакет lsp-copilot, который пока мешает,
нежели чем помогает. Поэтому попробуем пока отключить его.

Способ 1 (не сработал).

#+begin_src emacs-lisp :tangle yes
(setq lsp-copilot-enabled nil)
#+end_src

Способ 2 (сработал).

#+begin_src emacs-lisp :tangle yes
(delete 'lsp-copilot lsp-client-packages)
#+end_src

** Semgrep

Мешается. Убираем.

#+begin_src emacs-lisp :tangle yes
(delete 'lsp-semgrep lsp-client-packages)
#+end_src

* Tree sitter (treesit)

** Treesit. Установка и общие настройки

Здесь ориентируемся на Emacs 29, в котором tree-sitter уже
предустановлен.

Полезную информацию по tree-sitter можно почитать в "Mastering Emacs":
[[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][How to Get Started with Tree-Sitter]]

Для поддержки грамматики разных языков сделаем функцию. Принимает на
вход символ языка (например 'cpp) и путь к реализации его грамматики
на Github (например "https://github.com/tree-sitter/tree-sitter-cpp").

#+begin_src emacs-lisp :tangle yes
(defun my/treesit-install-language-grammar (lang-symbol github-path)
    (add-to-list 'treesit-language-source-alist
                 `(,lang-symbol ,github-path))
    (unless (treesit-ready-p lang-symbol)
        (treesit-install-language-grammar lang-symbol)))
#+end_src

После регистрации необходимо заменить привычные ~<LANG>-mode~ на
~<LANG>-ts-mode~. Например:
: (add-to-list 'auto-mode-alist '("\\.cpp\\'" . c++-ts-mode))
: (add-to-list 'auto-mode-alist '("\\.c\\'" . c-ts-mode))

** COMMENT Схлопывание текста с tree-sitter (ts-fold)

   Не дружит со встроенным в Emacs 29 treesit.
   Treesit и tree-sitter - это два разных пакета.

#+begin_src emacs-lisp :tangle yes
(use-package combobulate
    :quelpa (ts-fold :fetcher github :repo "emacs-tree-sitter/ts-fold")
    :ensure t)
#+end_src

** Combobulate - редактирование с treesit

Навигация посредством tree sitter. Сделано для очень ограниченного
количества языков (см. на [[https://github.com/mickeynp/combobulate][странице]]). При навигации рисует дерево
разбора.

Чтобы заработало, нужно включить =combobulate-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package combobulate
    :quelpa (combobulate :fetcher github :repo "mickeynp/combobulate")
    :preface
    (setq combobulate-key-prefix "C-c o"))
#+end_src

** Выделение родительских блоков (в программном коде)

Сделаем выделение блоков по дереву treesit. Может пригодится для
визуализации или для отправки выделенного фрагмента в LLM-модель.

Выделять будем по границам ноды. Если выделение уже есть, то
увеличиваем его до границ родительской ноды.

Чтобы можно было откатывать выделение назад, будем хранить историю
выделений. Соответственно, обеспечим функции для работы с этой
историей (push, pop с автоматической очисткой). Историю ведем локально
для каждого буфера.

#+begin_src emacs-lisp :tangle yes
(defvar my/treesit--selection-history nil
  "History of treesit selection.
Must be a list of pairs (begin . end).")

(defun my/treesit--selection-history-push (begin end)
    (when (my/treesit--selection-history-clear-p)
        (setq-local my/treesit--selection-history nil))
    (push (cons begin end) my/treesit--selection-history))

(defun my/treesit--selection-history-pop ()
    (when (my/treesit--selection-history-clear-p)
        (setq-local my/treesit--selection-history nil))
    (when my/treesit--selection-history
        (pop my/treesit--selection-history)))

(defun my/treesit--selection-history-clear-p ()
    (not (and (use-region-p)
              my/treesit--selection-history)))
#+end_src

Выделять будем только при наличии парсера treesit. Обертку с проверкой
будем держать в следующей функции.

#+begin_src emacs-lisp :tangle yes
(defun my/treesit-saver (func &rest args)
    (if (and (fboundp 'treesit-parser-list)
             (treesit-parser-list))
        (apply func args)
        (message "Treesit mode is required.")))
#+end_src

Теперь сделаем три интерактивных функции для выделения:
- =my/treesit-select-parent-node= - расширяет выделение до
  родительской ноды.
- =my/treesit-select-to-parent-node-top= - расширяет выделение только
  в одну сторону до начала родительской ноды.
- =my/treesit-select-back= - откатывает выделение на предыдущее.

#+begin_src emacs-lisp :tangle yes
(defun my/treesit-select-parent-node ()
    (interactive)
    (when-let ((node (my/treesit-saver 'my/treesit--select-parent-node)))
        (message (treesit-node-type node))))

(defun my/treesit--select-parent-node ()
    (let* ((node (my/treesit--get-node))
           (point-in-begin-p (my/treesit--point-in-region-begin-p))
           (parent-node (my/treesit--bigger-parent-node node t t))
           (begin (treesit-node-start parent-node))
           (end (treesit-node-end parent-node)))
        (my/treesit--selection-history-push (treesit-node-start node)
                                            (treesit-node-end node))
        (if point-in-begin-p
            (progn (set-mark end)
                   (goto-char begin))
            (progn (set-mark begin)
                   (goto-char end)))
        (activate-mark)
        parent-node))

(defun my/treesit-select-to-parent-node-top ()
    (interactive)
    (when-let ((node (my/treesit-saver 'my/treesit--select-to-parent-node-top)))
              (message (treesit-node-type node))))

(defun my/treesit--select-to-parent-node-top ()
    (let* ((node (my/treesit--get-node))
           (point-in-begin-p (my/treesit--point-in-region-begin-p t))
           (parent-node (my/treesit--bigger-parent-node node t nil))
           (begin (treesit-node-start parent-node))
           (end (if (use-region-p)
                    (use-region-end)
                    (treesit-node-end node))))
        (my/treesit--selection-history-push (treesit-node-start node)
                                            end)
        (if point-in-begin-p
            (progn (set-mark end)
                   (goto-char begin))
            (progn (set-mark begin)
                   (goto-char end)))
        (activate-mark)
        parent-node))

(defun my/treesit-select-back ()
    (interactive)
    (when-let ((node (my/treesit-saver 'my/treesit--select-back)))
        (message (treesit-node-type node))))

(defun my/treesit--select-back ()
    (if-let ((region (my/treesit--selection-history-pop)))
        (progn (deactivate-mark)
               (set-mark (cdr region))
               (goto-char (car region))
               (activate-mark)
               (treesit-node-on (car region) (cdr region)))
        (deactivate-mark)))

(defun my/treesit--get-node ()
    (if (use-region-p)
        (treesit-node-on (use-region-beginning)
                         (use-region-end))
        (treesit-node-at (point))))

(defun my/treesit--point-in-region-begin-p (&optional prefer-end-p)
    (if (use-region-p)
        (cond
          ((= (use-region-beginning) (use-region-end))
           (not prefer-end-p))
          (t
           (< (- (point) (use-region-beginning))
              (- (use-region-end) (point)))))
        (not prefer-end-p)))

(defun my/treesit--bigger-parent-node (node begin-p end-p)
    (if (or begin-p end-p)
        (let* ((node node)
               (parent-node (treesit-node-parent node))
               (begin (when begin-p (treesit-node-start node)))
               (end (when end-p (treesit-node-end node))))
            (while (and (not (equal node parent-node))
                        (or (not begin-p)
                            (= begin (treesit-node-start parent-node)))
                        (or (not end-p)
                            (= end (treesit-node-end parent-node))))
                (setq node parent-node
                      parent-node (treesit-node-parent node)))
            parent-node)
        node))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-:") 'my/treesit-select-parent-node)
(global-set-key (kbd "M-P") 'my/treesit-select-to-parent-node-top)
(global-set-key (kbd "M-N") 'my/treesit-select-back)
#+end_src

* Программирование

** Навигация по ошибкам

Запилим горячие клавиши для перемещения по ошибкам на основе flycheck
(а для C++/C - flymake, потому что пока работает на Eglot+Clangd).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "e p" '(my/jump-previous-error :which-key "Jump to previous error")
    "e n" '(my/jump-next-error :which-key "Jump to next error"))

(defun my/jump-previous-error ()
    (interactive)
    (if (my/--check-c++/c-eglot-mode)
        (flymake-goto-prev-error)
        (flycheck-previous-error)))

(defun my/jump-next-error ()
    (interactive)
    (if (my/--check-c++/c-eglot-mode)
        (flymake-goto-next-error)
        (flycheck-next-error)))

(defun my/--check-c++/c-eglot-mode ()
    ;; (member major-mode '(c++-mode c-mode)))
    nil)
#+end_src

** Компиляция (compile). Назначение клавиш

Для вызова асинхронной shell-команды есть стандартные клавиши:
: M-&

Для вызова команды =compile= сделаем свои клавиши.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-*") #'compile)
#+end_src

** Emacs-Lisp

Для emacs-elisp переход на функцию осуществляется через функцию
=find-function-at-point=.  Посадим ее на те же клавиши, что и для LSP.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'emacs-lisp-mode-map
    "c d" '(find-function-at-point :which-key "Jump to definition"))
#+end_src

** Показ кандидатов через ivy-xref

Ниже код вставлен по инструкции отсюда:
[[https://github.com/alexmurray/ivy-xref][ivy-xref - select from xref candidates with ivy]]

#+begin_src emacs-lisp :tangle yes
(use-package ivy-xref
    :ensure t
    :init
    ;; xref initialization is different in Emacs 27 - there are two different
    ;; variables which can be set rather than just one
    (when (>= emacs-major-version 27)
        (setq xref-show-definitions-function #'ivy-xref-show-defs))
    ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
    ;; commands other than xref-find-definitions (e.g. project-find-regexp)
    ;; as well
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+end_src

** Dumb-jump. Решение проблемы перехода по сущностям

Когда не помогают LSP-сервера и прочие инструменты, на помощь приходит
dumb-jump. Грепает регулярками по проекту и показывает результат
(настроено на ivy).

#+begin_src emacs-lisp :tangle yes
(use-package dumb-jump
    :ensure t
    :config
    (setq dumb-jump-selector 'ivy))
#+end_src

Зададим свои горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "j d" '(:ignore t :which-key "Dumb Jump")
               "j d j" '(dumb-jump-go :which-key "Go")
               "j d o" '(dumb-jump-go-other-window :which-key "Other window")
               "j d e" '(dumb-jump-go-prefer-external :which-key "Go external")
               "j d x" '(dumb-jump-go-prefer-external-other-window
                         :which-key "Go external other window")
               "j d i" '(dumb-jump-go-prompt :which-key "Prompt")
               "j d l" '(dumb-jump-quick-look :which-key "Quick look")
               "j d b" '(dumb-jump-back :which-key "Back"))
#+end_src

** Logview

Пакет для просмотра логов. Дает logview-mode.

#+begin_src emacs-lisp :tangle yes
(use-package logview
    :ensure t)
#+end_src

** Markdown

Устанавливаем пакеты для поддержки markdown.

#+begin_src emacs-lisp :tangle yes
(use-package markdown-toc
	:ensure t)
#+end_src

# Поскольку в markdown пробелы в конце строки имеют значение, то
# визуализируем их.
#
# #+begin_src emacs-lisp :tangle yes
# (add-hook 'markdown-mode-hook #'whitespace-mode)
# #+end_src

Для markdown-файлов нужен просмотр. Сделаем его через утилиту
=retext=. Утилита хороша тем, что в режиме просмотра тут же
перерисовывает содержимое при изменениях в исходном файле. Это
особенно удобно при работе в плиточных оконных менеджерах.

Устанавливаем утилиту =retext= так:

#+begin_example bash
sudo apt install retext
#+end_example

Пишем код для предпросмотра markdown-файлов.

#+begin_src emacs-lisp :tangle yes
(defun my/markdown-preview-file ()
    "Preview a markdown file by `retext' utilite."
    (interactive)
    (start-process "Markdown-Preview-by-Retext"
                   "*markdown-retext-preview*"
                   "retext" "--preview" (buffer-file-name)))
                   ;; "retext" "--preview" (shell-quote-argument (buffer-file-name))))  ; Оставлено для памяти.
#+end_src

Вешаем предпросмотр на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
;; (eval-after-load 'markdown-mode
;; 	'(evil-define-key nil markdown-mode-map (my/kbd-localleader "p") #'my/markdown-preview-file))

(my/localleader-def nil 'markdown-mode-map
    "p" #'my/markdown-preview-file)

#+end_src

** CSV и TSV

Режим для работы с CSV-файлами. Определяет правильно поля и колонки,
перемещается по ним через TAB и S-TAB. Умеет сортировать по колонкам и
т.п..

Подцепляет также работу с TSV.

#+begin_src emacs-lisp :tangle yes
(use-package csv-mode
    :ensure t
    :hook (csv-mode . csv-guess-set-separator))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'csv-mode-map
                    "s" '(csv-sort-fields :which-key "csv-sort-fields")
                    "n" 'csv-sort-numeric-fields
                    "r" 'csv-reverse-region
                    "k" 'csv-kill-fields
                    "y" 'csv-yank-fields
                    "a" 'csv-align-fields
                    "u" 'csv-unalign-fields
                    "t" 'csv-transpose)
#+end_src

** PDF

Позволяет просматривать PDF'ки и делать аннотации, просматривать их и
смотреть их полный список.

#+begin_src emacs-lisp :tangle yes
(use-package pdf-tools
    :ensure t
    :commands (pdf-loader-install)
    :mode "\\.pdf\\'"
    :bind (:map pdf-view-mode-map
                ("j" . pdf-view-next-line-or-next-page)
                ("k" . pdf-view-previous-line-or-previous-page)
                ("C-=" . pdf-view-enlarge)
                ("C--" . pdf-view-shrink))
    :init
    (pdf-loader-install)
    :config
    (add-to-list 'revert-without-query ".pdf"))
#+end_src

** Yaml

Подсветка yaml-файлов.

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
    :ensure t)
#+end_src

** Json

#+begin_src emacs-lisp :tangle yes
(use-package json-mode
    :ensure t)
#+end_src

Поддержка LSP для Json'а больше мешает, чем помогает. Оставляю тут для
памяти.

#+begin_example emacs-lisp :tangle yes
(lsp-ensure-server 'json-ls)
#+end_example

Поддержка tree-sitter. Слабенькая (json-ts-mode не тянет большие
файлы), но если вручную выставить:
: (json-ts-mode)
: (combobulate-mode)
то, может, редактировать JSON'ы будет удобнее.

#+begin_src emacs-lisp :tangle yes
(my/treesit-install-language-grammar
 'json
 "https://github.com/tree-sitter/tree-sitter-json")
#+end_src

** Make

#+begin_src emacs-lisp :tangle yes
(require 'make-mode)
#+end_src

** Vimrc

#+begin_src emacs-lisp :tangle yes
(use-package vimrc-mode
    :ensure t)
#+end_src

** PlantUML

Загружаем пакеты для поддержки Plantuml.
По-умолчанию на выходе стоит "svg"-файл (есть еще "png" и "txt").
Это неудобно для темных тем, поскольку все буквы идут черным цветом.
Перейдем на "png" по-умолчанию.

#+begin_src emacs-lisp :tangle yes
(use-package plantuml-mode
    :ensure t
    :init
    (let ((jar-path (file-name-concat user-emacs-directory "/.local/plantuml.jar")))
        (setq plantuml-jar-path jar-path
              org-plantuml-jar-path jar-path))
    :config
    (setq plantuml-default-exec-mode
          (cond ((file-exists-p plantuml-jar-path) 'jar)
                ((executable-find "plantuml") 'executable)
                (plantuml-default-exec-mode)))
    (plantuml-set-output-type "png"))
#+end_src

Подгрузим автоматом jar-файл.

#+begin_src emacs-lisp :tangle yes
(unless (file-exists-p plantuml-jar-path)
    (plantuml-download-jar))
#+end_src

Присоседим расширение ".puml" к ".plantuml".

#+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.puml\\'" . plantuml-mode))
#+end_src

Горячая клавиша для автодополнения.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key 'insert 'plantuml-mode-map
               "TAB" #'plantuml-complete-symbol)
#+end_src

Горячая клавиша для показа диаграмы в вертикально разделенной половине окна.

#+begin_src emacs-lisp :tangle yes
(defun my/plantuml-preview ()
    (interactive)
    (save-excursion
        (plantuml-preview 4)
        ;; (plantuml-preview-current-block 4)
        ;; (doom/escape)
        ))

(my/evil-define-key 'normal 'plantuml-mode-map
                    "RET" #'my/plantuml-preview)
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'plantuml)
#+end_src

UTF-8 - наше всё! :)

#+begin_src emacs-lisp :tangle yes
(add-to-list 'org-babel-default-header-args:plantuml
             '(:cmdline . "-charset utf-8"))
#+end_src

Настроим параметр :file для plantuml-блоков по-умолчанию. Если
параметр :file не указан, то создаем временный файл с картинкой.

#+begin_src emacs-lisp :tangle yes
(advice-add #'org-babel-execute:plantuml
            :around (my/org-babel-execute plantuml))
#+end_src

** Mermaid

Mermaid - это аналог PlantUML. Для работы требует установки
=mermail-cli=.  Прочитать можно тут: [[https://mermaid.js.org/intro/][About Mermaid]].

#+begin_src emacs-lisp :tangle yes
(use-package mermaid-mode
    :ensure t)
(use-package ob-mermaid
    :ensure t)
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'mermaid)
#+end_src

Настроим параметр :file для mermaid-блоков по-умолчанию. Если
параметр :file не указан, то создаем временный файл с картинкой.

#+begin_src emacs-lisp :tangle yes
(advice-add #'org-babel-execute:mermaid
            :around (my/org-babel-execute mermaid))
#+end_src

** Gnuplot

Gnuplot рисует графики и диаграммы. Для работы с этим надо установить
Gnuplot в систему. На Arch это выглядит так:
: sudo pacman -S gnuplot

Полезные ссылки по установке и использованию:
- [[https://github.com/emacs-gnuplot/gnuplot][Gnuplot for Emacs]]
- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][Org-babel-gnuplot]]
- [[https://orgmode.org/worg/org-tutorials/org-plot.html][Plotting tables in Org-Mode using org-plot]]
- [[https://stackoverflow.com/questions/15736101/is-there-a-way-to-quickly-plot-elisp-functions-with-gnuplot][Is there a way to quickly plot elisp functions with gnuplot?]]

Сделаем установку пакетов для Gnuplot.

#+begin_src emacs-lisp :tangle yes
(use-package gnuplot
    :ensure t)
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'gnuplot)
#+end_src

Настроим параметр :file для gnuplot-блоков по-умолчанию. Если
параметр :file не указан, то создаем временный файл с картинкой.

#+begin_src emacs-lisp :tangle yes
(advice-add #'org-babel-execute:gnuplot
            :around (my/org-babel-execute gnuplot))
#+end_src

** Restclient

   #+begin_src emacs-lisp :tangle yes
(use-package restclient
    :ensure t)
(use-package company-restclient
    :ensure t)
   #+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(use-package ob-restclient
    :ensure t)
#+end_src

** Python

Установим основные пакеты. Какие-то будут впрок.

/Шпаргалка:/
:   - if doom-module:+pyright
:     - doom-package:lsp-pyright

#+begin_src emacs-lisp :tangle yes
(use-package python
    :ensure t)
(use-package python-mode
    :ensure t)
(use-package pipenv
    :ensure t)
(use-package pip-requirements
    :ensure t)
(use-package pyvenv
    :ensure t
    :config
    (add-hook 'python-mode-local-vars-hook #'pyvenv-track-virtualenv)
    (add-to-list 'global-mode-string
                 '(pyvenv-virtual-env-name (" venv:" pyvenv-virtual-env-name " "))
                 'append))
(use-package pyenv-mode
    :ensure t)
(use-package pyimport
    :ensure t)
(use-package py-isort
    :ensure t)
(use-package python-pytest
    :ensure t)
#+end_src

Путь к настройкам линтера PyLint.

#+begin_src emacs-lisp :tangle yes
(setq flycheck-pylintrc (list "pylintrc"
                              ".pylintrc"
                              ;; "pyproject.toml"
                              "setup.cfg"
                              (file-name-concat (getenv "HOME") "/.config/pylintrc")))
#+end_src

Путь к настройкам линтера flake8.

#+begin_src emacs-lisp :tangle yes
(setq flycheck-flake8rc (list ".flake8"
                              "setup.cfg"
                              "tox.ini"
                              (file-name-concat (getenv "HOME") "/.config/flake8")))
#+end_src

Путь к настройкам линтера mypy.

#+begin_src emacs-lisp :tangle yes
(setq flycheck-python-mypy-config (list "mypy.ini"
                                        ;; "pyproject.toml"
                                        "setup.cfg"
                                        (file-name-concat (getenv "HOME")
                                                          "/.config/mypy/config")))
#+end_src

Настройка LSP сервера. Ориентируемся на Pyright, он более устойчивый и
легковесный, чем Mspyls.

Pyright может не скачаться с серверов, поэтому при удачной попытке его
лучше сохранить. Лежит сервер в директории
: ~/.emacs.d/.cache/lsp/npm/pyright

Устанавливаем pyright из архива в репозитории (ибо пакет =lsp-pyright=
уже не тянется).

#+begin_src emacs-lisp :tangle yes
(unless (file-exists-p (file-name-concat user-emacs-directory
                                         "/.cache/lsp/npm/pyright"))
    (shell-command (concat "tar -xzf "
                           (file-name-concat (my/config-dir
                                              "/lsp-saves/pyright_vanilla.tar.gz"))
                           " -C " user-emacs-directory)))
#+end_src

Теперь устанавливаем сам сервер.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-pyright
    :ensure t)
;; (lsp-ensure-server 'pyright)
#+end_src

У LSP-сервера pyright есть *проблема*: Ошибка в буфере *stderr* имеет
следующее описание:
: Process terminated. Couldn't find a valid ICU package installed on the
: system. Set the configuration flag System.Globalization.Invariant to
: true if you want to run with no globalization support.
И лечится установкой где-нибудь в [[/etc/profile]] переменной:
: export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1

Поддержка tree-sitter. Подменяем python-mode на python-ts-mode.

#+begin_src emacs-lisp :tangle yes
(my/treesit-install-language-grammar
 'python
 "https://github.com/tree-sitter/tree-sitter-python")

(add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
#+end_src

Настраиваем активацию LSP-сервера.

#+begin_src emacs-lisp :tangle yes
(mapc (apply-partially (-flip 'add-hook) 'my/python--lsp-exclude-calculator)
      '(python-mode-hook
        python-ts-mode-hook))

(defun my/python--lsp-exclude-calculator ()
    (unless (equal (buffer-file-name)
                   (my/calculator--get-python-filename))
        (require 'lsp-pyright)
        (lsp)))  ; or lsp-deferred
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'python)
#+end_src

** Python. Pyvenv

Если работаем в одном демоне с несколькими проектами, то удобно будет
иметь быструю менюшку для выбора ранее открытых виртуальных
сред. Запилим такую.

Для начала повесим обвязку на pyvenv-activate.

#+begin_src emacs-lisp :tangle yes
(setq my/pyvenv-activated-paths (make-hash-table :test 'equal))

(defun my/pyvenv-activate-path-saver (func &rest args)
    (let ((path (car args)))
        (puthash path nil my/pyvenv-activated-paths)
        (apply func args)))

(advice-add 'pyvenv-activate :around #'my/pyvenv-activate-path-saver)
#+end_src

Один /важный момент/ с пакетом =Conda=! Ему тоже надо накидывать путь
в виртуальную среду, и тогда он будет видеть ее объекты! Запилим для
этого собственную функцию активации виртуальной среды.

#+begin_src emacs-lisp :tangle yes
(defun my/pyvenv-activate (directory)
    (interactive (list (read-directory-name "Activate venv: " nil nil nil
                                            pyvenv-default-virtual-env-name)))
    (setq directory (expand-file-name directory))
    (pyvenv-activate directory)
    (when (fboundp 'conda-env-activate-path)
        (conda-env-activate-path directory)))
#+end_src

Теперь сделаем выбор из ранее открытых директорий виртуальных сред.
Сделаем попытку подтянуть наверх пути из текущего проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/pyvenv-select-path ()
    "Select one of opened Python virtual environment paths."
    (interactive)
    (if (= 0 (hash-table-count my/pyvenv-activated-paths))
            (message "The history of Pyvenv activating is empty.")
        (let ((path (ivy-read "Select Python virtual environment path:"
                              (my/--sort-pyvenv-paths my/pyvenv-activated-paths
                                                      (projectile-project-root)))))
            (unless (string-empty-p path)
                (pyvenv-activate path)
                (when (fboundp 'conda-env-activate-path)
                    (conda-env-activate-path path))
                (message (format "Pyvenv is activated: %s" path))))))

(defun my/--sort-pyvenv-paths (paths-hashmap path-prefix)
    (let ((ensured-prefix (if path-prefix path-prefix ""))
          (with-prefix)
          (without-prefix)
          (result))
        (maphash (lambda (key val)
                     (if (string-search ensured-prefix key)
                             (setq with-prefix (cons key with-prefix))
                         (setq without-prefix (cons key without-prefix))))
                 paths-hashmap)
        (mapc (lambda (path)
                  (setq result (cons path result)))
              without-prefix)
        (mapc (lambda (path)
                  (setq result (cons path result)))
              with-prefix)
        result))
#+end_src

И горячие клавиши на активацию и на выбор путей:

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "c a" #'my/pyvenv-activate
               "c i" #'my/pyvenv-select-path)
#+end_src

** Emacs IPython Notebook (ein)

Клиент для Jupyter-notebook, не самый красивый, но что-то.

Пока настроено так, что не работают ein:run и ein:jupyter-server-start
(дают ошибку). Так что запускаться надо следующим образом:
1. Где-нибудь в консоли запускаем Jupyter-notebook:
   : ~/anaconda3/bin/jupyter-notebook --no-browse
2. Подключаемся к сервису:
   : M-x ein:login
   Там только указываем порт (8888).

#+begin_src emacs-lisp :tangle yes
(use-package ein
    :ensure t
    :config
    (require 'ein)
    (require 'ein-notebook)
    ;; (require 'ein-subpackages)
    )
#+end_src

Чтобы долго не искать, оставлю это тут:

|   | key          | binding                                     |
|---+--------------+---------------------------------------------|
|   | C-c          | Prefix Command                              |
|   | C-x          | Prefix Command                              |
|   | ESC          | Prefix Command                              |
|   | .            | ein:notebook-complete-dot                   |
|   | C-:          | ein:shared-output-eval-string               |
|   | <C-down>     | ein:worksheet-goto-next-input               |
|   | <C-up>       | ein:worksheet-goto-prev-input               |
|   | <M-S-return> | ein:worksheet-execute-cell-and-insert-below |
|   | <M-down>     | ein:worksheet-move-cell-down                |
|   | <M-up>       | ein:worksheet-move-cell-up                  |
|---+--------------+---------------------------------------------|
|   | C-x C-s      | ein:notebook-save-notebook-command          |
|   | C-x C-w      | ein:notebook-rename-command                 |
|---+--------------+---------------------------------------------|
|   | M-RET        | ein:worksheet-execute-cell-and-goto-next    |
|   | M-,          | ein:pytools-jump-back-command               |
|   | M-.          | ein:pytools-jump-to-source-command          |
|   | M-n          | ein:worksheet-next-input-history            |
|   | M-p          | ein:worksheet-previous-input-history        |
|---+--------------+---------------------------------------------|
| * | C-c C-a      | ein:worksheet-insert-cell-above             |
| * | C-c C-b      | ein:worksheet-insert-cell-below             |
| * | C-c C-c      | ein:worksheet-execute-cell                  |
| * | C-c C-e      | ein:worksheet-toggle-output                 |
|   | C-c C-f      | ein:pytools-request-tooltip-or-help         |
|   | C-c TAB      | ein:completer-complete                      |
| * | C-c C-k      | ein:worksheet-kill-cell                     |
| * | C-c C-l      | ein:worksheet-clear-output                  |
|   | C-c RET      | ein:worksheet-merge-cell                    |
| * | C-c C-n      | ein:worksheet-goto-next-input               |
|   | C-c C-o      | ein:console-open                            |
| * | C-c C-p      | ein:worksheet-goto-prev-input               |
|   | C-c C-q      | ein:notebook-kill-kernel-then-close-command |
|   | C-c C-r      | ein:notebook-restart-kernel-command         |
|   | C-c C-s      | ein:worksheet-split-cell-at-point           |
|   | C-c C-t      | ein:worksheet-toggle-cell-type              |
|   | C-c C-u      | ein:worksheet-change-cell-type              |
|   | C-c C-v      | ein:worksheet-set-output-visibility-all     |
|   | C-c C-w      | ein:worksheet-copy-cell                     |
|   | C-c C-x      | ein:tb-show                                 |
|   | C-c C-y      | ein:worksheet-yank-cell                     |
|   | C-c C-z      | ein:notebook-kernel-interrupt-command       |
|   | C-c ESC      | Prefix Command                              |
|   | C-c !        | ein:worksheet-rename-sheet                  |
|   | C-c +        | ein:notebook-worksheet-insert-next          |
|   | C-c -        | ein:notebook-worksheet-delete               |
|   | C-c 1        | ein:notebook-worksheet-open-1th             |
|   | C-c 2        | ein:notebook-worksheet-open-2th             |
|   | C-c 3        | ein:notebook-worksheet-open-3th             |
|   | C-c 4        | ein:notebook-worksheet-open-4th             |
|   | C-c 5        | ein:notebook-worksheet-open-5th             |
|   | C-c 6        | ein:notebook-worksheet-open-6th             |
|   | C-c 7        | ein:notebook-worksheet-open-7th             |
|   | C-c 8        | ein:notebook-worksheet-open-8th             |
|   | C-c 9        | ein:notebook-worksheet-open-last            |
|   | C-c {        | ein:notebook-worksheet-open-prev-or-last    |
|   | C-c }        | ein:notebook-worksheet-open-next-or-first   |
|   | C-c C-S-l    | ein:worksheet-clear-all-output              |
|   | C-c C-#      | ein:notebook-close                          |
|   | C-c C-'      | ein:worksheet-turn-on-autoexec              |
|   | C-c C-,      | ein:pytools-jump-back-command               |
|   | C-c C-.      | ein:pytools-jump-to-source-command          |
|   | C-c C-/      | ein:notebook-scratchsheet-open              |
|   | C-c C-;      | ein:shared-output-show-code-cell-at-point   |
|   | C-c <down>   | ein:worksheet-move-cell-down                |
|   | C-c <up>     | ein:worksheet-move-cell-up                  |
|---+--------------+---------------------------------------------|
|   | C-c M-+      | ein:notebook-worksheet-insert-prev          |
|   | C-c M-w      | ein:worksheet-copy-cell                     |
|   | C-c M-{      | ein:notebook-worksheet-move-prev            |
|   | C-c M-}      | ein:notebook-worksheet-move-next            |

** Haskell

Устанавливаем пакет для Haskell и поддержку LPS для него.

#+begin_src emacs-lisp :tangle yes
(use-package haskell-mode
    :ensure t)
(use-package lsp-haskell
    :ensure t
    :config
    (add-hook 'haskell-mode-hook #'lsp)
    (add-hook 'haskell-literate-mode-hook #'lsp)
    ;; (customize-group 'lsp-haskell)
    )
(use-package retrie
    :ensure t)
#+end_src

Для org-mode удобно раз и навсегда включить полезные расширения языка.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'haskell-process-args-ghci "-XDuplicateRecordFields")
(add-to-list 'haskell-process-args-ghci "-XOverloadedStrings")
(add-to-list 'haskell-process-args-ghci "-XDeriveGeneric")
(add-to-list 'haskell-process-args-ghci "-package aeson")
#+end_src

Автоотступы. Ставим четверки вместо двоек.

#+begin_src emacs-lisp :tangle yes
(setq haskell-indentation-starter-offset 4
      haskell-indentation-where-pre-offset 4
      haskell-indentation-left-offset 4
      haskell-indentation-where-post-offset 4
      haskell-indentation-layout-offset 4)
#+end_src

Настраиваем tree-sitter. Но здесь не полностью - пока не въехал,
откуда брать haskell-ts-mode.

#+begin_src emacs-lisp :tangle yes
(my/treesit-install-language-grammar
 'haskell
 "https://github.com/tree-sitter/tree-sitter-haskell")

(when (treesit-ready-p 'haskell)
    (treesit-parser-create 'haskell))

;; ;; Не реализовано.
;; (add-to-list 'major-mode-remap-alist '(haskell-mode . haskell-ts-mode))
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'haskell)
#+end_src

** Rust

(!) Чтобы заработал LSP-сервер для Rust,
необходимо установить утилиту =rust-analyzer=:
: sudo pacman -S rust-analyzer

Много полезных настроек можно посмотреть тут:
[[https://robert.kra.hn/posts/rust-emacs-setup/][Configuring Emacs for Rust development]].

Устанавливаем необходимые пакеты. (Все есть в одном пакете rustic, а
ob-rust для работы с org-babel блоками устанавливается [[id:c98e419e-f7e9-456d-b8f3-5037f0af775b][выше]]).

#+begin_src emacs-lisp :tangle yes
(use-package rustic
    :ensure t)
(use-package ob-rust
    :ensure t)
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'rust)
#+end_src

** COMMENT C++ Irony-mode, Company-irony

В помощь LSP-серверам подгоним irony-mode. Оно ходит по заголовкам и
делает авто-дополнение.

Примеры настроек возьмем со страницы [[https://github.com/Sarcasm/irony-mode][irony-mode]] и [[https://github.com/Sarcasm/company-irony][company-irony]].

После надо не забыть установить =irony-server= командой:
: (irony-install-server)

#+begin_src emacs-lisp :tangle yes
(use-package irony
    :ensure t
    :config
    (unless (irony--find-server-executable) (call-interactively #'irony-install-server)))
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

(use-package company-irony
    :ensure t)
(eval-after-load 'company
    '(add-to-list 'company-backends 'company-irony))

;; (use-package flycheck-irony
;;     :ensure t)
;; (global-flycheck-mode)
;; (eval-after-load 'flycheck
;;     '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))

(add-to-list 'company-backends 'company-irony-c-headers)

;; Use compilation data first, clang_complete as fallback.
(setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
                                                irony-cdb-clang-complete))
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

;; (use-package irony-eldoc
;;     :ensure t
;;     :config
;;     (add-hook 'irony-mode-hook #'irony-eldoc))
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'C)
#+end_src

** COMMENT C++ (ccls LSP-server)
   :PROPERTIES:
   :ID:       b98a08b8-ca0b-4850-8816-702d90fd1e15
   :CUSTOM_ID: b98a08b8-ca0b-4850-8816-702d90fd1e15
   :END:

Есть две альтернативы LSP-сервера для C++: =clangd= и =ccls=. Первый
приводится в документации только совместно с пакетом =eglot=, второй -
с пакетом =lsp=. Поскольку на данный момент я выбрал для себя lsp, то
базируемся на =ccls=.

Для начала =ccls= следует установить. На Arch это выглядит так:
: sudo pacman -S ccls

Инструкцию берем отсюда:
1. [[https://github.com/emacs-lsp/emacs-ccls][emacs-ccls]]
2. [[https://github.com/MaskRay/ccls/wiki/lsp-mode][lsp mode]]

Устанавливаем пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package ccls
    ;; :ensure t
    :hook ((c-mode c++-mode objc-mode cuda-mode) .
           (lambda () (require 'ccls) (lsp))))
#+end_src

И настройки из инструкции.

#+begin_src emacs-lisp :tangle yes
(setq ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'C)
#+end_src

** COMMENT C++ (clangd on Eglot)
   :PROPERTIES:
   :ID:       871c5917-4bed-4369-9cb6-121582f33ede
   :CUSTOM_ID: 871c5917-4bed-4369-9cb6-121582f33ede
   :END:

=TODO=: Инструкция на поизучать: [[https://emacs-lsp.github.io/lsp-mode/tutorials/CPP-guide/][Configuring Emacs as a C/C++ IDE]].

Есть две альтернативы LSP-сервера для C++: =clangd= и =ccls=. Первый
приводится в документации только совместно с пакетом =eglot=, второй -
с пакетом =lsp=.

Здесь поставим =eglot=. Теперь можно сравнивать работу с [[id:b98a08b8-ca0b-4850-8816-702d90fd1e15][ccls на lsp]].

Пользуемся инструкцией:
[[https://clangd.llvm.org/installation.html][Clangd. Getting started]]

#+begin_src emacs-lisp :tangle yes
(require 'eglot)
(add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
(add-hook 'c-mode-hook 'eglot-ensure)
(add-hook 'c++-mode-hook 'eglot-ensure)
#+end_src

Настройки работы LSP-сервера через TRAMP. Если на удаленной машине
редактируется C++-файл, то LSP-сервер запускается так же на удаленной
машине. Об этом и надо сказать Emacs'у.  Настройки сделаны по примеру
отсюда: [[https://emacs-lsp.github.io/lsp-mode/page/remote/][LSP Mode - LSP support for Emacs]]

#+begin_src emacs-lisp :tangle yes
(lsp-register-client
    (make-lsp-client :new-connection (lsp-tramp-connection "clangd")
                     :major-modes '(c++-mode c-mode)
                     :remote? t
                     :server-id 'clangd-remote))
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'C)
#+end_src

** C++ (default LSP-server)
   :PROPERTIES:
   :ID:       6435cae0-700a-4263-966a-cbebc8f9ae25
   :CUSTOM_ID: 6435cae0-700a-4263-966a-cbebc8f9ae25
   :END:

Этот вариант настройки LSP-сервера для C++ выберет один из тех, что
установлен в системе, и будет с ним работать через lsp-mode. Это пока
единственный способ, который я нашел, чтобы подружить clangd с
lsp-mode (без eglot'а).

Поддержка подсказок и дополнений.

#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'company-mode)
(add-to-list 'company-backends 'company-capf)
#+end_src

Поддержка tree-sitter.

#+begin_src emacs-lisp :tangle yes
(my/treesit-install-language-grammar
 'cpp
 "https://github.com/tree-sitter/tree-sitter-cpp")

(mapc (apply-partially #'add-to-list 'auto-mode-alist)
      '(("\\.cpp\\'" . c++-ts-mode)
        ("\\.cc\\'" . c++-ts-mode)
        ("\\.c\\'" . c++-ts-mode)
        ("\\.hpp\\'" . c++-ts-mode)
        ("\\.h\\'" . c++-ts-mode)))

(mapc (apply-partially #'add-to-list 'major-mode-remap-alist)
      '((c-mode . c-ts-mode)
        (c++-mode . c++-ts-mode)))
#+end_src

Поддержка LSP. Установим LSP-сервер по-умолчанию (чтобы в итоге
работал clangd). Запретим неудобное автоформатирование, которое для
C++ больше мешает, чем помогает.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
    :ensure t)

(mapc (lambda (hook)
          ;; (add-hook hook 'lsp-clangd)
          (add-hook hook 'lsp-deferred)
          (add-hook hook 'my/--disable-lsp-auto-formatting))
      '(c-mode-hook c++-mode-hook c-ts-mode-hook c++-ts-mode-hook))

(defun my/--disable-lsp-auto-formatting ()
    (setq-local lsp-enable-on-type-formatting nil
                ;; indent-region-function nil
                ))
#+end_src

Влепим поддержку C++20 для org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(setq org-babel-C++-compiler "g++ -std=c++20")
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'C)
#+end_src

** C++. Clangd на удаленном сервере через docker (информация)

В параграфе [[id:871c5917-4bed-4369-9cb6-121582f33ede][C++ (clang on Egloy)]] уже есть настройки для подключения к
clangd на удаленной машине (хоть работает и без них). Здесь покажем,
как закинуть clangd на эту удаленную машину, если нет возможности
установить его напрямую из репозитория.

_Первый способ_ - это скачать готовый релиз отсюда:
- https://github.com/clangd/clangd/
На момент написания это был релиз 17.0.3:
- https://github.com/clangd/clangd/releases/tag/17.0.3
Далее копируем бинарь clangd из архива и надеемся, что будет работать.

_Второй способ_ (если первый не удался) - это воспользоваться
docker-контейнером. Вот вполне неплохой (но под Alpine - будут глючить magit и
projectile) - [[https://hub.docker.com/r/lspcontainers/clangd-language-server][lspcontainers/clangd-language-server]].

Устанавливается он на удаленной машине просто:
: docker pull lspcontainers/clangd-language-server
Информации по нему на hub.docker.com нет никакой, но и сложного там
ничего нет.

Запускаем контейнер (не забыв параметры "-it" - без них контейнер не
взлетит), подцепляем к нему директорию с проектами (внутри пусть
называется "/projects" - не принципиально):
: docker run -dit --restart=always --name=lsp-clangd -v /путь_к_директории_с_проектами:/projects lspcontainers/clangd-language-server
Теперь к контейнеру можно присоединяться и открывать там файлы,
утилиту clangd из контейнера TRAMP подцепит сам.

Теперь открываем С++-файлики через TRAMP:
: /ssh:имя_пользователя@адрес_сервера|docker:root@lsp-clangd:/projects/какой-то_проект/файл_проекта.cpp
LSP-сервер будет работать так же, как на локальной машине.

Для памяти: в /projects можно положить файлик =.clangd=, в котором
обозначить версию стандарта С++ и указать директории с файлами
заголовков, которые LSP-сервер может сам не найти:
: CompileFlags:
:   Add:
:     - -std=c++20
:     - -I/projects/проект_1/include
:     - -I/projects/проект_2/include
:     - -I/projects/проект_3/include
это хорошо помогает работать LSP-серверу.

На этом все.

** Clang-format. Форматирование C++

Работает просто:
1. Выделяем текст на C++ (желательно не одну строку из контекста).
2. Нажимаем "=" и функция =evil-indent= отформатирует текст согласно
   правилам в файлике .clang-format в ближайшей из родительских папок.

Еще работает =clang-format-buffer=.

*Подсказка:* Чтобы при автовыравнивании работали 4 пробела вместо
двух, нужно создать файлик [[~/.clang-format]] со следующим содержимым:
: ---
: ConstructorInitializerIndentWidth: 4
: ContinuationIndentWidth: 4
: IndentWidth:     4
: TabWidth:        4
: ...

Установим пакеты и пропишем соответствующие хуки.

#+begin_src emacs-lisp :tangle yes
(use-package clang-format+
    :ensure t
    :hook ((c-mode c++-mode c-ts-mode c++-ts-mode) . clang-format+-mode))
#+end_src

Поскольку по SSH эта штука работает до бесполезности плохо, то сделаем
ручное сравнение через ediff-buffers.

#+begin_src emacs-lisp :tangle yes
(defun my/clang-format-ediff-buffers ()
    (interactive)
    (when (member major-mode '(c-mode c++-mode c-ts-mode c++-ts-mode))
        (let ((buffer (current-buffer)))
            (my/ediff--store-window-configuration)
            (delete-other-windows)
            (shell-command (concat
                            "clang-format --style=file "
                            (file-name-nondirectory (buffer-file-name buffer))))
            (evil-window-move-far-left)
            (evil-window-right 1)
            (when my/evil
                (evil-force-normal-state))
            (c++-ts-mode)
            (let ((out-buffer (current-buffer)))
                (evil-window-left 1)
                (ediff-buffers buffer out-buffer)))))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "c f" '(:ignore t :which-key "Format Code")
               "c f c" '(my/clang-format-ediff-buffers :which-key "C++ clang-format"))
#+end_src

** Cmake

Для подсветки cmake-файлов установим пакет cmake-mode.

#+begin_src emacs-lisp :tangle yes
(use-package cmake-mode
    :ensure t)
#+end_src

#+RESULTS:

** Go

На минималках.

#+begin_src emacs-lisp :tangle yes
(use-package go-mode
    :ensure t)
(use-package ob-go
    :ensure t)
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'go)
#+end_src

** Groovy

#+begin_src emacs-lisp :tangle yes
(use-package groovy-mode
    :ensure t)
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'groovy)
#+end_src

** Java

Инструкцию по установке смотрим тут:
- [[https://github.com/emacs-lsp/lsp-java][lsp-java]].
На этой же странице есть ссылка на руководство:
- [[https://xpressrazor.wordpress.com/2020/11/04/java-programming-in-emacs/][Java Programming in Emacs]],
тут же есть поддержка spring: "Spring boot support (Experimental)".

Сперва позаботимся о поддержке lombok. Пока у меня не прошла его
автоматическая закачка в "m2", поэтому сохранил его в
репозитории. Копируем lombok.jar в кеш редактора.

#+begin_src emacs-lisp :tangle yes
(setq my/java-lombok-dir (file-name-concat (expand-file-name user-emacs-directory)
                                           "/.cache/java"))
(setq my/java-lombok (file-name-concat my/java-lombok-dir "/lombok.jar"))

(unless (file-exists-p my/java-lombok)
    (let ((lombok-src (file-name-concat my/config-dir "/lsp-saves/lombok.jar")))
        (make-directory my/java-lombok-dir t)
        (copy-file lombok-src my/java-lombok)))
#+end_src

Делаем установку.

#+begin_src emacs-lisp :tangle yes
(setq my/java-agent (concat "-javaagent:" my/java-lombok))

(use-package lsp-java
    :ensure t
    :hook ((java-mode java-ts-mode) . lsp)
    :config
    (when (member 'lsp-java-boot features)
        (require 'lsp-java-boot))
    (add-to-list 'lsp-java-vmargs my/java-agent))
#+end_src

Если скрипт ниже не сработает, при запуске LSP-сервера Emacs спросит
установить =jdtls=. Соглашаемся.

# #+begin_src emacs-lisp :tangle yes
# (lsp-ensure-server 'jdtls)
# #+end_src

Еще нужна работа с gradle-файлами.

#+begin_src emacs-lisp :tangle yes
(use-package gradle-mode
    :ensure t)
#+end_src

Поддержка tree-sitter.

#+begin_src emacs-lisp :tangle yes
(my/treesit-install-language-grammar 'java
                                     "https://github.com/tree-sitter/tree-sitter-java")

(add-to-list 'auto-mode-alist '("\\.java\\'" . java-ts-mode))

(use-package lsp-mode
    :hook ((java-mode java-ts-mode) . lsp-deferred)
    )
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'java)
#+end_src

** Java. Spring Boot

Чтобы установить Spring Boot, вводим следующие команды:
: curl -s "https://get.sdkman.io" | bash
: sdk install springboot
Пакет появится по пути: [[~/.sdkman/candidates/springboot/current/]].

(Надо еще как-то поставить STS4 - Spring Tool Suite. Как сказано тут,
он должен подтянуться при установке lsp-сервера jdtls.)
: yay -S spring-tool-suite

#+begin_src emacs-lisp :tangle yes
;; (require 'jsp-java-boot)
(use-package lsp-java
    :hook ((lsp-mode-hook . lsp-lens-mode)
           ((java-mode java-ts-mode) . lsp-deferred)
           ((java-mode java-ts-mode) . lsp-java-boot-lens-mode)))
#+end_src

** JavaScript/TypeScript

Информация о сервере и его установке смотрим тут:
[[https://emacs-lsp.github.io/lsp-mode/page/lsp-typescript/][LSP Mode - LSP support for Emacs. JavaScript/TypeScript (RECOMMENDED)]]

Нужно установить утилиты:
: sudo npm i -g typescript-language-server
: sudo npm i -g typescript
а также пакет =ts-ls= через lsp-install-server (сделано ниже).

#+begin_src emacs-lisp :tangle yes
(use-package js2-mode
    :ensure t)
(lsp-ensure-server 'jsts-ls)
(use-package typescript-mode
    :ensure t)
(lsp-ensure-server 'ts-ls)
#+end_src

И назначим соответствующие хуки...

#+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
(add-to-list 'interpreter-mode-alist '("node" . js2-mode))
(add-to-list 'auto-mode-alist '("\\.jsx?\\'" . js2-jsx-mode))
(add-to-list 'interpreter-mode-alist '("node" . js2-jsx-mode))
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))
;; (add-hook 'js-mode-hook 'js2-minor-mode)
(add-hook 'js-mode-hook 'my/--lsp-except-json)
(add-hook 'typescript-mode-hook 'my/--lsp-except-json)

(defun my/--lsp-except-json ()
    (unless (equal major-mode 'json-mode)
        (lsp)))
#+end_src

Позаботимся о вычислении org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(my/--register-org-babel 'js)
#+end_src

** Scala

LSP-сервер для Scala называется [[https://scalameta.org/metals/][Metals]]. Для компиляции Metals нужно
установить:
: sudo pacman -S jdk8-openjdk
: sudo pacman -S jdk11-openjdk
: sudo pacman -S jdk17-openjdk
На Arch его можно установить Metals из AUR-пакета:
: yay -S metals

Для начала установим режим [[https://github.com/hvesalai/emacs-scala-mode][scala-mode]] для Scala:

#+begin_src emacs-lisp :tangle yes
(use-package scala-mode
    :ensure t
    :interpreter
    ("scala" . scala-mode))
#+end_src

Соответствующий пакет для общения с Меtals - это [[https://github.com/emacs-lsp/lsp-metals][lsp-metals]]. Установим
его. Много комментариев в коде ниже взяты для памяти со страницы
lsp-сервера.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-metals
  :ensure t
  :custom
  ;; You might set metals server options via -J arguments. This might
  ;; not always work, for instance when metals is installed using
  ;; nix. In this case you can use JAVA_TOOL_OPTIONS environment
  ;; variable.
  (lsp-metals-server-args '(;; Metals claims to support range
                            ;; formatting by default but it supports
                            ;; range formatting of multiline strings
                            ;; only. You might want to disable it so
                            ;; that emacs can use indentation provided
                            ;; by scala-mode.
                            "-J-Dmetals.allow-multiline-string-formatting=off"
                            ;; Enable unicode icons. But be warned
                            ;; that emacs might not render unicode
                            ;; correctly in all cases.
                            "-J-Dmetals.icons=unicode"))
  ;; In case you want semantic highlighting. This also has to be
  ;; enabled in lsp-mode using `lsp-semantic-tokens-enable'
  ;; variable. Also you might want to disable highlighting of
  ;; modifiers setting `lsp-semantic-tokens-apply-modifiers' to `nil'
  ;; because metals sends `abstract' modifier which is mapped to
  ;; `keyword' face.
  (lsp-metals-enable-semantic-highlighting t))

(add-hook 'scala-mode-hook #'lsp)
#+end_src

# Позаботимся об org-babel блоках (в melpa этого пакета нет - надо
# позаботиться самому).
#
# #+begin_src emacs-lisp :tangle yes
# (let ((langs (cons '(scala . t) org-babel-load-languages)))
# (org-babel-do-load-languages 'org-babel-load-languages
#                              langs)
# #+end_src

* Финалочки

Здесь соберем все действия, которые нужно применить после установки
всего остального.

** Чистка статусной панели от всего лишнего (modeline)

Почистим строку состояния от лишних названий режимов. Сначала сносим
индикацию всех минорных режимов, потом восстанавливаем нужные из них.

#+begin_src emacs-lisp :tangle yes
(use-package diminish
    :ensure t)

(mapc 'diminish
      minor-mode-list)

(mapc 'diminish-undo
      '(persp-mode       ;; Название рабочего пространства.
        lsp-mode         ;; LSP
        ;; projectile-mode  ;; Название текущего проекта (длинновато).
        ))

;; (diminish 'lsp-mode " LSP")  ;; Сокращаем длинный текст.
#+end_src

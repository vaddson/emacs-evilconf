#+title: Конфигурация под ванильный Emacs
#+startup: content
#+startup: noindent

* Вводная

Уход с Doom на собственную конфигурацию.

Цель - использовать новые версии Emacs, которые Doom не успевает поддерживать.

Выгода - избавиться от хорошей, но тем не менее зависимости.

*Как установить?*
1. Склонировать этот проект настроек в директорию ~/.config (или просто завести
   там ссылку).
2. Скопировать файл init.el в директорию ~/.emacs.d/ .
3. Запустить Emacs.
4. Дождаться установки пакетов. По ходу установки отвечать на вопросы утвердительно.
(Настройка сразу подтянет все, что нужно для дальнейшей работы, и
больше в интернет обращаться не будет.)

*Как перейти c Vim (EVIL) на стандартную раскладку Emacs?*
1. В разделе "[[id:44f272c6-5f95-440f-8a1f-1766fe438feb][Включение Evil по всему редактору]]" установить
   переменную my/evil в nil:
   : (setq my/evil nil)
2. Это все. Все раскладки должны сохраниться, а префикс-лидер к ним по-умолчанию
   станет =Ctrl-s=.

* Отладка

Создаем буфер =*my/log-buffer*= и пишем в него логи.
Функция для записи - =(my/log TEXT)=.
Иногда нужно для отладки кода в этом документе.

#+begin_src emacs-lisp :tangle yes
(setq my/log-buffer (get-buffer-create "*my/log-buffer*"))

(defun my/log (text)
    (interactive "s")
    (with-current-buffer my/log-buffer
        (goto-char (point-max))
        (insert text)
        (insert "\n")
        (goto-char (point-max))))
#+end_src
  
* Общие параметры и переменные данной конфигурации

Здесь собраны параметры, значения которых будут далее использованы по всему
конфигу.

** Директория файлов конфигурации

Для дальнейшей работы в переменой =my/config-dir= устанавливается путь
к файлам настроек, т.е. путь к проекту с этим файлом.
Значение переменной my/config-dir задается в файле проекта [[./init.el][init.el]].

** Идентификация пользователя Emacs

Подпишемся, как просят. :)

"Some functionality uses this to identify you, e.g. GPG configuration,
email clients, file templates and snippets."

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Vaddson"
      user-mail-address "vaddson@vaddson.aaa")
#+end_src

** Включение Evil по всему редактору
   :PROPERTIES:
   :ID:       44f272c6-5f95-440f-8a1f-1766fe438feb
   :END:

Здесь выбирается режим редактирования.  По-умолчанию это Vim (EVIL).
Чтобы переключиться на Emacs, надо сбросить переменную =my/evil= в nil.

#+begin_src emacs-lisp :tangle yes
(setq my/evil t)  ;; For Vim keys.
;; (setq my/evil nil)  ;; For Emacs keys.
#+end_src

Префикс-лидер для Vim установлен в =пробел=, для Emacs - =Ctrl-s=.
Эти префиксы задаются в разделе "[[id:03e1b30d-e7f1-42ac-bc0b-71a9b2970fcf][General (назначение клавиш на помощь evil)]]".
   
* Подготовка к установке пакетов из репозиториев

Подцепим репозиторий melpa.

#+begin_src emacs-lisp :tangle yes
(require 'package)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
#+end_src

Рекомендуемые где-то кем-то действия перед загрузкой пакетов.  (Если
какой-то пакет по прошествии времени упорно не находится в
репозиториях, спасает ручной вызов функции =package-refresh-contents=.

#+begin_src emacs-lisp :tangle yes
;; disable automatic loading of packages after the init file
(setq package-enable-at-startup nil)
;; instead load them explicitly
(package-initialize)
;; refresh package descriptions
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

Пакеты будем цеплять через =use-package=. Установим его.

#+begin_src emacs-lisp :tangle yes
;;; use-package initialization
;;; install use-package if not already done
(if (not (package-installed-p 'use-package))
    (progn (package-refresh-contents)
           (package-install 'use-package)))
;;; use-package for вид GUI
#+end_src

Не будем кошмарить логом с ошибками, если там только предупреждения.

#+begin_src emacs-lisp :tangle yes
(setq warning-minimum-level :error)
#+end_src

* Пока редактор загружается, поправим ему внешний вид

** Меню и панель инструментов (menu and toolbar)

Скроем лишние элементы управления такие, как меню, полосы прокрутки и
прочее. Меню по-прежнему остается доступно по клавише =F10=.

#+begin_src emacs-lisp :tangle yes
(menu-bar-mode     -1)  ;; Отключаем графическое меню.
(tool-bar-mode     -1)  ;; Отключаем tool-bar.
(scroll-bar-mode   -1)  ;; Отключаем полосы прокрутки.
#+end_src

** Красивые темы и установка темы по-умолчанию
   :PROPERTIES:
   :ID:       40986685-fc80-45b7-ab77-4cac074fea9f
   :END:

Загружаем красивые темы и устанавливаем одну из них.
Стараемся успеть до загрузки всех остальных настроек.

#+begin_src emacs-lisp :tangle yes
(use-package doom-themes
    :ensure t
    :config
    (load-theme 'doom-one t)
    ;; (load-theme 'doom-gruvbox-light t)
    ;; (load-theme 'doom-gruvbox t)
    ;; (load-theme 'doom-molokai t)
    )
#+end_src

* Полезные пакеты, вытащенные из сторонних проектов

Здесь импортируются удобства, вытащенные из сторонних конфигураций Emacs.

** Spacemacs

Библиотека, вытянутая из Spacemacs. Так и тащу ее за собой через Doom. :)

#+begin_src emacs-lisp :tangle yes
(load-file (concat my/config-dir "/funcs.el"))
#+end_src

* Среда

** Сохранение состояния для Desktop

Запретим сохранение среды, чтобы не мешалось.

#+begin_src emacs-lisp :tangle yes
(setq desktop-save-mode nil)
#+end_src

** Удаление файлов и бэкапы

Файлы удаляем только в корзину.

#+begin_src emacs-lisp :tangle yes
(setq delete-by-moving-to-trash t)
#+end_src

А бэкапы файлов запрещаем. Очень неудобно они называются, да и не нужны мне.

#+begin_src emacs-lisp :tangle yes
(setq make-backup-files nil)
(setq auto-save-default nil)
#+end_src

** Звуковой сигнал (типа "гудок")

Вот ни разу не был нужен. Отключаем.

#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+end_src

** Сборщик мусора (GC)

Добыл из Emacs-чатика настройки для сборщика мусора.  Там порог
выворачивается в максимум: меньше экономии, больше скорость работы.
Попробуем.

#+begin_src emacs-lisp :tangle yes
(use-package gcmh
	:ensure t
	:config
	(gcmh-mode 1)
	(setf gc-cons-threshold gcmh-high-cons-threshold)
	;; Release severe GC strategy before the user restart to working
	(add-hook 'pre-command-hook #'gcmh-set-high-threshold)
	(add-hook 'post-command-hook #'gcmh-register-idle-gc))
#+end_src

* Evil. Режим редактирования
  :PROPERTIES:
  :ID:       cc78f980-e959-4169-b667-4b40109e08a7
  :END:

** Установка и настройка

Сразу ставим пакет =evil= и включаем эмуляцию редактора Vim. Здесь же
ставим замену табуляций на пробелы для команды =evil-indent=.

При необходимости переключение между Evil и Emacs режимами в пределах
одного буфера можно делать клавишами =Ctrl-z=.

#+begin_src emacs-lisp :tangle yes
(use-package evil
    :ensure t
    :init
    ;; (setq evil-undo-system 'undo-tree)
    (setq evil-undo-system 'undo-redo)
    (setq evil-want-keybinding nil)
    :config
    (setq-default indent-tabs-mode nil)
    (setq evil-indent-convert-tabs t))
#+end_src

Включаем Evil, если [[id:44f272c6-5f95-440f-8a1f-1766fe438feb][на старте]] это было заказано.

#+begin_src emacs-lisp :tangle yes
(when my/evil
    (evil-mode))
#+end_src

Устанавливаем evil-клавиши для всего, что есть.

Устанавливаем сразу все карты клавиш функцией =evil-collection-init=.
Список того, что там еще есть:
- evil-collection-bm-setup
- evil-collection-calendar-setup
- evil-collection-calendar-setup-org-bindings
- evil-collection-comint-setup
- evil-collection-compile-setup
- evil-collection-custom-setup
- evil-collection-debug-setup
- evil-collection-diff-mode-setup
- evil-collection-dired-setup
- evil-collection-edebug-setup
- evil-collection-ediff-setup
- evil-collection-eglot-setup
- evil-collection-elisp-mode-setup
- evil-collection-elisp-refs-setup
- evil-collection-epa-setup
- evil-collection-eshell-setup
- evil-collection-eshell-setup-keys
- evil-collection-finder-setup
- evil-collection-flycheck-setup
- evil-collection-flymake-setup
- evil-collection-grep-setup
- evil-collection-help-setup
- evil-collection-helpful-setup
- evil-collection-ibuffer-setup
- evil-collection-imenu-setup
- evil-collection-indent-setup
- evil-collection-info-setup
- evil-collection-ivy-setup
- evil-collection-log-edit-setup
- evil-collection-magit-section-setup
- evil-collection-magit-setup
- evil-collection-magit-todos-setup
- evil-collection-man-setup
- evil-collection-markdown-mode-setup
- evil-collection-org-roam-setup
- evil-collection-org-setup
- evil-collection-package-menu-setup
- evil-collection-popup-setup
- evil-collection-python-setup
- evil-collection-setup
- evil-collection-sh-script-setup
- evil-collection-so-long-setup
- evil-collection-vc-git-setup
- evil-collection-view-setup
- evil-collection-wgrep-setup
- evil-collection-which-key-setup
- evil-collection-xref-setup

#+begin_src emacs-lisp :tangle yes
(use-package evil-collection
    :ensure t
    :config
    (evil-collection-init))
#+end_src

Догружаем остальной ворох пакетов для evil.

#+begin_src emacs-lisp :tangle yes
(use-package evil-args
    :ensure t)
(use-package evil-easymotion
    :ensure t)
(use-package evil-embrace
    :ensure t)
(use-package evil-escape
    :ensure t)
(use-package evil-exchange
    :ensure t)
(use-package evil-indent-plus
    :ensure t)
(use-package evil-lion
    :ensure t)
(use-package evil-nerd-commenter
    :ensure t)
(use-package evil-numbers
    :ensure t)
(use-package evil-snipe
    :ensure t)
(use-package evil-surround
    :ensure t)
(use-package evil-textobj-anyblock
    :ensure t)
(use-package evil-vimish-fold
    :ensure t)
(use-package evil-visualstar
    :ensure t)
#+end_src

** General (назначение клавиш на помощь evil)
   :PROPERTIES:
   :ID:       03e1b30d-e7f1-42ac-bc0b-71a9b2970fcf
   :END:

Установка клавиш leader (=пробел= или =Alt-m=) и localleader (с добавкой =m= к лидеру).
Для режима редактирования Emacs лидеры переопределяются в =Ctrl-s=.

#+begin_src emacs-lisp :tangle yes
(if my/evil
    (setq my/leader "SPC"
          my/leader-non-normal "M-m"
          my/localleader "SPC m"
          my/localleader-non-normal "M-m m")
    (setq my/leader "C-s"
          my/leader-non-normal "C-s"
          my/localleader "C-s m"
          my/localleader-non-normal "C-s m"
          my/evil-prefix "C-s C-s"))
#+end_src

Для определения клавиш удобнее переключиться на пакет =general=.
Заодно для некоторых раскладок отменим клавишу пробела.

#+begin_src emacs-lisp :tangle yes
(use-package general
    :ensure t
    :config
    (evil-define-key 'normal dired-mode-map (kbd my/leader) nil))
#+end_src

Определим на основе general-define-key свои функции назначения клавиш.
- Функция =my/leader= будет назначать клавишам префикс с
  лидером (=пробел= или =Alt-m=).
- Функция =my/localleader= будет назначать клавишам префикс с
  локальным лидером (=пробел m= или =Atl-m m=).
- Функция =my/evil-define-key= будет назначать клавиши в режимах EVIL
  без префикса, как то: normal, visual, insert, replace, moniton, emacs.

#+begin_src emacs-lisp :tangle yes
(defmacro my/leader-def (states keymaps &rest args)
    `(my/--define-key my/leader
                      my/leader-non-normal
                      ,states
                      ,keymaps
                      ,@args))

(defmacro my/localleader-def (states keymaps &rest args)
    `(my/--define-key my/localleader
                      my/localleader-non-normal
                      ,states
                      ,keymaps
                      ,@args))

(defmacro my/evil-define-key (states keymaps &rest args)
    (if my/evil
        (progn
            (setq states (or states
                             '(normal visual insert replace moniton emacs)))
            `(general-define-key :states ',states
                                 :keymaps ',keymaps
                                 ,@args))
        `(general-define-key :keymaps ',keymaps
                             :prefix my/evil-prefix
                             ,@args)))

(defmacro my/--define-key (leader leader-non-normal states keymaps &rest args)
    (if my/evil
        (progn
            (setq states (or states
                             '(normal visual insert replace moniton emacs)))
            `(general-define-key :states ',states
                                 :keymaps ',keymaps
                                 :prefix ,leader
                                 :non-normal-prefix ,leader-non-normal
                                 ,@args))
        `(general-define-key :keymaps ',keymaps
                             :prefix ,leader
                             ,@args)))

(unless my/evil
    (general-define-key my/evil-prefix '(:ignore t :which-key "normal")))
#+end_src

Назначим некоторые полезные сочетания клавиш.
Ниже это вычисление LISP-выражения, введенного с клавиатуры.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               ";" '(pp-eval-expression :which-key "Eval LISP expression"))
#+end_src

** Настройка поведения клавиш для evil-mode, как в Vim.

Перемещение по строкам и внутри них хоть и сделано в evil-mode, но
работает как-то все равно с огрехами (или мне так кажется). Поэтому
сделаем костыль, в котором четко определим, как должна работать
навигация.

Здесь включается, как в Vim, реакция на "dd", "V" и т.п.. "Допил
напильником" ниже.

#+begin_src emacs-lisp :tangle yes
(setq evil-respect-visual-line-mode nil)
#+end_src

Перемещение курсора, как в Vim, независимо от `global-visual-mode' и
прочих "удобств".

#+begin_src emacs-lisp :tangle yes
(define-key evil-normal-state-map (kbd "j") #'evil-next-line)
(define-key evil-visual-state-map (kbd "j") #'evil-next-line)
(define-key evil-normal-state-map (kbd "g j") #'evil-next-visual-line)
(define-key evil-visual-state-map (kbd "g j") #'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "k") #'evil-previous-line)
(define-key evil-visual-state-map (kbd "k") #'evil-previous-line)
(define-key evil-normal-state-map (kbd "g k") #'evil-previous-visual-line)
(define-key evil-visual-state-map (kbd "g k") #'evil-previous-visual-line)
(define-key evil-normal-state-map (kbd "$") #'evil-end-of-line)
(define-key evil-visual-state-map (kbd "$") #'evil-end-of-line)
(define-key evil-normal-state-map (kbd "^") #'evil-first-non-blank)
(define-key evil-visual-state-map (kbd "^") #'evil-first-non-blank)
(define-key evil-normal-state-map (kbd "0") #'evil-beginning-of-line)
(define-key evil-visual-state-map (kbd "0") #'evil-beginning-of-line)

(define-key evil-normal-state-map (kbd "A") #'my/evil-append-line)
(defun my/evil-append-line ()
    (interactive)
    (evil-end-of-line)
    (evil-append 1))

(define-key evil-normal-state-map (kbd "I") #'my/evil-insert-line)
(defun my/evil-insert-line ()
    (interactive)
    (evil-first-non-blank)
    (evil-insert 1))

(define-key evil-normal-state-map (kbd "D") #'my/evil-delete-line)
(defun my/evil-delete-line ()
    (interactive)
    (save-excursion
        (let ((beg (point))
              (end))
            (evil-end-of-line)
            ;; (setq end (point))
            (setq end (min (buffer-end +1) (+ 1 (point))))
            (evil-delete-line beg end))))

(define-key evil-normal-state-map (kbd "C") #'my/evil-change-line)
(defun my/evil-change-line ()
    (interactive)
    (save-excursion
        (let ((beg (point))
              (end))
            (evil-end-of-line)
            (setq end (min (buffer-end +1) (+ 1 (point))))
            (evil-change beg end))))

(define-key evil-normal-state-map (kbd "S") #'my/evil-change-whole-line)
(defun my/evil-change-whole-line ()
    (interactive)
    (let ((beg)
          (end))
        (evil-first-non-blank)
        (setq beg (point))
        (evil-end-of-line)
        (setq end (min (buffer-end +1) (+ 1 (point))))
        (evil-change beg end)))
#+end_src

* Внешний вид UI и GUI

** Автоматическая установка шрифтов

Для маленького монитора в 14" удобнее взять шрифт побольше.  Поскольку
отображение текста в Emacs не подстраивается к текущему DPI, напишем
следующий костыль.

Для этого установим в редактор два шрифта: обычный и побольше.
Пример:
: (setq my/global-font "Droid Sans Mono-10")
Глобальный шрифт (обычный) будем держать в переменной =my/global-font=,
а шрифт побольше - в переменной =my/global-font-inc=.

#+begin_src emacs-lisp :tangle yes
(setq my/global-font "Liberation Mono-9")
(setq my/global-font-inc "Liberation Mono-10")
#+end_src

Прописываем шрифты глобально в редактор.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'default-frame-alist `(font . ,my/global-font))
;; (add-to-list 'default-frame-alist `(font . ,my/global-font-inc))
;; (set-face-attribute 'default t :font my/global-font :weight 'semi-light)
;; (set-face-attribute 'default nil :font my/global-font :weight 'semi-light)
#+end_src

Напишем функцию, которая в указанном (или активном) фрейме в
зависимости от ширины экрана выбирает один из двух шрифтов.

#+begin_src emacs-lisp :tangle yes
(defun my/select-frame-font-for-monitor (frame font font-inc)
    (if (my/small-monitor-p frame)
        (set-frame-font font-inc frame t)
        (set-frame-font font t)))

(defun my/small-monitor-p (frame)
    (let* ((monitor-attrs (frame-monitor-attributes frame))
           (mm-width (cl-second (assoc 'mm-size monitor-attrs))))
        (and mm-width
             (<= mm-width 310))))
#+end_src

Теперь с помощью полученной функции обновляем шрифт в активном фрейме.
В случае запуска демоном установку шрифта ниже надо пропустить.

#+begin_src emacs-lisp :tangle yes
(unless (daemonp)
    (my/select-frame-font-for-monitor nil my/global-font my/global-font-inc))
#+end_src

При создании фрейма навесим обработчик этого события, чтобы размер
шрифта выровнять автоматически.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-make-frame-functions
          (lambda (frame)
              (my/select-frame-font-for-monitor frame
                                                my/global-font
                                                my/global-font-inc)))
#+end_src

Не всегда получится правильно угадать и выставить шрифт
автоматически. Так что предусмотрим "ручное управлене".

#+begin_src emacs-lisp :tangle yes
(defun my/correct-font-in-current-frame ()
    (interactive)
    (my/select-frame-font-for-monitor nil
                                      my/global-font
                                      my/global-font-inc))

(my/leader-def nil 'override
               "e" '(:ignore t :which-key "env"))
(my/leader-def nil 'override
               "e d" #'my/correct-font-in-current-frame)
#+end_src

** Выбор случайной картинки для стартового логотипа
   :PROPERTIES:
   :ID:       3a0a5684-d453-4d37-bd1a-0a65ae9591ef
   :END:

В репозитории этого конфига есть папочка с картинками. В нее можно добавлять
новые картинки, и на старте Emacs одна из них случайно будет помещена на
логотип. Обозначим эту директорию.

#+begin_src emacs-lisp :tangle yes
(setq my/dashboard-banner-dir (concat my/config-dir "/banners"))
#+end_src

Теперь напишем функцию выбора случайной картинки.

#+begin_src emacs-lisp :tangle yes
(defun my/select-random-banner ()
    (let* ((pictures (directory-files my/dashboard-banner-dir nil ".png"))
           (pictures-sorted (sort pictures #'string-lessp))
           (filename (nth (random (length pictures))
                          pictures-sorted)))
        (concat my/dashboard-banner-dir "/" filename)))
#+end_src

** Панель на старте с логотипом (dashboard)

Заменим начальный экран более модной панелью.
Картинку логотипа [[id:3a0a5684-d453-4d37-bd1a-0a65ae9591ef][выберем случайно]].

#+begin_src emacs-lisp :tangle yes
(use-package dashboard
    :ensure t
    :config
    (setq dashboard-center-content t
          dashboard-startup-banner (my/select-random-banner)
          initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    (dashboard-setup-startup-hook))
#+end_src

Определим, какие секции будут видны на начальном экране.
Пусть это будут ранее открытые проекты и файлы.

#+begin_src emacs-lisp :tangle yes
(setq dashboard-items '((projects . 6)
                        (recents .  6)))
#+end_src

** Мигание курсора

Выключаем мигание курсора.

#+begin_src emacs-lisp :tangle yes
(blink-cursor-mode 0)
#+end_src

** Прозрачность

Делаем три уровня прозрачности редактора:
1. непрозрачный,
2. слегка прозрачный,
3. достаточно прозрачный (не пользуюсь, но, может, пригодится). :)

#+begin_src emacs-lisp :tangle yes
(defvar my/transparency-level 0
    "Transparence level for Emacs environment. Values: 0, 1 or 2.")

(defun my/change-transparency ()
    "Toggles transparency of Emacs between 3 settings (none, mild, moderate)."
    (interactive)
    (setq my/transparency-level (mod (+ 1 my/transparency-level) 3))
    (my/set-transparency))

(defun my/set-transparency (&optional frame)
    "Set current transparency from my/transparency-level variable."
    (interactive)
    (let ((true-frame (or frame (selected-frame))))
        (pcase my/transparency-level
            (0
             (set-frame-parameter true-frame 'alpha '(100 . 100)))
            (1
             (set-frame-parameter true-frame 'alpha '(85 . 85)))
            (2
             (set-frame-parameter true-frame 'alpha '(65 . 65))))))
#+end_src

Если открылся новый фрейм, то восстановим его прозрачность.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-make-frame-functions #'my/set-transparency)
#+end_src

Смену уровней прозрачности вешаем на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "t" '(:ignore t :which-key "toggles"))
(my/leader-def nil 'override
               "t t" #'my/change-transparency
               "t T" #'my/set-transparency)
#+end_src

** Настройка статусной панели (modeline)

Установим в панели отображение позиции курсора.

#+begin_src emacs-lisp :tangle yes
(setq mode-line-position (list "(%l,%c)"))
#+end_src

** Показ объекта внутри которого находится курсор (header-line)

Часто бывает нужно посмотреть, в каком объекте находится курсор. Это
может быть функция из программного кода или заголовок в org-mode или
что-то еще.

Сделаем такую строку.

#+begin_src emacs-lisp :tangle yes
(defun my/show-header-line ()
    (setq-default header-line-format
                  '((which-func-mode ("" which-func-format " ")))))

(defun my/hide-header-line ()
    (setq-default header-line-format nil))

(which-function-mode)
(my/show-header-line)
(setq mode-line-misc-info
      ;; We remove Which Function Mode from the mode line, because it's mostly
      ;; invisible here anyway.
      (assq-delete-all 'which-function-mode mode-line-misc-info))
#+end_src

Цвет текста в header-line перенастроим, поскольку по-умолчанию он слишком слепой.

Type [M-x list-faces-display] to see all colors.

#+begin_src emacs-lisp :tangle yes
(set-face-foreground 'which-func            "#7f9fff" )
#+end_src

** Установка текста в заголовке основного окна (фрейма)

Если размещать работу по разным фреймам, то скоро можно запутаться, в
каком из них что.  Здесь спасает текст в заголовке фрейма.  Нужно
иметь возможность назначать текст окна интерактивно.

Определим для этого соответствующую функцию. Неизменная часть
заголовка будет жить в переменной =my/application-name=.

#+begin_src emacs-lisp :tangle yes
(setq my/application-name "GNU Emacs")

(defun my/make-title-bar-text (text)
    (concat text " - " my/application-name))

(defun my/set-title-bar (text)
    "Set title bar like: '<my-text> - <app-name>'.
Find application name in my/application-name variable."
    (let ((frame-text (my/make-title-bar-text text)))
        (set-frame-name frame-text)
        frame-text))

(defun my/set-title-bar-interactive (text)
    "Interactive set title bar. Type 'M-x RET my/set-title-bar-interactive RET some-text'"
    (interactive (list (read-string "Enter text for title bar: ")))
    (my/set-title-bar text)
    )
#+end_src

И повесим назначение заголовка окну на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "n" '(:ignore t :which-key "notes"))
(my/leader-def nil 'override
    "n i" '(my/set-title-bar-interactive :which-key "Set frame title"))
#+end_src

Ниже устанавливаем формат заголовка по умолчанию.

#+begin_src emacs-lisp :tangle yes
(setq frame-title-format
      '(multiple-frames "%b"
                        ("" "%b - " my/application-name)))
#+end_src

** Подсветка кодов цвета соответствующим цветом (rainbow mode)

Здесь на постоянку устанавливается подсветка фона у текстовых значений
цветов, например: #aa0000, #00aa00, #0000aa

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode
	:ensure t
	:config
	(define-globalized-minor-mode global-rainbow-mode rainbow-mode
		(lambda () (rainbow-mode 1))))
#+end_src

Можно выставить подсветку цветов везде по-умолчанию через вызов
=(global-rainbow-mode 1)=. Однако, она не дружит с некоторыми более
полезными режимами, такими как org-agenda. Так что оставим код ниже
только для примера.

#+begin_example emacs-lisp :tangle yes
(global-rainbow-mode 1)  ; Remove comment for turn on on start Emacs.
#+end_example

Лучше поставим режим rainbow-mode только для программного и org
режимов.

#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook (lambda () (rainbow-mode 1)))
(add-hook 'org-mode-hook (lambda () (rainbow-mode 1)))
#+end_src

** Отказываемся от диалоговых окон

Ибо не по emacs'ерски это. :)

#+begin_src emacs-lisp :tangle yes
(setq use-dialog-box nil)
#+end_src

** Тильды в конце буффера

В Vim было удобно видеть тильды "~" в конце буфера. Установим их.

#+begin_src emacs-lisp :tangle yes
(use-package vi-tilde-fringe
    :ensure t
    :config
    (global-vi-tilde-fringe-mode 1))
#+end_src

** Увеличение и уменьшение шрифта в окне

Нужно в основном во время демонстраций экрана.

#+begin_src emacs-lisp :tangle yes
(require 'face-remap)
(text-scale-mode 1)
#+end_src

Горячие клавиши, как в любом редакторе или консоли.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-=") #'text-scale-increase)
(global-set-key (kbd "C--") #'text-scale-decrease)
#+end_src

** Настройка окна компиляции (compilation)

Для окна компиляции выставим настройки:
- Гасить процесс компиляции перед началом нового.
- Запрос на сохранение всех буферов при старте компиляции.
- Останавливать прокрутку в окне компиляции при первой строчке с ошибкой.
- Цветная раскраска текста.

#+begin_src emacs-lisp :tangle yes
(require 'compile)

(setq compilation-always-kill t       ; kill compilation process before starting another
      compilation-ask-about-save t    ; save all buffers on `compile'
      compilation-scroll-output 'first-error)
(add-hook 'compilation-filter-hook #'my/apply-ansi-color-to-compilation-buffer)

(defun my/apply-ansi-color-to-compilation-buffer ()
    (with-silent-modifications
        (ansi-color-apply-on-region compilation-filter-start (point))))
#+end_src

* Демоны

** Задание цветовых тем для известных демонов

Мне удобно для работы запускать несколько демонов Emacs.
Визуально их различаю цветовыми темами. Например:
- демон "notes" - теплая тема,
- демон "dev"   - холодная тема,
- демон "rest"  - холодная тема с прозрачностью.
Так сложнее визуально перепутать клиентские фреймы для каждого из
демонов.

Установим каждому демону тему на старте.

#+begin_src emacs-lisp :tangle yes
(pcase (daemonp)
    ("notes"
     (load-theme 'doom-molokai t))

    ("dev"
     (load-theme 'doom-one t))

    ("rest"
     (setq my/transparency-level 1)
     (load-theme 'doom-one t)))
#+end_src

А тема по-умолчанию задается [[id:40986685-fc80-45b7-ab77-4cac074fea9f][выше]].

** Ярлыки для работы с известными демонами

Клиентов к демонам запускаю по desktop-ярлыкам из
[[/usr/share/applications/]].

Если при вызове клиента демон не был запущен, то он запускается, так
что на старте системы думать о Emacs-демонах не приходится. Для этого
есть параметр "-a":
: $ emacsclient -a "" -c -s my_daemon_name

Пример ярлыка для клиента от демона "notes" (файл emacs_notes.desktop):

#+begin_src conf
[Desktop Entry]
Name=Emacs Notes
GenericName=Text Editor
Comment=Edit text
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -a "" -c -s notes
Icon=emacs
Type=Application
Terminal=false
Categories=Development;TextEditor;
StartupWMClass=Emacs
Keywords=Text;Editor;
#+end_src

* Регистры и операции с ними

** Общий буфер обмена для Emacs и ОС

Запретим для evil. Раздельные с ОС буфера обмена здесь удобней
(т.е. сделаем, как в оригинальном Vim).

#+begin_src emacs-lisp :tangle yes
(when my/evil
    (setq x-select-enable-clipboard nil))
#+end_src

** Быстрая работа с регистрами `+' и `"'

Часто нужно скопировать содержимое буфера ОС в буфер Emacs.  Тут будем
пользоваться регистрами "vim", предоставляемыми через evil-mode.

Ниже код копирует содержимое регистра `+' в регистр `"' по =Ctrl-,=.
Далее можно пользоваться =Ctrl-y= для вставки.

#+begin_src emacs-lisp :tangle yes
(defun my/copy-system-clipboard-to-emacs ()
    (interactive)
    (let ((text (evil-get-register ?+)))
        (evil-set-register ?\" text)
        (minibuffer-message (concat "Register `\"': " text))))

(global-set-key (kbd "C-,") #'my/copy-system-clipboard-to-emacs)
#+end_src

Аналогично в обратную сторону, из регистра `"' в `+' и `*'.

#+begin_src emacs-lisp :tangle yes
(defun my/copy-emacs-clipboard-to-system ()
    (interactive)
    (let ((text (evil-get-register ?\")))
        (evil-set-register ?+ text)
        (evil-set-register ?* text)
        (minibuffer-message (concat "Registers `+' and `*': " text))))

(global-set-key (kbd "C-;") #'my/copy-emacs-clipboard-to-system)
#+end_src

* Редактирование текста и интерфейс к нему

** Отмена изменений на основе дерева (undo-tree)

Очень удобное окошко с деревом изменений по буферу.
Сразу отменим запись дерева изменений в файл.

/TODO: Пока настроено плохо - все в линеечку. Буду разбираться, что не так./

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
	:ensure t
	:config
    (setq undo-tree-auto-save-history nil)
	(global-undo-tree-mode 1))
#+end_src

Чтобы в окошке с деревом изменений не помнить про клавишу "d"
(показать diff изменеий), включим ее эффект сразу при показе этого
окна.

#+begin_src emacs-lisp :tangle yes
(defun my/undo-tree-visualize ()
	(interactive)
	(undo-tree-visualize)
	(undo-tree-visualizer-toggle-diff))
#+end_src

И переопределим предустановленные из пакета клавиши "Ctrl-x u".

#+begin_src emacs-lisp :tangle yes
(define-key undo-tree-map (kbd "C-x u") #'my/undo-tree-visualize)
#+end_src
   
** Прокручивание текста

Ставим прокручивание текста мышкой по три строки, клавишами по одной и
забываем об этом.

#+begin_src emacs-lisp :tangle yes
(setq mouse-wheel-scroll-amount '(3 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+end_src

Прокрутка курсором по одной строке.

#+begin_src emacs-lisp :tangle yes
(setq scroll-step 1
      scroll-preserve-screen-position t  ;; nil
      scroll-margin 0  ;; 0
      scroll-conservatively 10  ;; 0
      maximum-scroll-margin 0.0  ;; 0.25
      scroll-up-aggressively 0.0   ;; nil
      scroll-down-aggressively 0.0)  ;; nil
#+end_src

Начиная с Emacs 29, имеем плавную прокрутку по пикселям. Наконец-то
картинки при прокрутке не скачут на весь размер (ну, почти).

#+begin_src emacs-lisp :tangle yes
(when (fboundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode 1))
#+end_src

** Avy. Перемещение по всему редактору

Все любят =Avy=. Этот пакет позволяет перемещать курсор на любую
позицию видимого в редакторе текста. Текст этот может быть как в
активном окне, так и в любом другом.

Поставим пакет и назначим переход по двум символам или
последовательности символов.

#+begin_src emacs-lisp :tangle yes
(use-package avy
    :ensure t
    :config
    (my/evil-define-key '(norman visual) 'override
                        "g s s" #'evil-avy-goto-char-timer
                        "g s /" #'evil-avy-goto-char-2))
#+end_src

** Нумерация строк

В =evil-mode= самая удобная нумерация строк - относительная.  Выставим
по-умолчанию относительную нумерацию, если [[id:44f272c6-5f95-440f-8a1f-1766fe438feb][редактор запущен в режиме EVIL]],
или оставим привычную нумерацию в противном случае.

Зададим в переменной нумерацию строк по-умолчанию.

#+begin_src emacs-lisp :tangle yes
(if my/evil
    (setq my/display-line-numbers 'relative)
    (setq my/display-line-numbers 'value))
#+end_src

Определим функции переключения нумерации строк.
Действовать будем через локальные переменные буферов
~display-line-numbers~.

#+begin_src emacs-lisp :tangle yes
(defun my/display-line-numbers (&optional arg)
    (interactive)
    (cond ((not arg)
           (if display-line-numbers
               (setq-local display-line-numbers nil)
               (setq-local display-line-numbers my/display-line-numbers)))
          ((or (equal t arg) (> arg 0))
           (setq-local display-line-numbers my/display-line-numbers))
          ((< arg 0)
           (setq-local display-line-numbers nil))))

(defun my/display-next-line-numbers ()
    (interactive)
    (pcase display-line-numbers
        (`relative
         (setq-local display-line-numbers 'value))
        (`value
         (setq-local display-line-numbers nil))
        (_
         (setq-local display-line-numbers 'relative))))
#+end_src

Теперь покажем номера строк для текстовых и программных режимов.

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook (lambda () (my/display-line-numbers 1)))
(add-hook 'prog-mode-hook (lambda () (my/display-line-numbers 1)))
(add-hook 'org-mode-hook (lambda () (my/display-line-numbers 1)))
#+end_src

Горячие клавиши смены показа нумерации строк.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t l" '(my/display-next-line-numbers
            :which-key "Change line numbers")
    "t L" '((lambda ()
                (interactive)
                (my/display-line-numbers 1))
            :which-key "Default line numbers"))
#+end_src

** Wgrep. Отслеживаем не сохраненное во всех буферах

При выходе из редактора тот предупредит о не сохраненных буферах.

#+begin_src emacs-lisp :tangle yes
(use-package wgrep
    :ensure t)
#+end_src

** Автоотступ (indent)

Четыре пробела - лучший отступ.

#+begin_src emacs-lisp :tangle yes
(setq-default tab-width 4) ;; ширина табуляции - 4 пробельных символа
(setq-default c-basic-offset 4)
(setq-default standart-indent 4) ;; стандартная ширина отступа - 4 пробельных символа
(setq-default plantuml-indent-level 4)
(setq-default lisp-body-indent 4) ;; сдвигать lisp-выражения на 4 пробельных символа
(setq lisp-indent-function 'common-lisp-indent-function)
#+end_src

** ESC-кодирование для работы с URL

Часто бывает нужно кодировать и раскодировать URL, например, как в Python:

#+begin_example python
from urllib.parse import quote, unquote
#+end_example

Сделаем аналоги функций =quote= и =unquote= из Python'а:
- =my/quote-reion=
- =my/unquote-reion=
Они интерактивны и работают с выделенными в тексте URL'ами.

#+begin_src emacs-lisp :tangle yes
(defun my/quote-url (url-text)
    "Quote URL to esc-sequence."
    (url-encode-url url-text))

(defun my/unquote-url (url-text)
    "Unquote URL from esc-sequence to UTF-8."
    (decode-coding-string (url-unhex-string url-text) 'utf-8))

(defun my/quote-region ()
    "Quote text (like URL) in region."
    (interactive)
    (let ((beg (region-beginning))
          (end (region-end))
          (text))
        (setq text (buffer-substring-no-properties beg end))
        (kill-region beg end)
        (insert (my/quote-url text))))

(defun my/unquote-region ()
    "Unquote text (like URL) in region."
    (interactive)
    (let ((beg (region-beginning))
          (end (region-end))
          (text))
        (setq text (buffer-substring-no-properties beg end))
        (kill-region beg end)
        (insert (my/unquote-url text))))
#+end_src

Горячие клавиши не назначал. Пользуемся =M-x=.

** Более привычная раскладка клавиш для evil-mode (ближе к Vim и консоли)

Переносим привычные клавиши передвижения, удаления и ввода и в Emacs тоже.

#+begin_src emacs-lisp :tangle yes
(define-key evil-insert-state-map (kbd "C-j") (kbd "RET"))
(define-key evil-replace-state-map (kbd "C-j") (kbd "RET"))
(define-key evil-normal-state-map (kbd "C-j") (kbd "j"))
(define-key evil-visual-state-map (kbd "C-j") (kbd "j"))
(define-key evil-insert-state-map (kbd "C-h") (kbd "<backspace>"))
(define-key evil-replace-state-map (kbd "C-h") (kbd "<backspace>"))
(define-key evil-normal-state-map (kbd "C-h") (kbd "h"))
(define-key evil-visual-state-map (kbd "C-h") (kbd "h"))
#+end_src

А удалению символа влево - особое место. Удобно при наборе пути в Ivy или Helm.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-h") 'delete-backward-char)
#+end_src

После такого надо реанимировать вызов части полезных функций из Emacs.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "h c" #'helpful-command)
(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

** Переключение раскладки клавиатуры

Внутри Vim и evil-mode много удобней иметь внутренне переключение
раскладки клавиатуры. Такое переключение позволяет пользоваться
командами модального режима вне зависимости от состояния раскладки. И,
хотя, переключение в evil-mode работает хуже, чем в Vim, все равно оно
того стоит.

#+begin_src emacs-lisp :tangle yes
(set-input-method 'russian-computer)
(global-set-key (kbd "C-c d") #'toggle-input-method)
#+end_src

Во время поиска в Ex-режиме нельзя задать аккорд, поэтому переключение
раскладки в Ex ставим на сокращенное сочетание =C-d=. (Придется
помнить.)

#+begin_src emacs-lisp :tangle yes
(define-key evil-ex-search-keymap (kbd "C-d") #'toggle-input-method)
(define-key evil-ex-map (kbd "C-d") #'toggle-input-method)
#+end_src

** Схлопывание текста

Выбрал пакет =yafolding=. Объект схлопывания определяется по
отступам. Есть три варианта схлопывания:
- объекта,
- родительского объекта,
- всех объектов (может сильно тормозить).

#+begin_src emacs-lisp :tangle yes
(use-package yafolding
	:ensure t
	:config
	(add-hook 'buffer-list-update-hook 'yafolding-mode))
#+end_src

Назначим горячие клавиши для схлопывания текста.

#+begin_src emacs-lisp :tangle yes
(my/leader-def '(normal visual motion) 'override
               "y" '(:ignore t :which-key "folding")
               "y RET" #'yafolding-toggle-element
               "y p" #'yafolding-hide-parent-element
               "y f" #'yafolding-toggle-all)
#+end_src

** Подсветка отступов

Можно подсветить верткальньной "чертой" отступы в тексте. Почти всегда
это удобно. Подсвечивать можно или символом "|", что не всегда
работает гладко, или перекрашивая фон у символов (тут без проблем).

#+begin_src emacs-lisp :tangle yes
(use-package highlight-indent-guides
	:ensure t
    :config
	(setq highlight-indent-guides-method 'column)
	(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
	(add-hook 'org-mode-hook 'highlight-indent-guides-mode))
#+end_src
   
** Проверка орфографии

Проверка орфографии делается на основе утилиты hunspell. Ее нужно
предварительно установить в систему.
: sudo pacman -S hunspell

Словари лежат в директории настроек редактора ../dictionaries/hunspell/.
Чтобы утилита hunspell имела к ним доступ, установим переменную среды DICPATH.

#+begin_src emacs-lisp :tangle yes
(setenv "DICPATH" (concat my/config-dir "/dictionaries/hunspell/"))
#+end_src

Осталось настроить ispell. Код ниже работает как по русским, так и по английским словам.

#+begin_src emacs-lisp :tangle yes
(when (executable-find "hunspell")
    (setq ispell-local-dictionary-alist '(("russian"
             "[АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюяA-Za-z]"
             "[^АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюяA-Za-z]"
             ""  ;; было "[-']", но убрал, чтобы эти символы не мешали обнаружению ошибок.
             nil ("-d" "ru_RU,en_US") nil utf-8))
          ispell-program-name "hunspell"
          ispell-dictionary "russian"
          ispell-really-aspell nil
          ispell-really-hunspell t
          ispell-encoding8-command t
          ispell-silently-savep t))
#+end_src

Включаем проверку синтаксиса на лету в emacs с помощью =flyspell-mode=.
Автоматическое его включение ставим только на редактирование литературных
текстов (text, org, markdown и т.п.).

#+begin_src emacs-lisp :tangle yes
(dolist (hook '(text-mode-hook
                org-mode-hook
                markdown-mode-hook))
    (add-hook hook (lambda ()
                       (flyspell-mode 1))))
#+end_src

Горячие клавиши для flyspell-mode оказались неудобными для меня. Выпилим их.

#+begin_src emacs-lisp :tangle yes
(require 'flyspell)
(assq-delete-all 'flyspell-mode minor-mode-map-alist)
(define-key flyspell-mode-map (kbd "C-,") nil)
(define-key flyspell-mode-map (kbd "C-;") nil)
#+end_src

Подсказки по исправлению слова зашиты на функцию =ispell-word=.

** Сниппеты Yasnippet

Сниппет в Emacs - это заранее подготовленный кусок текста, который
можно вставить себе в документ при редактировании.  Очень удобный и
полезный инструмент! Сниппеты могут на лету доопределяться параметрами
и быть привязаны к разным типам документов.

Грузим пакеты, указываем директорию со своими сниппетами.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
    :ensure t
    :config
    (add-to-list 'yas-snippet-dirs (concat my/config-dir "/snippets"))
    (yas-global-mode 1))
(use-package yasnippet-classic-snippets
    :ensure t)
(use-package yasnippet-snippets
    :ensure t)
(use-package ivy-yasnippet
    :ensure t)
#+end_src

Горячие клавиши для выбора сниппета по его названию.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "i" '(:ignore t :which-key "insert"))
(my/leader-def nil 'override
               "i s" #'yas-insert-snippet)
#+end_src

** Закладки

Ставим закладки на разные места в разных документах и перемещаемся по ним.

Пакет =bm= (Visual Bookmarks).

#+begin_src emacs-lisp :tangle yes
(use-package bm
	:ensure t)
#+end_src

Восстановление при загрузке.

#+begin_src emacs-lisp :tangle yes
(setq bm-restore-repository-on-load t)
#+end_src

Переключение закладок по всем буферам при выполнении 'next'.

#+begin_src emacs-lisp :tangle yes
(setq bm-cycle-all-buffers t)
#+end_src

Где хранить постоянные файлы.

#+begin_src emacs-lisp :tangle yes
(setq bm-repository-file (concat user-emacs-directory "/bm-repository"))
#+end_src

Сохранение закладок.

#+begin_src emacs-lisp :tangle yes
(setq-default bm-buffer-persistence t)
(add-hook 'kill-buffer-hook #'bm-buffer-save)
#+end_src

Сохранение закладок при удалении буфера.

#+begin_src emacs-lisp :tangle yes
(add-hook 'kill-emacs-hook #'(lambda ()
                                 (bm-buffer-save-all)
                                 (bm-repository-save)))
#+end_src

Сохранение буфера с закладками после сохранения самих закладок.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-save-hook #'bm-buffer-save)
#+end_src

Чтение репозитория из файла при старте.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-init-hook 'bm-repository-load)
#+end_src

Восстановление буфера с закладками.

#+begin_src emacs-lisp :tangle yes
(add-hook 'find-file-hooks   #'bm-buffer-restore)
(add-hook 'after-revert-hook #'bm-buffer-restore)
#+end_src

Подстраховка с сохранением закладки при обновлении буфера.

#+begin_src emacs-lisp :tangle yes
(add-hook 'vc-before-checkin-hook #'bm-buffer-save)
#+end_src

Функция создания аннотированной ссылки.

#+begin_src emacs-lisp :tangle yes
(defun my/bm-bookmark-annotate ()
	(interactive)
	(bm-toggle)
	(bm-bookmark-annotate))
#+end_src

Подстрахуемся на удаление закладок.

#+begin_src emacs-lisp :tangle yes
(defun my/bm-remove-all-current-buffer ()
	(interactive)
	(when (y-or-n-p "Remove all bookmarks in current buffer?")
		(bm-remove-all-current-buffer)))

(defun my/bm-remove-all-all-buffers ()
	(interactive)
	(when (yes-or-no-p "Remove all bookmarks in all buffers?")
		(bm-remove-all-all-buffers)))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "j" '(:ignore t :which-key "marks"))
(my/leader-def nil 'override
               "j m" '(:ignore t :which-key "marks")
               "j m t" #'bm-toggle
               "j m a" #'bm-bookmark-annotate
               "j m s" #'bm-bookmark-show-annotation
               "j m n" #'bm-next
               "j m p" #'bm-previous
               "j m l" #'bm-show
               "j m L" #'bm-show-all
               "j m T" #'my/bm-bookmark-annotate
               "j m d" #'my/bm-remove-all-current-buffer
               "j m D" #'my/bm-remove-all-all-buffers)
#+end_src

* Подсказки, выпадашки, автодополнения

** Ivy - меню с поиском по частичному совпадению

=Ivy= - одно из самых удобных меню с выбором элементов по частичному совпадению
текста. Есть более новый =Vertico=, но сперва сделаю, к чему привык.

#+begin_src emacs-lisp :tangle yes
(use-package ivy
    :ensure t
    :config
    (ivy-mode)
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t))
(use-package ivy-hydra
    :ensure t)
#+end_src

Определим горячие клавиши на восстановление результатов последней сессии ivy.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "'" #'ivy-resume)
#+end_src

** Подсказки на клавиши

При вводе клавишного аккорда получаем подсказку на его продолжение.

#+begin_src emacs-lisp :tangle yes
(use-package guide-key
    :ensure t
    :diminish guide-key-mode)
(use-package which-key
    :ensure t
    :config
    (setq which-key-sort-order 'which-key-key-order-alpha)
    (which-key-mode 1))
#+end_src

Пакет ниже дает развернутые подсказки. Поставим такую на подсказку для клавиш.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
    :ensure t
    :config
    (my/leader-def nil 'override
                   "h k" '(helpful-key :which-key "Describe key")))
(my/leader-def nil 'override
               "h" '(:ignore t :which-key "help"))
#+end_src

** Counsel. Меню вызова функции с более полным описанием

Здесь нужен пакет =counsel=. Функциями из него подменяем стандартные.

#+begin_src emacs-lisp :tangle yes
(use-package counsel
    :ensure t)
(use-package counsel-projectile
    :ensure t)
#+end_src

Уберем "^" из начала поисковой строки в counsel и вообще в Ivy.

#+begin_src emacs-lisp :tangle yes
(setq ivy-initial-inputs-alist
      '((counsel-minor . "+")
        (counsel-package . "+")
        (counsel-org-capture . "")
        (counsel-M-x . "")
        (counsel-describe-symbol . "")
        (org-refile . "")
        (org-agenda-refile . "")
        (org-capture-refile . "")
        (Man-completion-table . "")
        (woman . "")))

#+end_src

Подменим стандартные функции на их counsel-аналог.
Так, как это закомментарено ниже, не будет работать.
Позже допилю другое решение.

# #+begin_src emacs-lisp :tangle yes
# (advice-add #'find-library :override #'counsel-find-library)
# (advice-add #'info-lookup-symbol :override #'counsel-info-lookup-symbol)
# (advice-add #'locate :override #'counsel-locate)
# (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
# (global-set-key (kbd "C-c g") 'counsel-git)
# (global-set-key (kbd "C-c j") 'counsel-git-grep)
# (global-set-key (kbd "C-c k") 'counsel-ag)
# (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
# #+end_src

Определяем действия =counsel= на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(setq suggest-key-bindings t)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-r") #'counsel-minibuffer-history)
(my/leader-def nil 'override
               ":" '(counsel-M-x :which-key "M-x")
               "h f" '(counsel-describe-function :which-key "Describe function")
               "h v" '(counsel-describe-variable :which-key "Describe variable")
               "h p" '(describe-package :which-key "Describe package")
               "h o" '(counsel-describe-symbol :which-key "Descrive symbol")
               "h t" '(counsel-load-theme :which-key "Load visual theme"))
#+end_src

** Company. Автодополнения

Строим автодополнения через =Company= и =Ivy=.

#+begin_src emacs-lisp :tangle yes
(use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode))
(use-package company-dict
    :ensure t)
(use-package company-box
    :ensure t)
(use-package company-restclient
    :ensure t)
(use-package ivy-hydra
    :ensure t)
(use-package company-shell
    :ensure t)
#+end_src

** Наполнение полезным содержимым ivy-меню

Этот код взят из Doom. Буков много, но и польза видна: показываются
значения переменных прямо в меню.

Ниже функция, которая выдает нужный формат для describe-variable.

#+begin_src emacs-lisp :tangle yes
(defun doom/ivy-rich-describe-variable-transformer (cand)
	"Previews the value of the variable in the minibuffer"
	(let* ((sym (intern cand))
		   (val (and (boundp sym) (symbol-value sym)))
		   (print-level 3))
		(replace-regexp-in-string
		 "[\n\t\^[\^M\^@\^G]" " "
		 (cond ((booleanp val)
				(propertize (format "%s" val) 'face
							(if (null val)
								'font-lock-comment-face
								'success)))
			   ((symbolp val)
				(propertize (format "'%s" val)
							'face 'highlight-quoted-symbol))
			   ((keymapp val)
				(propertize "<keymap>" 'face 'font-lock-constant-face))
			   ((listp val)
				(prin1-to-string val))
			   ((stringp val)
				(propertize (format "%S" val) 'face 'font-lock-string-face))
			   ((numberp val)
				(propertize (format "%s" val) 'face 'highlight-numbers-number))
			   ((format "%s" val)))
		 t)))
#+end_src

Теперь грузим пакет ivy-rich, который эту красоту и поддеживает.

#+begin_src emacs-lisp :tangle yes
(use-package ivy-rich
	:ensure t
	:config
	(setq ivy-rich-display-transformers-list
		  (list
		   'counsel-describe-variable
		   '(:columns
			 ((counsel-describe-variable-transformer (:width 40)) ; the original transformer
			  (doom/ivy-rich-describe-variable-transformer (:width 50)) ; display variable value
			  (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))
		   'counsel-M-x
		   '(:columns
			 ((counsel-M-x-transformer (:width 60))
			  (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))
		   ;; Apply switch buffer transformers to `counsel-projectile-switch-to-buffer' as well
		   'counsel-projectile-switch-to-buffer
		   (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer)
		   'counsel-bookmark
		   '(:columns
			 ((ivy-rich-candidate (:width 0.5))
			  (ivy-rich-bookmark-filename-or-empty (:width 60))))
		   ))
	(ivy-rich-mode 1))
#+end_src

** Некоторые дополнения пакетов

Копирую сюда установку некоторых пакетов из прошлых конфигов.
Прокомментирую как-нибудь позже.

#+begin_src emacs-lisp :tangle yes
(use-package amx
    :ensure t)
(use-package flx
    :ensure t)
(use-package prescient
    :ensure t)
(use-package ivy-posframe
    :ensure t)
(use-package all-the-icons-ivy
    :ensure t)
#+end_src

** Клавиши перемещения по минибуферу

Вернем более привычное мне перемещение по строкам минибуферов, как было в Doom:
Ctrl + jk. Собственно, из него и беру код ниже.

#+begin_src emacs-lisp :tangle yes
(setq my/default-minibuffer-maps (list minibuffer-local-map
                                       minibuffer-local-ns-map
                                       minibuffer-local-completion-map
                                       minibuffer-local-must-match-map
                                       minibuffer-local-isearch-map
                                       read-expression-map
                                       ivy-minibuffer-map
                                       ivy-switch-buffer-map))

(mapc (lambda (key-map)
          (define-key key-map (kbd "C-j") #'next-line)
          (define-key key-map (kbd "C-k") #'previous-line)
          (define-key key-map (kbd "C-S-j") #'scroll-up-command)
          (define-key key-map (kbd "C-S-k") #'scroll-down-command))
      my/default-minibuffer-maps)

(mapc (lambda (key-map)
          (evil-define-key 'insert key-map (kbd "C-j") #'next-line)
          (evil-define-key 'insert key-map (kbd "C-k") #'previous-line))
      my/default-minibuffer-maps)

(define-key read-expression-map (kbd "C-j") #'next-line-or-history-element)
(define-key read-expression-map (kbd "C-k") #'previous-line-or-history-element)
#+end_src

* Поиск и выделение

** Swiper. Удобный живой поиск текста по открытому буфферу

Очень удобный поиск текста по открытому буферу. Результаты показываются в
минибуфере по мере ввода поискового текста.

#+begin_src emacs-lisp :tangle yes
(use-package swiper
    :ensure t)
#+end_src

Горячие клавиши для вызова поиска swiper.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "s" '(:ignore t :which-key "search"))
(my/leader-def nil 'override
               "s s" '(swiper :which-key "Search buffer")
               "s S" '(swiper-isearch-thing-at-point
                       :which-key "Search buffer for thing at point")
               "s b" '(counsel-grep-or-swiper :which-key "Grep or search buffer"))
#+end_src

** Поиск на стартовой странице Emacs

Были проблемы поиска текста на стартовой странице Doom Emacs.
Проблемы решены следующим способом.

#+begin_src emacs-lisp :tangle yes
(set-input-method 'russian-computer)
(isearch-toggle-input-method)
#+end_src

** Выделение при поиске по тексту

Не отключаем выделение по всему тексту при поиске.

#+begin_example emacs-lisp :tangle yes
(setq evil-ex-search-highlight-all nil)
#+end_example

** Символ технического пробела `_'

Emacs по-умолчанию не причисляет символ `_' к составу слова, что очень неудобно.
Исправим положение.

#+begin_src emacs-lisp :tangle yes
(modify-syntax-entry ?_ "w")
#+end_src

** Чувствительность к регистру (прописные и строчные символы)

Чувствительность нужна и важна (особенно при поиске).

Есть три параметра настройки:
- =sensitive=,
- =insensitive=,
- =smart=
Возможно, =smart= даже удобней.

Use [M-x toggle-case-fold-search] to toggle mode.

#+begin_src emacs-lisp :tangle yes
(setq case-fold-search nil)  ; Use [M-x toggle-case-fold-search] to toggle mode.
(setq evil-ex-search-case 'smart)  ; sensitive, insensitive, smart
#+end_src

** Imenu. Навигация по документу через меню

Imenu - дает не только удобный способ навигации по документу, но и
показывает его структуру.  Если это текстовый файл с разметкой (org),
то определит в нем заголовки (оглавление).  Если это программный код,
то определит в нем классы и функции.

Определим глубину заголовков (два по-умолчанию - это очень мало).

#+begin_src emacs-lisp :tangle yes
(setq org-imenu-depth 8)
#+end_src

Определим горячие клавиши для навигации через imenu.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "s i" '(counsel-imenu :which-key "IMenu"))
#+end_src

Установим дополнтельный пакет, который в отдельном окне отображает
оглавление.

#+begin_src emacs-lisp :tangle yes
(use-package imenu-list
    :ensure t
    :config
    (my/leader-def nil 'override
                   "s I" '(imenu-list-smart-toggle :which-key "IMenu content")))
#+end_src

* Работа с вкладками (tab)

** Новая именованная вкладка

Создает новую вкладку и интерактивно назначает ей имя. Один прокол - полоса во вкладками почему-то сразу не показывается. Дерганье соответствующих функций показа не помогает.

#+begin_src emacs-lisp :tangle yes
(defun my/new-tab-with-name (tab-name)
    (interactive (list (read-string "Enter a name for new tab: ")))
    (tab-bar-new-tab)
    (tab-rename tab-name)
    (tab-bar-mode -1)
    (message "Tab \"%s\" is active." tab-name))
#+end_src

Горячие клавиши для интерактивно именованной вкладки.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x t a") #'my/new-tab-with-name)
#+end_src

* Работа с фреймами

** Клавиши для работы с фреймами

Здесь определим набор клавиш для привычных действий с фреймами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "q" '(:ignore t :which-key "quite/close"))
(my/leader-def nil 'override
    "o f" '(make-frame :which-key "Make frame")
    "q f" '(delete-frame :which-key "Delete frame"))
#+end_src

** Поиск фрейма по имени

Поиск фрейма по имени. Результат - найденный фрейм с указанным именем или nil.
(Для справки: Есть функция =select-frame-by-name=, которая по имени находит фрейм и активизирует его.)

#+begin_src emacs-lisp :tangle yes
(defun my/get-frame-by-name (name)
    "If there is a frame named NAME, return it, else nil."
    (-some (lambda (frame)
               (when (equal name (frame-parameter frame 'name))
                   frame))
           (frame-list)))
#+end_src

** Вид окон при открытии нового фрейма

Когда появляется новый клиент, то хорошо бы скрыть все, что было во
фрейме ранее открытого клиента.  Для этого оставим в нем только одно
окно и выведем в него приветственный буфер (dashboard).

Есть неприятность при создании коммита через Magit тоже поднимается
server-after-make-frame-hook.  Понять, что это "был Magit", можно по
имени текущего буфера - =" *server*"= (определил экспериментально).

#+begin_src emacs-lisp :tangle yes
(add-hook 'server-after-make-frame-hook
          (lambda (&optional frame)
              (unless (equal "*server*"
                             (string-trim (buffer-name (current-buffer))))
                  (persp-switch "main")
                  (delete-other-windows)
                  (switch-to-buffer "*scratch*")
                  (switch-to-buffer "*dashboard*"))))
#+end_src

* Работа с окнами

** Клавиши для работы с окнами

В целом, все уже есть в evil и вызывается по Ctrl-w.
Но верну сочетания клавиш, к которым привык в Doom.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "w" '(:ignore t :which-key "windows")
               "w d" #'evil-window-delete
               "w r" #'evil-window-rotate-downwards
               "w R" #'evil-window-rotate-upwards
               "w =" #'balance-windows
               "w C-l" #'evil-window-right
               "w C-h" #'evil-window-left
               "w C-j" #'evil-window-down
               "w C-k" #'evil-window-up
               "w C-S-l" #'evil-window-move-far-right
               "w C-S-h" #'evil-window-move-far-left
               "w C-S-j" #'evil-window-move-very-bottom
               "w C-S-k" #'evil-window-move-very-top)
#+end_src

Отдельно перетащим из Doom расширение окон по горизонтали и вертикали.

#+begin_src emacs-lisp :tangle yes
(defun doom/window-maximize-horizontally ()
	"Delete all windows to the left and right of the current window."
	(interactive)
	(require 'windmove)
	(save-excursion
		(while (ignore-errors (windmove-left)) (delete-window))
		(while (ignore-errors (windmove-right)) (delete-window))))

(defun doom/window-maximize-vertically ()
	"Delete all windows above and below the current window."
	(interactive)
	(require 'windmove)
	(save-excursion
		(while (ignore-errors (windmove-up)) (delete-window))
		(while (ignore-errors (windmove-down)) (delete-window))))
#+end_src

И теперь определим горячие клавиши для "максимизации" окон.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
	"w m m" #'delete-other-windows
	"w m s" #'doom/window-maximize-horizontally
	"w m v" #'doom/window-maximize-vertically)
#+end_src

** Нумерация окон

Работа с окнами на основе их нумерации. Нумерацию окон устанавливаем
локальньно, в текущем фрейме (переменная =winum-scope=).

#+begin_src emacs-lisp :tangle yes
(use-package winum
    :ensure t
    :config
    (winum-mode 1)
    (setq winum-scope 'frame-local))
#+end_src

** Разделение рабочего пространства на заданное количество окон

Взято из Spacemacs. Рабочее пространство разделяется по <leader>-w-<Num> на
заданное количество окон (от одного до четырех). Буфера по окнам распределяются
в порядке очереди и выбираются из текущего проекта.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "w 1" '(spacemacs/window-split-single-column :which-key "Window split single column")
    "w 2" '(spacemacs/window-split-double-columns :which-key "Window split double columns")
    "w 3" '(spacemacs/window-split-triple-columns :which-key "Window split triple columns")
    "w 4" '(spacemacs/window-split-grid :which-key "Window split grid"))
#+end_src

** Переключение окон, как в Spacemacs

Переключение окон по <leader>-<Num>.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "0" '(treemacs-select-window :which-key "Select window 0")
    "1" '(winum-select-window-1 :which-key "Select window 1")
    "2" '(winum-select-window-2 :which-key "Select window 2")
    "3" '(winum-select-window-3 :which-key "Select window 3")
    "4" '(winum-select-window-4 :which-key "Select window 4")
    "5" '(winum-select-window-5 :which-key "Select window 5")
    "6" '(winum-select-window-6 :which-key "Select window 6")
    "7" '(winum-select-window-7 :which-key "Select window 7")
    "8" '(winum-select-window-8 :which-key "Select window 8")
    "9" '(winum-select-window-9 :which-key "Select window 9"))
#+end_src

** Разделение окна

Вертикальное и горизонтальное разделение окна с переносом фокуса.

#+begin_src emacs-lisp :tangle yes
(defun my/split-window-right-and-focus ()
    (interactive)
    (split-window-right)
    (windmove-right))

(defun my/split-window-below-and-focus ()
    (interactive)
    (split-window-below)
    (windmove-down))
#+end_src

Горячие клавиши для разделения окна (с переключением в новое окно и без
переключения).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "w v" '(evil-window-vsplit :which-key "Split window vertical")
    "w V" '(my/split-window-right-and-focus :which-key "Split window vertical with focus")
    "w s" '(evil-window-split :which-key "Split window horizontally")
    "w S" '(my/split-window-below-and-focus :which-key "Split window horizontally with focus"))
#+end_src

** Ширина разделителя окон

Сделаем разделение окон по-заметнее.

#+begin_src emacs-lisp :tangle yes
(window-divider-mode 1)
(setq window-divider-default-right-width 4)
#+end_src

** Настройка Ediff

Настроим расположение окон для сравнения содежимого буферов.  Ставим
окна сравниваемых буферов рядом (а не одно под другим), панель
управления уводим вниз (а не в отдельный фрейм).

#+begin_src emacs-lisp :tangle yes
(require 'ediff)
(setq ediff-diff-options "-w" ; turn off whitespace checking
      ediff-split-window-function #'split-window-horizontally
      ediff-window-setup-function #'ediff-setup-windows-plain)
#+end_src

** Поиск текста и файла по директории

Функция поиска текста по заданной директории.  Назначаем директорию
корнем проекта, после чего запускаем поиск по проекту.

#+begin_src emacs-lisp :tangle yes
(defun my/search-in-directory ()
    (interactive)
    (let ((projectile-project-root (read-directory-name "Select directory: ")))
        (call-interactively 'counsel-projectile-rg)))
#+end_src

Аналогично поступаем с поиском файла по директории.

#+begin_src emacs-lisp :tangle yes
(defun my/find-file-in-directory ()
    (interactive)
    (let ((projectile-project-root (read-directory-name "Select directory: ")))
        (call-interactively #'counsel-projectile-find-file)))
#+end_src

Назначаем горячие клавиши для поиска.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "s d" '(my/search-in-directory :which-key "Search in directory")
               "f F" '(my/find-file-in-directory :which-key "Open file in directory"))
#+end_src

* Работа с буферами

Для работы части функций этого раздела используется код, взятый из
Spacemacs. Код находится в файле [[./funcs.el][funcs.el]].

** Клавиши для работы с буферами

Здесь определим набор клавиш для привычных действий с буферами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "b" '(:ignore t :which-key "buffers")
               "b b" '(counsel-projectile-switch-to-buffer
                       :which-key "Switch buffer in project")
               "SPC" '(counsel-projectile-switch-to-buffer
                       :which-key "Switch buffer in project")
               "b B" '(counsel-switch-buffer :which-key "Switch buffer")
               "b d" '(kill-current-buffer :which-key "Kill buffer"))
#+end_src

** Отображение popup-буферов внизу окна и прочие настройки показа буферов

Мне удобней работать с popup-окнами (например окно помощи "*Help*"),
когда они появляются не сбоку фрейма, а снизу.  Делается через задание
списка ACTION для функции =display-buffer=.

Настроим сначала фокус у окон с help-буферами.

#+begin_src emacs-lisp :tangle yes
(setq help-window-select t)
#+end_src

Теперь все остальное.

#+begin_src emacs-lisp :tangle yes
(setq display-buffer-alist
      '(
        ;; Any new buffer
        ("^\\*new .*")

        ;; Dashboard
        ("^\\*dashboard\\*$")

        ;; PlantUML
        ("^\\*PLANTUML Preview\\*$"
         (display-buffer-reuse-window))

        ;; Ilist
        ("^\\*Ilist\\*$"
         (display-buffer-reuse-window)
         (window-width . 0.30))

        ;; Org Src edit
        ("^\\*Org Src .*\\*$")

        ;; Clean Eshell
        ("^\\*eshell\\*$")

        ;; Clean Vterm
        ("^\\*vterm\\*$")

        ;; IELM
        ("^\\*ielm\\*$")

        ;; Magit (status)
        ("^magit: .*"
         (display-buffer-reuse-window display-buffer-same-window))

        ;; Magit log
        ("^magit-log.*"
         (display-buffer-reuse-window display-buffer-same-window))

        ;; Magit refs
        ("^magit-refs:.*"
         (display-buffer-reuse-window display-buffer-same-window))

        ;; Magit process
        ("^magit-process:.*"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))

        ;; Other buffers with name like "*Name*"
        ("^\\*.*\\*$"
         (display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.40))))
#+end_src

** Открытие буфера, простое и с разделением окна

Удобно открыть существующий буфер, разделив при этом активное окно.

Привяжем горячие клавиши на такое открытие буфера.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "b j" '(projectile-switch-to-buffer-other-window :which-key "Switch buffer in project with other window")
    "b J" '(counsel-switch-buffer-other-window :which-key "Switch buffer with other window"))
#+end_src

** Перенос буферов между окнами

Взято из Spacemacs для переноса буферов между окнами по клавишам <leader>-b-<Num>.

#+begin_src emacs-lisp :tangle yes
(defun my/move-buffer-to-window (windownum follow-focus-p)
  "Moves a buffer to a window, using the my numbering. follow-focus-p
controls whether focus moves to new window (with buffer), or stays on current"
  (interactive)
  (if (> windownum (length (window-list-1 nil nil t)))
      (message "No window numbered %s" windownum)
    (let ((b (current-buffer))
          (w1 (selected-window))
          (w2 (winum-get-window-by-number windownum)))
      (unless (eq w1 w2)
        (set-window-buffer w2 b)
        (switch-to-prev-buffer)
        (unrecord-window-buffer w1 b))
      (when follow-focus-p
        (select-window (winum-get-window-by-number windownum))))))

(defun my/swap-buffers-to-window (windownum follow-focus-p)
  "Swaps visible buffers between active window and selected window.
follow-focus-p controls whether focus moves to new window (with buffer), or
stays on current"
  (interactive)
  (if (> windownum (length (window-list-1 nil nil t)))
      (message "No window numbered %s" windownum)
    (let* ((b1 (current-buffer))
           (w1 (selected-window))
           (w2 (winum-get-window-by-number windownum))
           (b2 (window-buffer w2)))
      (unless (eq w1 w2)
        (set-window-buffer w1 b2)
        (set-window-buffer w2 b1)
        (unrecord-window-buffer w1 b1)
        (unrecord-window-buffer w2 b2)))
    (when follow-focus-p (winum-select-window-by-number windownum))))

(dotimes (i 9)
  (let ((n (+ i 1)))
    (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
             ,(format "Move buffer to the window with number %i." n)
             (interactive "P")
             (if arg
                 (my/swap-buffers-to-window ,n t)
               (my/move-buffer-to-window ,n t))))
    (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
             (interactive)
             (my/move-buffer-to-window ,n t)))
    (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
             (interactive)
             (my/swap-buffers-to-window ,n t)))
    ))
#+end_src

Привязываем горячие клавиши для переноса буферов.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "b 1" '(move-buffer-window-no-follow-1 :which-key "Move buffer to window 1")
    "b 2" '(move-buffer-window-no-follow-2 :which-key "Move buffer to window 2")
    "b 3" '(move-buffer-window-no-follow-3 :which-key "Move buffer to window 3")
    "b 4" '(move-buffer-window-no-follow-4 :which-key "Move buffer to window 4")
    "b 5" '(move-buffer-window-no-follow-5 :which-key "Move buffer to window 5")
    "b 6" '(move-buffer-window-no-follow-6 :which-key "Move buffer to window 6")
    "b 7" '(move-buffer-window-no-follow-7 :which-key "Move buffer to window 7")
    "b 8" '(move-buffer-window-no-follow-8 :which-key "Move buffer to window 8")
    "b 9" '(move-buffer-window-no-follow-9 :which-key "Move buffer to window 9"))
#+end_src

** Переключение показа по центру окна

Здесь воспользуемся пакетом centered-window.

#+begin_src emacs-lisp :tangle yes
(use-package centered-window
	:ensure t)
#+end_src

На широком окне неудобно читать длинные строчки.
Запилим корячие клавиши переключения =centered-window-mode=.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t m" #'centered-window-mode)
#+end_src

** Показ буферов, разобранных по проектам

Удобно видеть список буферов, разобранный по проектам.

/TODO: В Doom различал проекты сразу. Здесь надо донастроить./

Загрузим пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-projectile
    :ensure t)
(use-package ibuffer-vc
    :ensure t)
#+end_src

Красивый список вызывается командой =ibuffer=.
В evil-mode запилим его вызов на команду ":bd".

#+begin_src emacs-lisp :tangle yes
(evil-ex-define-cmd "buffers" #'ibuffer)
#+end_src

** Srcatch буфер

В Doom были удобные черновики (scratch), которые не только создавались
уникальными для каждого проекта, но и автоматически сохраняли свое
содержимое.  Напишем им подобные.

Начнем с функции для создания именованного scratch-буфера с
автосохранением в файл.  Сохранять содержимое scratch-буферов будем в
эту директорию.

#+begin_src emacs-lisp :tangle yes
(setq my/scratch-dir (concat user-emacs-directory ".cache/scratches"))
(make-directory my/scratch-dir t)
#+end_src

Теперь сама функция. Она принимает на вход имя буфера и какой-либо
идентификатор, по которому строится имя файла для автосохранения.
Возвращает созданный буфер.

#+begin_src emacs-lisp :tangle yes
(defun my/scratch-buffer-create (name id)
    (let* ((buffer-name (format "*scratch:%s*" name))
           (file-name (expand-file-name (concat my/scratch-dir "/"
                                                (md5 (format "%s" id))
                                                ".txt")))
           (buffer (get-buffer buffer-name)))
        (unless buffer
            (setq buffer (get-buffer-create buffer-name))
            (when (file-exists-p file-name)
                (with-current-buffer buffer
                    (insert-file-contents file-name))))
        (with-current-buffer buffer
            (setq-local buffer-auto-save-file-name file-name))
        buffer))
#+end_src

Теперь сделаем создание конкретных scratch-буферов.  Начнем с общего
scratch-буфера (на замену стандартному "*scratch*").

#+begin_src emacs-lisp :tangle yes
(defun my/make-scratch-main ()
    (interactive)
    (let* ((name "main")
           (buffer (my/scratch-buffer-create name name)))
        (pop-to-buffer buffer)
        buffer))
#+end_src

И создание scratch-буфера для текущего проекта или рабочего пространства.

#+begin_src emacs-lisp :tangle yes
(defun my/make-scratch-perspective ()
    (interactive)
    (let* ((project-path (projectile-project-root))
           (persp-name (my/--get-current-persp-name))
           (id (or project-path
                   persp-name))
           (name (if project-path
                     (concat "PROJ-" (my/make-project-name project-path))
                     persp-name))
           (buffer (my/scratch-buffer-create name id)))
        (pop-to-buffer buffer)
        buffer))
#+end_src

Привычные из Doom горячие клавиши для scratch-буферов.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "x" '(my/make-scratch-main :which-key "Scratch main")
    "p x" '(my/make-scratch-perspective :which-key "Scratch project"))
#+end_src

* Работа с файлами

** Клавиши для работы с файлами

Здесь определим набор клавиш для привычных действий с файлами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "f" '(:ignore t :which-key "files")
               "f s" '(save-buffer :which-key "Save file or buffer")
               "f S" '(write-buffer :which-key "Save file as")
               "f f" '(counsel-find-file :which-key "Open file")
               "f d" '(counsel-find-file :which-key "Open directory or file")
               "o -" '(dired-jump :which-key "Open directory and select file"))
#+end_src

** Автоматическое обновление буферов при внешнем изменении их содержимого

Этот параметр позволит обновлять буфера, если файлы, с ними связанные, были
изменены вне Emacs:

#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode 1)
#+end_src

Аналогично этот параметр позволит автоматически обьновлять такие буфера, как
Dired:

#+begin_src emacs-lisp :tangle yes
(setq global-auto-revert-non-file-buffers t)
#+end_src

** Открытие файла с разделением окна

Открытие файла с разделением окна, вертикальным и горизонтальным.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "f i" '(spacemacs/find-file-vsplit :which-key "Open file vsplit")
    "f n" '(spacemacs/find-file-split :which-key "Open file split"))
#+end_src

** Копирование в буфер обмена текущего имени файла

При копировании имени файла в буфер обмена выводим его название.
Также имя файла дублируем в системные буфера обмена.

#+begin_src emacs-lisp :tangle yes
  (defun my/yank-buffer-filename ()
	  (interactive)
	  (let ((text (buffer-file-name)))
		  (evil-set-register ?\" text)
		  (evil-set-register ?+ text)
		  (evil-set-register ?* text)
		  (evil-set-register ?0 text)
		  (message text)))
#+end_src

Горячие клавиши для копирования в буфер имени текущего файла.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "f y" #'my/yank-buffer-filename)
#+end_src

** Dired. Настройка файлового менеджера

Установим автоматическое обновление содержимого окон Dired.

#+begin_src emacs-lisp :tangle yes
(setq dired-auto-revert-buffer #'dired-buffer-stale-p)
#+end_src

Копирование файлов удобно делать в директорию, что открыта в ближайшем
dired-окне. Для этого надо установить соответствующий флажок.

#+begin_src emacs-lisp :tangle yes
(setq dired-dwim-target t)
#+end_src

Файлы в Dired сортируются опциями команды "ls".
Из коробки по-умолчанию стоит сортировка по размеру ("SXU").
Изменим ее на сортировку по имени ("XSU"):

#+begin_src emacs-lisp :tangle yes
(setq dired-ls-sorting-switches "XSU")
#+end_src

Теперь раскрасим представление файлов. Делаем это пакетом dired-k.
(С флажком dired-k-style='git файлы будут иметь git-пометки.)

#+begin_src emacs-lisp :tangle yes
(use-package dired-k
    :ensure t
    :config
    (setq dired-k-human-readable t
          dired-k-style 'git)
    (add-hook 'dired-initial-position-hook 'dired-k)
    (add-hook 'dired-after-readin-hook #'dired-k-no-revert)
    )
#+end_src

** История сохраненных файлов

Бывает нужно для ручной синхронизации файлов на машинах.

Хранить истории будем в файле.

#+begin_src emacs-lisp :tangle yes
(defun my/files-history-save-file ()
    (concat user-emacs-directory
            "files-saving-history-"
            (if (bound-and-true-p server-name) server-name "server")
            ".el"))
#+end_src

Создадим хэш-таблицу сохраненных файлов: имя-файла - время сохранения.
А еще создадим такую же хэш-таблицу, но для директорий.

#+begin_src emacs-lisp :tangle yes
(defvar my/files-saving-history (make-hash-table :test 'equal))
(defvar my/directories-saving-history (make-hash-table :test 'equal))
#+end_src

Напишем функции загрузки и сохранения историй в файл.
Функция чтения отработает только в случае пустых историй.

#+begin_src emacs-lisp :tangle yes
(defun my/soft-load-histories-from-file ()
    (when (and (or (hash-table-empty-p my/files-saving-history)
                   (hash-table-empty-p my/directories-saving-history))
               (file-exists-p (my/files-history-save-file)))
        (with-temp-buffer
            (insert-file-contents (my/files-history-save-file))
            (goto-char 0)
            (setq my/directories-saving-history (read (current-buffer))
                  my/files-saving-history (read (current-buffer))))))

(defun my/save-histories-to-file ()
    (with-temp-buffer
        (prin1 my/directories-saving-history (current-buffer))
        (prin1 my/files-saving-history (current-buffer))
        (write-region (buffer-end -1) (buffer-end +1) (my/files-history-save-file))))
#+end_src

Добавлять файлы и директории в историю будем этой функцией.

#+begin_src emacs-lisp :tangle yes
(defun my/append-file-to-saving-history ()
    (let* ((buffer (or (buffer-base-buffer) (current-buffer)))
           (filename (buffer-file-name buffer))
           (time-value (format-time-string "%Y-%m-%d %H:%M:%S")))
        (when (and buffer filename time-value
                   (file-exists-p filename))
            (puthash filename time-value
                     my/files-saving-history)
            (puthash (file-name-directory filename) time-value
                     my/directories-saving-history))))
#+end_src

Ниже функция сортирует историю сохранений по датам и выдает результат списком.

#+begin_src emacs-lisp :tangle yes
(defun my/sort-files-saving-history (fd-saving-history)
    (let (saving-histry)
        (maphash (lambda (key val)
                     (push (list val key) saving-histry))
                 fd-saving-history)
        (sort saving-histry
              (lambda (pair1 pair2)
                  (string> (car pair1) (car pair2))))))
#+end_src

Теперь будем выбирать, какую историю показывать: файлов или директорий?
Заведем соответствующую переключалку.

#+begin_src emacs-lisp :tangle yes
(defvar my/fd-saving-history 'files)

(defun my/fd-saving-history (&optional ARG)
    "Select mode for show siving history.
ARG may be 'files, 'directories, 'toggle or nil.
Return history hash-map."
    (setq my/fd-saving-history (cond ((or (eq ARG 'directories)
                                          (and (eq ARG 'toggle)
                                               (eq my/fd-saving-history 'files)))
                                      'directories)
                                     ((or (eq ARG 'files)
                                          (and (eq ARG 'toggle)
                                               (eq my/fd-saving-history 'directories)))
                                      'files)
                                     (t
                                      my/fd-saving-history)))
    (cond ((eq my/fd-saving-history 'files)
           my/files-saving-history)
          ((eq my/fd-saving-history 'directories)
           my/directories-saving-history)))
#+end_src

Эта функция создает/обновляет буфер с историей сохранений, используя результат предыдущей функции.
Сутки разделяем пустой строкой.
Буфер переводим в org-mode и тексты файлов даем со ссылками.
Название буфера сохранено в переменную [[elisp:(message my/files-saving-history-buffer-name)][my/files-saving-history-buffer-name]].

#+begin_src emacs-lisp :tangle yes
(defvar my/files-saving-history-buffer-name "*files-saving-history*")

(defun my/update-buffer-for-files-saving-history (fd-saving-history)
    (interactive)
    (let* ((history-buffer (get-buffer-create my/files-saving-history-buffer-name))
           (history (my/sort-files-saving-history fd-saving-history))
           (date-result nil)

           (insert-row (lambda (pair)
                           (let* ((date-time (car pair))
                                  (date (car (split-string date-time " +")))
                                  (filename (cadr pair)))
                               (when (and date-result (not (equal date date-result)))
                                   (insert "\n"))
                               (insert (concat date-time "  [[" filename "]]\n"))
                               (setq date-result date)))))

           (with-current-buffer history-buffer
               (read-only-mode -1)
               (erase-buffer)
               (mapc insert-row history)
               (org-mode)
               (goto-char 0)
               (org-next-link)
               (read-only-mode 1))))
#+end_src

Дополнение хэш-таблицы и обновление буфера истории повесим на 'after-save-hook.
Теперь каждый сохраненный файл оставляет свой след.

#+begin_src emacs-lisp :tangle yes
(add-hook 'after-save-hook
          (lambda ()
              (my/soft-load-histories-from-file)
              (my/append-file-to-saving-history)
              (my/update-buffer-for-files-saving-history (my/fd-saving-history))
              (my/save-histories-to-file)))
#+end_src

Горячие клавиши для переключения между показом файлов и директорий.
Первое нажатие вытягивает буфер с историей наверх.
Остальные нажатия уже переключают показ.

#+begin_src emacs-lisp :tangle yes
(defun my/toggle-files-saving-history ()
    (interactive)
    (my/soft-load-histories-from-file)
    (if (equal my/files-saving-history-buffer-name
               (buffer-name (current-buffer)))
        (my/update-buffer-for-files-saving-history (my/fd-saving-history 'toggle))
        (switch-to-buffer my/files-saving-history-buffer-name))
    (when (string-empty-p (buffer-string))
        (my/update-buffer-for-files-saving-history (my/fd-saving-history)))
    (message (symbol-name my/fd-saving-history)))

(my/leader-def nil 'override
    "t h" #'my/toggle-files-saving-history)
#+end_src

** Открытие файла средствами операционной системы

Очень неудобно, когда Emacs пытается открывать и показывать сам такие файлы,
как PDF, ODT, DOCX и т.п. (речь о dired).
Чтобы иметь возможность открывать файлы средствами операционной системы
напишем функцию, под капотом у которой будет =gio open=.

#+begin_src emacs-lisp :tangle yes
(defun my/open-file-by-shell ()
    (interactive)
    (let ((filename (dired-get-filename)))
        (when filename
            (call-process "gio" nil 0 nil "open" filename))))
#+end_src

Горячие клавиши повесим на режим dired-mode.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'dired-mode-map
    "RET" #'my/open-file-by-shell)
#+end_src

** Логирование всплывающих сообщений

Предполагается, что в системе настроено логирование всплывающих сообщений типа
: $ notify-send "Test message" "Some text"
и помещено в файл

#+begin_src emacs-lisp :tangle yes
(setq my/notify-log-filename (concat (getenv "HOME") "/.log/notify.log"))
#+end_src

Функция ниже создает буфер, где в реальном времени отображаются последние
всплывшие сообщения.

#+begin_src emacs-lisp :tangle yes
(defun my/notify-log-open-notify-log ()
    (interactive)
    (let ((buffer-name "*notify-log*"))
        (if (get-buffer buffer-name)
                (switch-to-buffer buffer-name)
            (start-process "notify-log" buffer-name "tail" "-n 50" "-f" my/notify-log-filename)
            (switch-to-buffer buffer-name)
            (special-mode)
            ;; Highlighitng works only manually. :(
            (font-lock-mode 1)
            (font-lock-fontify-region (point-min) (point-max)))))
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t k" #'my/notify-log-open-notify-log)
#+end_src

* Рабочие пространства (workspaces, perspectives)

** Установка и настройка рабочих пространств

Здесь происходит организация рабочих пространств в редакторе.
Делается на основе модуля persp-mode (перспективы).

Рабочее пространство отвечает за запоминание расположения окон и
видимость своих буферов.  При смене рабочих пространств происходит
восстановление расположения окон для активированного пространства.

Если рабочее пространство создается новое, нужно показать начальный
экран (dashboard).

Установим пакет и назовем "нулевую" перспективу "main".

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "persp-mode"
    (setq wg-morph-on nil)
    (setq persp-autokill-buffer-on-remove 'kill-weak)
    (setq persp-auto-save-opt 0)
    (setq persp-auto-resume-time 0)
    (add-hook 'window-setup-hook #'(lambda () (persp-mode 1))))

(use-package persp-mode
    :ensure t
    :init
    (setq persp-nil-name "main")
    :config)

;; (use-package persp-projectile
;;     :ensure t)
#+end_src

** Клавиши для работы с рабочими пространствами

Все функции пакета доступны по префиксу "Ctrl-c p".
Но для удобства определю клавиши, к которым привык в Doom.

#+begin_src emacs-lisp :tangle yes
(defun my/persp-frame-switch ()
    (interactive)
    (let ((names (copy-list persp-names-cache)))
        (call-interactively 'persp-frame-switch)
        (unless (member (my/--get-current-persp-name) names)
            (switch-to-buffer "*dashboard*")
            (delete-other-windows))))

(my/leader-def nil 'override
               "TAB" '(:ignore t :which-key "workspaces")
               "TAB ." '(my/persp-frame-switch
                         :which-key "Switch or create workspace")
               "TAB r" '(persp-rename :which-key "Rename workspace")
               "TAB d" '(persp-kill :which-key "Delete workspace")
               "," '(persp-switch-to-buffer :which-key "Switch buffer in workspace")
               "TAB k" '(persp-remove-buffer :which-key "Remove buffer from workspace"))
#+end_src

Отдельно сделаем показ имени активной перспективы.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "TAB v" '(my/show-perspective-name :which-key "Show workspace name"))

(defun my/show-perspective-name ()
    (interactive)
    (message (my/--get-current-persp-name)))

(defun my/--get-current-persp-name ()
    (if (bound-and-true-p persp-mode)
        (safe-persp-name (get-current-persp))
        "main"))
#+end_src

** Открытие новых рабочих пространств в новых фреймах
   :PROPERTIES:
   :ID:       9061c49b-5d1a-47a7-a419-a9787254e99f
   :END:

Чтобы сократить количество телодвижений, сделаем открытие фрейма
одновременно с созданием или выбором рабочего пространства
(перспективы).  В заголовок фрейма поместим имя перспективы.

#+begin_src emacs-lisp :tangle yes
(defun my/make-frame-and-switch-perpective (persp-name)
    (interactive (list (ivy-read "Enter workspace name: "
                                 persp-names-cache)))
    (when persp-name
        (let* ((frame-text (my/make-title-bar-text persp-name))
               (frame (my/get-frame-by-name frame-text)))
            (if frame
                (select-frame-set-input-focus frame)
                (my/prepare-frame-for-workspace persp-name
                                                (make-frame))))))

(defun my/prepare-frame-for-workspace (persp-name frame &optional safe-frame-title)
    (let ((names (copy-list persp-names-cache)))
        (select-frame-set-input-focus frame)
        (unless safe-frame-title
            (my/set-title-bar persp-name))
        (persp-frame-switch persp-name)
        (unless (member persp-name names)
            (switch-to-buffer "*dashboard*")
            (delete-other-windows))
        (message (concat "Workspace '" persp-name "' is selected."))))
#+end_src

Выбрать/создать перспективу с изменением заголовка удобно сделать и
для текущего активного фрейма.  Это пригодится после вызова нового
emacs-клиента.

#+begin_src emacs-lisp :tangle yes
(defun my/set-title-bar-and-workspace-interactive (persp-name)
    (interactive (list (read-string "Enter workspace name: ")))
    (when persp-name
        (my/prepare-frame-for-workspace persp-name
                                        (selected-frame))))
#+end_src

Определим горячие клавиши для работы с рабочими пространствами и
фреймами для них.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o F" '(my/make-frame-and-switch-perpective :which-key "Make frame and switch workspace")
    "n I" '(my/set-title-bar-and-workspace-interactive :which-key "Set title for frame and workspace"))
#+end_src

* Проекты (projects)

** Установка и настройка работы с проектами (Projectile)

Проекты определяют работу с файлами в пределах директории проекта.
Рабочие пространства никак не конфликтуют с проектами - их удобно
использовать совместно, например:
- Создать рабочее пространство и переключать внутри него несколько проектов.
- Под каждый проект создать свое рабочее пространство и переключаться между ними.
- Для каждого проекта завести не только свое рабочее пространство, но и свой
  отдельный фрейм.
И так далее, как будет удобней для работы.

Пакет =projectile= - крайне удобное средство для работы с проектами.
Директории проектов распознаются по наличию в них поддиректории .git
или файла .projectile. Среди прочего можно:
- Открывать файлы проекта по частичному совпадению в имени и пути.
- Тем же сособом можно переключаться между проектами.
- Назначать на ходу команды компиляции, запуска и отладки проекта и
  пользоваться ими.
- В файле .projectile можно назначать параметры отдельно для каждого
  проекта.

Загрузим необходимые пакеты и сразу запретим Counsel предварительный
показ буферов.

#+begin_src emacs-lisp :tangle yes
(use-package projectile
    :ensure t
    :config
    (projectile-load-known-projects))
(use-package counsel-projectile
    :ensure t)
(use-package ibuffer-projectile
    :ensure t
    :config
    (setq counsel-projectile-preview-buffers nil))
(use-package ibuffer-vc
    :ensure t)
#+end_src

Сам Projectile запоминать ранее открытые проекты не будет. Сделаем это за него.
Сперва определим функцию для запоминания текущего проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/projectile-save-current-project (dir)
    (when (projectile-discover-projects-in-directory dir)
        (projectile-save-known-projects)))
#+end_src

Теперь перехватим соответствующие hook'и, где проверим наличие проекта в текущей
директории (живет в переменой default-directory).

#+begin_src emacs-lisp :tangle yes
(let ((hooks (list 'find-file-hook
                   'dired-mode-hook
                   'projectile-find-file-hook
                   'projectile-find-dir-hook)))
    (mapc (lambda (hook)
              (add-hook hook
                        (lambda ()
                            (my/projectile-save-current-project default-directory))))
          hooks))
#+end_src

** Совместная работа проектов и рабочих пространств

Для работы с проектом в отдельном Emacs-клиенте мне нужны следующие действия:
1. Запустить нового Emacs-клиента (или, как вариант, открыть отдельный фрейм).
2. Завести новое рабочее пространство по имени проекта.
3. Открыть проект и выбрать в нем файл.
4. Фрейму назначить одноименный заголовок, чтобы отличать его среди других фреймов.
Шаги 2, 3 и 4 можно собрать в одно действие. Сделаем это ниже.

Понадобится функция для создания имени текущего проекта.  Имя берется
по названию директории проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/make-project-name (&optional project-path)
    (unless project-path
        (setq project-path (projectile-project-root)))
    (when project-path
        (car (last
              (remove "" (split-string project-path "/"))))))
#+end_src

Теперь собираем все описанные выше действия в одну функцию.

#+begin_src emacs-lisp :tangle yes
(defun my/switch-project-with-workspace (&optional safe-frame-title)
    (interactive)
    (let ((temporary-name (format "*%s*" (md5 "*temporary-name-workspace*"))))
        (persp-frame-switch temporary-name)
        (call-interactively #'counsel-projectile-switch-project)
        (let ((project-name (my/make-project-name))
              (buffer (current-buffer)))
            (if (member project-name persp-names-cache)
                (progn (persp-frame-switch project-name)
                       (switch-to-buffer buffer)
                       (persp-kill (list temporary-name)))
                (persp-rename project-name))
            (my/prepare-frame-for-workspace project-name
                                            (selected-frame)
                                            safe-frame-title))))
#+end_src

Определим горячие клавиши для работы с проектами.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "p" '(:ignore t :which-key "projects")
    "P" '(:ignore t :which-key "projects-ws")
    "p p" '(counsel-projectile-switch-project :which-key "Simple switch project")
    "p P" '((lambda ()
                (interactive)
                (my/switch-project-with-workspace t))
            :which-key "Light switch proj+ws")
    "P P" '(my/switch-project-with-workspace :which-key "Switch project+workspace")
    "p f" '(counsel-projectile-find-file :which-key "Open file in project")
    ;; "p c" #'project-compile
    "p c" '(projectile-compile-project :which-key "Compile in project")
    "p R" '(projectile-run-project :which-key "Run project")
    "p T" '(projectile-test-project :which-key "Test project")
    "/" '(counsel-projectile-rg :which-key "Search project"))
#+end_src

** Исключение файлов из поиска по проектам

Здесь исключим всякий файловый мусор, дабы не мешался при поиске по проектам.
Тут собраны в основном исключения для Python-проектов.

#+begin_src emacs-lisp :tangle yes
(setq grep-find-ignored-directories '("SCCS" "RCS" "CVS" "MCVS" ".src" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "__pycache__" "build" "develop-eggs" "dist" "dist_local" "eggs" ".eggs" "sdist" ".pytest_cache" "env" "venv" "ENV" "env.bak" "venv.bak" ".mypy_cache")
      helm-grep-ignored-directories '("SCCS/" "RCS/" "CVS/" "MCVS/" ".svn/" ".git/" ".hg/" ".bzr/" "_MTN/" "_darcs/" "{arch}/" ".gvfs/" "__pycache__/" "build/" "develop-eggs/" "dist/" "dist_local/" "eggs/" ".eggs/" "sdist/" ".pytest_cache/" "env/" "venv/" "ENV/" "env.bak/" "venv.bak/" ".mypy_cache/")
      projectile-globally-ignored-directories '("~/.emacs.d/.local/" "~/.emacs.d/.local/" "~/.emacs.d/.local/" ".idea" ".vscode" ".ensime_cache" ".eunit" ".git" ".hg" ".fslckout" "_FOSSIL_" ".bzr" "_darcs" ".tox" ".svn" ".stack-work" ".ccls-cache" ".cache" ".clangd" "__pycache__" "build" "develop-eggs" "dist" "dist_local" "eggs" ".eggs" "sdist" ".pytest_cache" "env" "venv" "ENV" "env.bak" "venv.bak" ".mypy_cache")
      projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o" ".coverage" ".cache" ".ipynb_checkpoints" ".egg" ".pyo" ".pyd" ".cover" ".egg-info")
      projectile-globally-ignored-files '(".DS_Store" "TAGS" "tags")
)
#+end_src

И еще докинем исключения для списков ранее открытых файлов.

#+begin_src emacs-lisp :tangle yes
(setq recentf-exclude '("/\\(\\(\\(COMMIT\\|NOTES\\|PULLREQ\\|MERGEREQ\\|TAG\\)_EDIT\\|MERGE_\\|\\)MSG\\|\\(BRANCH\\|EDIT\\)_DESCRIPTION\\)\\'" "ssh:" "SSH:")
      )
#+end_src

* Org

** Начальная инициализация всей org-кухни

Некоторые мелочи, как само собой разумеющееся:
- поддержка идентификаторов,
- автоотступ по заголовкам,
- вычисление org-babel блоков без вопросов
и т.п..

#+begin_src emacs-lisp :tangle yes
(use-package org
	:ensure t
	:config
	(require 'org-id)
	(add-hook 'org-mode-hook (lambda ()
								 (setq org-adapt-indentation t)))
	(setq org-confirm-babel-evaluate nil))
#+end_src

Подгрузим поддержку evil для org-mode, включая Агенду.

#+begin_src emacs-lisp :tangle yes
(use-package evil-org
	:ensure t
	:after org
	:hook (org-mode . (lambda () evil-org-mode))
	:config
	(require 'evil-org-agenda)
	(evil-org-agenda-set-keys))
#+end_src

** Клавиши для работы в org-mode

Вернем привычные горячие клавиши из Doom для evil-mode.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'org-mode-map
	"[ s" #'evil-prev-flyspell-error
	"] s" #'evil-next-flyspell-error
	"S-M-[" #'org-backward-element
	"S-M-]" #'org-forward-element
	"g h" #'org-up-element
	"g l" #'org-down-element
	"g k" nil
	"g j" nil
	"[ [" #'evil-backward-section-begin
	"[ ]" #'evil-backward-section-end
	"] ]" #'evil-forward-section-begin
	"] ]" #'evil-forward-section-end
	"C-S-h" #'org-shiftleft
	"C-S-l" #'org-shiftright
	"M-h" #'org-metaleft
	"M-l" #'org-metaright
	"M-k" #'org-metaup
	"M-j" #'org-metadown
	"M-RET" #'org-meta-return)
(my/localleader-def '(normal visual motion) 'org-mode-map
	"l l" #'org-insert-link
	"l t" #'org-toggle-link-display
    "y" #'org-id-copy)
;; It's a magic and shaman's dances:
(my/evil-define-key '(normal visual motion) 'org-mode-map
	"[ c" #'org-babel-previous-src-block
	"] c" #'org-babel-next-src-block)
;; It's a magic and shaman's dances:
(my/evil-define-key '(normal visual motion) 'org-mode-map
    "[ l" #'org-previous-link
    "] l" #'org-next-link)
(my/localleader-def nil 'org-mode-map
	"e" #'org-export-dispatch)
(define-key org-mode-map (kbd "C-c C-j") #'counsel-org-goto)
#+end_src

Отрубим мешающиеся клавиши, что затирают творение выше.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'evil-collection-unimpaired-mode-map
	"[ l" nil
	"] l" nil)
(define-key org-mode-map (kbd "C-,") nil)
#+end_src

** Разнообразная реакция на Enter (RET)

При нажатии Enter попробуем узнать тип объекта под курсором и в
зависимости от него вызвать соответствующую функцию.

Определим функцию для определения типа объекта под курсором.  Функция
возвращает информацию о типе org-объекта, которая может быть одним из
символов:
- button
- citation, citation-reference
- headline
- clock
- footnote-reference
- footnote-definition
- planning, timestamp
- table, table-row
- table-cell
- babel-call
- statistics-cookie
- src-block, inline-src-block
- latex-fragment, latex-environment
- link
- link-image
- item
- paragraph

#+begin_src emacs-lisp :tangle yes
(defun my/object-type-at-point ()
    (if (button-at (point))
        'button
        (let* ((context (org-element-context))
               (type (org-element-type context)))
            (while (and context
                        (memq type '(verbatim
                                     code
                                     bold
                                     italic
                                     underline
                                     strike-through
                                     subscript
                                     superscript)))
                (setq context (org-element-property :parent context)
                      type (org-element-type context)))
            (my/org--correct-object-type type context))))

(defun my/org--correct-object-type (type context)
    (pcase type
        (`link
         (if (my/org--link-image-p context) 'link-image type))
        (_
         type)))

(defun my/org--link-image-p (context)
    (let* ((lineage (org-element-lineage context '(link) t))
           (path (org-element-property :path lineage)))
        (or (equal (org-element-property :type lineage) "img")
            (and path (image-type-from-file-name path)))))
#+end_src

Теперь воткнем функцию-обработчик клавиши Enter. Содержимое
обработчика будет пополняться по мере надобности.

#+begin_src emacs-lisp :tangle yes
(defun my/dwim-at-point (&optional arg)
    (interactive "P")
    (let ((type (my/object-type-at-point)))
        (pcase type

            (`link
             (org-open-at-point arg))

            (`link-image
             (my/org-toggle-inline-images-in-subtree (org-element-at-point)))

            ((or `latex-fragment `latex-environment)
             (org-latex-preview arg))

            (`item
             (let ((match (and (org-at-item-checkbox-p)
                               (match-string 1))))
                 (org-toggle-checkbox (if (equal match "[ ]") '(16)))))  ; Set '-' to checkbox.
            ((or `table `table-row)
             (if (org-at-TBLFM-p)
                 (org-table-calc-current-TBLFM)
                 (ignore-errors
                     (save-excursion
                         (goto-char (org-element-property :contents-begin context))
                         (org-call-with-arg 'org-table-recalculate (or arg t))))))

            (`table-cell
             (org-table-blank-field)
             (org-table-recalculate arg)
             (when (and (string-empty-p (string-trim (org-table-get-field)))
                        (bound-and-true-p evil-local-mode))
                 (evil-change-state 'insert)))

            (_
             (org-ctrl-c-ctrl-c arg))
            )))

(defun my/org-toggle-inline-images-in-subtree (object &optional refresh)
    "Refresh inline image previews in the current heading/tree."
    (let* ((beg (or (org-element-property :begin object)
                    (if (org-before-first-heading-p)
                        (save-excursion (point-min))
                        (save-excursion (org-back-to-heading) (point)))))
           (end (or (org-element-property :end object)
                    (if (org-before-first-heading-p)
                        (save-excursion (org-next-visible-heading 1) (point))
                        (save-excursion (org-end-of-subtree) (point)))))
           (overlays (cl-remove-if-not (lambda (ov)
                                           (overlay-get ov 'org-image-overlay))
                                       (ignore-errors (overlays-in beg end)))))
        (dolist (ov overlays nil)
            (delete-overlay ov)
            (setq org-inline-image-overlays (delete ov org-inline-image-overlays)))
        (when (or refresh (not overlays))
            (org-display-inline-images t t beg end)
            t)))
#+end_src

Определяем поведение клавиши Enter для evil.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key '(normal visual motion) 'org-mode-map
               "RET" #'my/dwim-at-point)
#+end_src

** Открытие org-ссылки в том же окне

Открывать org-ссылку в другом окне оказалось очень неудобно. Сделаем
открытие ссылки в том же окне, где и сам org-файл. Правило это
задается в списке =org-link-frame-select=. Заменим
вызов 'find-file-other-window на 'find-file.

#+begin_src emacs-lisp :tangle yes
(let* ((pair (assq 'file org-link-frame-setup)))
    (setcdr pair 'find-file))
#+end_src

** Директория для org-файлов и прочей org-кухни

If you use `org' and don't want your org files in the default location below, change `org-directory'. It must be set before org loads!

#+begin_src emacs-lisp :tangle yes
(setq org-directory (concat (getenv "HOME") "/org"))
#+end_src

** Подгрузка остальных пакетов

#+begin_src emacs-lisp :tangle yes
(use-package org-cliplink
	:ensure t)
(use-package orgit
	:ensure t)
(use-package ox-clip
	:ensure t)
(use-package toc-org
	:ensure t)
(use-package restclient
	:ensure t)
(use-package company-restclient
	:ensure t)
(use-package know-your-http-well
	:ensure t)
#+end_src

** Подгрузка пакетов для запуска скриптов в org-babel блоках
   :PROPERTIES:
   :ID:       c98e419e-f7e9-456d-b8f3-5037f0af775b
   :END:

Подгружаем пакеты для запуска скриптов в org-babel блоках.
Поддержка языков прописывается в [[id:cb53569d-930e-42f1-925b-8c3b660f9c4d][разделе]] программирования.

#+begin_src emacs-lisp :tangle yes
(use-package ob-async
    :ensure t)
(use-package ob-go
    :ensure t)
(use-package ob-restclient
    :ensure t)
(use-package ob-rust
    :ensure t)
#+end_src

** Перенос длинных строк по словам

В org-mode удобно видеть перенос строк по словам.

Чтобы сделать простой перенос строк, надо вызвать функцию
=toggle-truncate-lines=, а чтобы перенос строк был по словам, надо
добавить к ней вызов =toggle-word-wrap=.  Определим функцию, которая
объединяет эти два вызова.

#+begin_src emacs-lisp :tangle yes
(defun my/set-word-wrap ()
	(interactive)
	(toggle-word-wrap)
	(toggle-truncate-lines))
#+end_src

Теперь добавим обработчик для режима org-mode. Но надо быть
осторожным: если где-то будет добавлен такой же обработчик на
text-mode, то он отменит перенос строк. :)

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'my/set-word-wrap)
#+end_src

А на функцию выше повесим горячие клавиши (пригодится).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "t w" #'my/set-word-wrap)
#+end_src

** Поддержка org-календаря

Определим клавиши навигации по org-календарю на привычные "hjkl".

#+begin_src emacs-lisp :tangle yes
(define-key org-read-date-minibuffer-local-map (kbd "M-h") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-day 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-l") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-day 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-k") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-week 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-j") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-week 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-H") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-month 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-L") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-month 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-K") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-year 1))))
(define-key org-read-date-minibuffer-local-map (kbd "M-J") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-year 1))))
#+end_src
   
** Карсивые метки списков

Поставим красивые метки списков (bullets) посредством пакета =org-bullets=.

#+begin_src emacs-lisp :tangle yes
(use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

** Отступы в src-блоках

Убираем бесячий автоотступ при сохранении src-блоков.

#+begin_src emacs-lisp :tangle yes
(setq org-src-preserve-indentation t)
#+end_src

** Автоматическое схлопывание org-babel блоков

Есть способ схлопывать все org-babel блоки на открытии org-файла.
Делается это или глобально через установку переменной =org-hide-block-startup=,
или через установку таких вот взамоисключающих заголовков в нужных org-файлах:

: #+STARTUP: hideblocks
: #+STARTUP: nohideblocks

Для выборочного схлопывания/показа блоков напишем обрботчик даух новых аргументов:
- =:hidden=  - блок показывается схлопнутым,
- =:visible= - блок блок показывается развернутым.
Эти аргументы можно применять в сочетании с командами выше (=nohideblocks=, =hideblocks=).

#+begin_src emacs-lisp :tangle yes
(defun my/individual-visibility-source-blocks ()
    "Fold blocks with argument :hidden in the current buffer."
    (interactive)
    (let ((block-types '(center-block comment-block dynamic-block example-block
                         export-block quote-block special-block src-block verse-block)))
        (org-block-map
         (lambda ()
             (let ((element (org-element-at-point)))
                 (when (member (org-element-type element) block-types)
                     (let ((arguments (cl-third (org-babel-get-src-block-info t))))
                         (cond ((cl-assoc ':hidden arguments)
                                (org-hide-block-toggle t nil element))
                               ((cl-assoc ':visible arguments)
                                (org-hide-block-toggle 'off nil element))))))))))
#+end_src

Обработчик, представленный выше, будет срабатывать при открытии org-документа.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'my/individual-visibility-source-blocks)
#+end_src

Скрытие блоков слетает на применении org-cycle,
поэтому запилим горячие клавиши для принудительного схлопывания/показа:
- org-babel блоков с аргументами =:hidden= или =:visible=,
- всех org-babel блоков в буфере.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "s" '(:ingore t :which-key "fold")
                    "s o" '(my/individual-visibility-source-blocks
                            :which-key "Fold :hidden src-blocks")
                    "s O" '(org-hide-block-all
                            :which-key "Fold all stc-blocks except :visual"))
#+end_src

** Параметры экспортирования из org-mode

Более полно про параметры экспорта можно прочитать на [[https://orgmode.org/manual/Export-Settings.html][странице документации]].

Убираем TeX-овые над/подстрочные шрифты.
Включить для отдельных документов можно опцией: "#+options: ^:t"

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-sub-superscripts nil)
#+end_src

Убираем автоматические номера из заголовков.
Включить для отдельных документов можно опцией: "#+options: num:t"

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-section-numbers nil)
#+end_src

Соблюдаем все переносы строк, что и в исходном org-файле.
Включить для отдельных документов можно опцией: "#+options: \n:t"
(Пришел к тому, что надо убрать.)

#+begin_example emacs-lisp :tangle yes
(setq org-export-preserve-breaks t)
#+end_example

Убираем автора из экспорта.
Включить для отдельных документов можно опцией: "#+options: author:t"

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-author nil)
#+end_src

Убираем оглавление путем указания ему неопределенного места.
Включить для отдельных документов можно опцией: "#+options: toc:t"
Подробнее смотри на [[https://orgmode.org/manual/Table-of-Contents.html][странице документации по оглавлению]].

#+begin_src emacs-lisp :tangle yes
(setq org-export-with-toc nil)
#+end_src

** Экспорт в PDF через Latex

Русский шрифт заработает совместно с установкой:

#+begin_example bash
# Ubuntu:
sudo apt install texlive-lang-cyrillic
# Arch Linux:
sudo pacman -S texlive-langcyrillic
sudo pacman -S texlive-latexextra
#+end_example

В настройки по-умолчанию (=org-latex-default-packages-alist=) уже
прописаны следующие заголовки (файл [[./custom.el][custom.el]]):

#+begin_quote
#+latex_header: \usepackage[utf8x]{inputenc}
#+latex_header: \usepackage[T2A]{fontenc}
#+latex_header: \usepackage[russian,english]{babel}
#+end_quote

** LaTeX preview. Формулы проямо в org-тексте

Здесь не будет настроек, а только памятка, чтобы вспоминать, как этим
пользоваться.

Сперва требуется установить =dvipng= (я установил еще вдогонку
=preview-latex-style=):
#+begin_example bash
# Ubuntu:
sudo apt install dvipng preview-latex-style
# Arch Linux: устанавливается вместе с пакетом texlive-bin.
#+end_example

Этого достаточно! Теперь можно вставлять прямо в org-текст TeX'овские
штуки:

| вторая степень          | $$x^2$$            |
| корень из дискриминанта | $$\sqrt{b^2-4ac}$$ |

Чтобы показать это надо или выделить текст с формулами, или навести
курсор на нужную формулу, после чего вызвать функцию =(org-latex-preview)=
(стандартные клавиши - =C-v C-x C-l= и просто =RET= для Doom).

Чтобы формулы показывались сразу при открытии org-файла, нужно в
заголовке startup указать значение =latexpreview=.

При экспорте в LaTeX+PDF все формулы будут преобразованы в
соответствующие изображения.

И еще маленькое удобство: при экспорте во что угодно спецсимволы типа
\lambda, \Sigma изображаются соответстущими символами греческого
алфавита.

** LaTeX preview. Ручное изменение размеров формул (костыль)

На одном из ноутов формулы стали не выше текстовой строки.
Для этого сделаем костыль по увеличению и уменьшению формул.

#+begin_src emacs-lisp :tangle yes
(defun my/latex-preview-scale-set (scale)
    (if (> scale 0.0)
            (setq org-format-latex-options (plist-put org-format-latex-options
                                                      :scale (float scale)))
        (plist-get org-format-latex-options :scale)))

(defun my/latex-preview-scale-inc ()
    (let ((prev-scale (plist-get org-format-latex-options :scale)))
        (my/latex-preview-scale-set (+ prev-scale 1.0))))

(defun my/latex-preview-scale-dec ()
    (let ((prev-scale (plist-get org-format-latex-options :scale)))
        (my/latex-preview-scale-set (- prev-scale 1.0))))
#+end_src

Вешаем на горячие клавиши и приделываем сообщения. Поскольку быстрее всего сразу
назначить величину масштаба (например 4), то первой предусмотрим такую операцию.
Остальные две - увеличить и уменьшить.

#+begin_src emacs-lisp :tangle yes
(defun my/set-scael-for-latex-preview (scale)
	(interactive (list (read-string "Enter LaTeX preview scale: ")))
	(my/latex-preview-scale-set (float (string-to-number scale)))
	(message "Latex scale = %f"
			 (plist-get org-format-latex-options :scale)))

(defun my/increace-scale-for-latex-preview ()
	(interactive)
	(my/latex-preview-scale-inc)
	(message "Latex scale = %f"
			 (plist-get org-format-latex-options :scale)))

(defun my/decreace-scale-for-latex-preview ()
	(interactive)
	(my/latex-preview-scale-dec)
	(message "Latex scale = %f"
			 (plist-get org-format-latex-options :scale)))

(my/localleader-def nil 'org-mode-map
                    "j" '(:ignore t :which-key "latex")
                    "j s" #'my/set-scael-for-latex-preview
                    "j k" #'my/increace-scale-for-latex-preview
                    "j j" #'my/decreace-scale-for-latex-preview)
#+end_src

** Копирование ссылки в буфер обмена

Быстрое вытаскивание ссылки из org-текста. Ссылка копируется сразу в три регистра: `+', `*' и `"'.

#+begin_src emacs-lisp :tangle yes
(defun my/org-copy-link-url ()
    (interactive)
    (kill-new (org-element-property :raw-link (org-element-context)))
    (let ((text (evil-get-register ?\")))
        (evil-set-register ?+ text)
        (evil-set-register ?* text)
        (evil-set-register ?0 text)
        (message text)))
#+end_src

Горячие клавиши для копирования ссылки.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "l" '(:ignore t :which-key "links"))
(my/localleader-def nil 'org-mode-map
                    "l y" #'my/org-copy-link-url)
#+end_src

** Преобразование URL в ссылку с именем задачи или файла

Часто в org-документах перевожу URL задач из Jira типа:
: https://....ru/jira/TASK-123
в ссылки, подобные этой:
: [[https://....ru/jira/TASK-123][TASK-123]]

Чтобы сократить время на редактирование таких ссылок, сделаем функцию.
Она принимает контекст org-элемента под курсором и в случае, если это URL,
создает ссылку, как показано выше.

Функция делает то же самое и для ссылок на файлы.

Параметром является ссылка на функцию преобразования сырой ссылки. Нужно это для
создания ссылки на открытие файла системой.

#+begin_src emacs-lisp :tangle yes
(defun my/make-task-link--common (&optional raw-link-converter)
    (let* ((element (org-element-context))
           (type (org-element-property :type element))
           (raw-link (org-element-property :raw-link element))
           (link (if raw-link-converter
                         (funcall raw-link-converter type raw-link)
                     raw-link))
           (is-url (org-url-p raw-link)))
        (when (or is-url
                  (equal type "file"))
            (let* ((start (org-element-property :begin element))
                   (end (org-element-property :end element))
                   (path (org-element-property :path element))
                   (parts (seq-filter (lambda (str)
                                          (not (string-empty-p str)))
                                      (split-string path "/")))
                   (task-name (car (last parts))))
                (delete-region start end)
                (insert (concat "[[" link "][" task-name "]]" (if is-url " " "")))
                (goto-char start)))))
#+end_src

Для файлов может быть полезна ссылка сразу на его открытие в системе (gio open).
Напишем функцию преобразования пути файла в его открытие.

#+begin_src emacs-lisp :tangle yes
(defun my/make-link-for-call--convert-file-raw-link-for-call (type raw-link)
    (if (equal type "file")
            (concat "elisp:(call-process \"gio\" nil 0 nil \"open\" \"" raw-link "\")")
        raw-link))
#+end_src

Пара конечных функций для горячих клавиш ("ссылка" и "открытие файла").

#+begin_src emacs-lisp :tangle yes
(defun my/make-task-link ()
    (interactive)
    (my/make-task-link--common))

(defun my/make-link-for-call ()
    (interactive)
    (my/make-task-link--common #'my/make-link-for-call--convert-file-raw-link-for-call))
#+end_src

Добавляем горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
	"l m" #'my/make-task-link
	"l M" #'my/make-link-for-call)
#+end_src

** Клавиши для работы с таблицами

Восстановим привычную раскладку из Doom для работы с таблицей.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
    "b i c" #'org-table-insert-column
    "b i h" #'org-table-insert-hline
    "b i H" #'org-table-hline-and-move
    "b i r" #'org-table-insert-row
    "b d c" #'org-table-delete-column
    "b d r" #'org-table-kill-row
    "b -" #'org-table-insert-hline
    "b a" #'org-table-align
    "b c" #'org-table-create-or-convert-from-region
    "b e" #'org-table-edit-field
    "b f" #'org-table-edit-formulas
    "b g" #'org-table-toggle-column-width
    "b h" #'org-table-field-info
    "b r" #'org-table-recalculate
    "b R" #'org-table-recalculate-buffer-tables
    "b s" #'org-table-sort-lines
    "b t f" #'org-table-toggle-formula-debugger
    "b t o" #'org-table-toggle-coordinate-overlays)
#+end_src

Назначим описание этой группы клавиш.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
    "b" '(:ignore t :which-key "tables")
    "b d" '(:ignore t :which-key "delete")
    "b i" '(:ignore t :which-key "insert")
    "b t" '(:ignore t :which-key "toggle"))
#+end_src

** Показ картинок-результатов выполнения org-babel блоков

Картинки отрисовываются сразу после выполнения org-babel блоков.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src

** Показ времени выполнения babel-блока

Здесь вычисляется время выполнения babel-блока.
Результат пойдет в регистры ="= и, внимание!, =t=.

#+begin_src emacs-lisp :tangle yes
(defun my/time-call-decorator (time-call &rest args)
    "Decorator for execiting of org-mode babel.

The decorator measures time of babel execution,
shows it in message and put the result into registers `\"' and `t'."
    ;; (message "Ohai %s" args)
    (let ((start-time (float-time))
          (delta 0.0)
          (formatted-delta "")
          (result (apply time-call args)))
        (setq delta (- (float-time) start-time))
        (setq formatted-delta (format "%f sec" delta))
        (evil-set-register ?\" formatted-delta)
        (evil-set-register ?t formatted-delta)
        (message "Execution time is %f seconds" delta)
        result))
#+end_src

В elisp есть подобие декоратора к функции.
Делается посредством функции =advice-add=.
Ниже в ее параметрах используется параметр =:around=.
Чтобы убрать декоратор, есть функция =advice-remove=.

Вешаем декоратор для подсчета времени на функцию =org-babel-execute-src-block=.

#+begin_src emacs-lisp :tangle yes
(advice-add 'org-babel-execute-src-block :around #'my/time-call-decorator)
#+end_src

Чтобы убрать декоратор к вычислению babel, надо выполнить это:

#+begin_example
(advice-remove 'org-babel-execute-src-block #'my/time-call-decorator)
#+end_example

** Слайды и презентации

Для показа интерактивных презентаций воспользуемся пакетом
=org-tree-slide=.

#+begin_src emacs-lisp :tangle yes
(use-package org-tree-slide
	:ensure t)
#+end_src

Однако, в чистом виде слайды выглядят некрасиво. Будем облагораживать
вид презентаций вручную.

Определим функции, которые скрывают и показывают операторные скобки
`#+begin_...' - `#+end_...' через изменение цвета текста. Цвет
запоминается на время в стек и из него же достается для восстановления
исходного состояния.

#+begin_src emacs-lisp :tangle yes
(setq my/begin:end-block-delimiters nil)

(defun my/hide-begin:end-block-delimiters ()
    (let ((begin-color (face-foreground 'org-block-begin-line nil 'default))
          (end-color (face-foreground 'org-block-end-line nil 'default)))
        (setq my/begin:end-block-delimiters
              (cons `(,begin-color . ,end-color) my/begin:end-block-delimiters))
        (set-face-attribute 'org-block-begin-line nil
                            :foreground (face-background 'org-block-begin-line nil 'default))
        (set-face-attribute 'org-block-end-line nil
                            :foreground (face-background 'org-block-end-line nil 'default))))

(defun my/show-begin:end-block-delimiters ()
    (let ((colors (car my/begin:end-block-delimiters)))
        (setq my/begin:end-block-delimiters (cdr my/begin:end-block-delimiters))
        (set-face-attribute 'org-block-begin-line nil :foreground (or (car colors) 'unspecified))
        (set-face-attribute 'org-block-end-line nil :foreground (or (cdr colors) 'unspecifie))))
#+end_src

Теперь определим функции, которые:
- отцентрируют текст (пакет =centered-window-mode=),
- скроют отвлекающие от слайда внимание элементы.

#+begin_src emacs-lisp :tangle yes
(defun my/slide-view-on ()
    "Prepare window for org-tree-slide-mode."
    (interactive)
    (if (eq major-mode 'org-mode)
            (progn
                (my/hide-begin:end-block-delimiters)
                ;; (doom-disable-line-numbers-h)
				(my/set-word-wrap)
                (my/hide-header-line)
                (highlight-indent-guides-mode -1)
                (centered-window-mode 1)
                (org-tree-slide-mode 1))
        (message "For org-mode only!")))

(defun my/slide-view-off ()
    "Returt window state from org-tree-slide-mode."
    (interactive)
    (if (eq major-mode 'org-mode)
            (progn
                (centered-window-mode -1)
                (highlight-indent-guides-mode 1)
                (my/show-header-line)
                (my/show-begin:end-block-delimiters)
                ;; (doom-enable-line-numbers-h)
				(my/set-word-wrap)
                (org-tree-slide-mode -1))
        (message "For org-mode only!")))
#+end_src

Сделаем переключатель режима презентации и обычного режима редактирования.

#+begin_src emacs-lisp :tangle yes
(setq my/slide-view-state nil)

(defun my/slide-view-toggle ()
    "Toggle window state for org-tree-slide-mode."
    (interactive)
    (setq my/slide-view-state (not my/slide-view-state))
    (if my/slide-view-state
            (my/slide-view-on)
        (my/slide-view-off)))
#+end_src

Повесим переключение в режим показа презентации на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'org-mode-map
    "t c" #'my/slide-view-toggle)
#+end_src

А это из документации к org-tree-slide, листаем слайды.

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "org-tree-slide"
    (define-key org-tree-slide-mode-map (kbd "<f9>") 'org-tree-slide-move-previous-tree)
    (define-key org-tree-slide-mode-map (kbd "<f10>") 'org-tree-slide-move-next-tree))
#+end_src

** Новый буфер в режиме org-mode

Очень часто открываю новый буфер, после чего устанавливаюему режим org-mode. Автоматизируем эти действия.

#+begin_src emacs-lisp :tangle yes
(defun my/open-new-buffer-in-org-mode ()
    (interactive)
    (let ((buffer (generate-new-buffer "*new Org-mode*")))
        (set-window-buffer nil buffer)
        (with-current-buffer buffer
            (org-mode))))
#+end_src

И горячие клавиши к созданию нового org-буфера.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "b o" #'my/open-new-buffer-in-org-mode)
#+end_src

** Agenda

Настраиваем Агенду.

#+begin_src emacs-lisp :tangle yes
(require 'org-agenda)
(setq-default org-agenda-deadline-faces '((1.001 . error)
                                          (1.0 . org-warning)
                                          (0.5 . org-upcoming-deadline)
                                          (0.0 . org-upcoming-distant-deadline))
              org-agenda-window-setup 'current-window
              org-agenda-skip-unavailable-files t
              org-agenda-span 'month
              org-agenda-start-on-weekday nil
              org-agenda-start-day "-3d"
              org-agenda-inhibit-startup t)
(evil-define-key '(normal visual motion) org-agenda-mode-map (kbd my/leader) nil)
#+end_src

(Вид Агенды еще предстоит доделать. По непонятной мне причине агенда
не раскрашена цветами.)

Здесь автоматизированы мои действия по созданию вкладки с agenda'ой.
Открытие новой вкладки (tab) со списком задач
Повесим эти действия на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(defun my/new-tab-with-agenda-list ()
    (interactive)
    (my/new-tab-with-name "agenda")
    (org-agenda-list)
    (delete-other-windows))

(my/leader-def nil 'override
               "o" '(:ignore t :which-key "open")
               "o a" '(:ignore t :which-key "agenda"))
(my/leader-def nil 'override
               "o a a" '(org-agenda :which-key "Agenda")
               "o A" '(org-agenda :which-key "Agenda")
               "o a n" #'my/new-tab-with-agenda-list)
#+end_src

Докатим привычные горячие клавиши из Doom для работы с TODO.

#+begin_src emacs-lisp :tangle yes
(my/localleader-def nil 'org-mode-map
                    "d" '(:ignore t :which-key "tasks"))
(my/localleader-def nil 'org-mode-map
                    "t" #'org-todo
                    "d s" #'org-schedule
                    "d d" #'org-deadline)
#+end_src

** Agenda. Статусы задач

Здесь определяются нужные мне статусы задач.

#+begin_src emacs-lisp :tangle yes
(setq my/org-todo-keywords
      '((sequence "TODO(t)" "IN-WORK(w)" "PAUSE(p)" "|" "DONE(d)" "CANCELED(c)" "SOMETIME(s)")))
(setq org-todo-keywords my/org-todo-keywords)
(defun my/set-org-todo-keywords ()  ; Принудительное восстановление статусов задач.
    (interactive)
    (setq org-todo-keywords my/org-todo-keywords))
#+end_src

Навесим теперь статусы, куда сработают.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-agenda-mode-hook #'my/set-org-todo-keywords)
(my/set-org-todo-keywords)
#+end_src

** Journal

Ведение дневника и ежедневных заметок.

Установим пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package org-journal
    :ensure t
    :config
    (setq org-journal-dir (concat org-directory "/journal")))
#+end_src

И горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
               "n j" '(:ignore t :which-key "journal")
               "n j j" #'org-journal-new-entry
               "n j J" #'org-journal-new-scheduled-entry
               "n j d" #'org-journal-new-date-entry
               "n j s" #'org-journal-search-forever)
#+end_src

* Терминалы

** eshell

Настроим приглашение для eshell.

/TODO: Что-то не так с настройками приглашения в командной строке./

#+begin_src emacs-lisp :tangle yes
;; (setq eshell-prompt-function
;;       (lambda ()
;;           (concat (eshell/pwd)
;;                   " " (my/git-current-branch)
;;                   " λ ")))

(defun my/git-current-branch ()
    "Return current git-branch or empty string."
    (let ((branch (shell-command-to-string
                   "git branch 2>/dev/null | grep \'^*\' | colrm 1 2 | tr -d \'\\n\'")))
        (if (string-empty-p branch)
                ""
            (concat "[" branch "]"))))
#+end_src

Вызов терминала eshell.  Терминал создается по возможности свой для
каждого рабочего пространства.  Если буфер с таким терминалом уже
создан, то он показывается в окне или окно с таким терминалом
скрывается.

#+begin_src emacs-lisp :tangle yes
(defun my/popup-eshell-toggle ()
    (interactive)
    (let* ((buffer-name (format "*eshell-popup:%s*"
                                (my/--get-current-persp-name)))
           (buffer (get-buffer buffer-name))
           (window))
        (unless buffer
            (setq buffer (get-buffer-create buffer-name))
            (with-current-buffer buffer
                (eshell-mode)))
        (if-let ((window (get-buffer-window buffer)))
            (delete-window window)
            (pop-to-buffer buffer))))
#+end_src

Запилим горячие клавиши на вызов окошка eshell.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o e" #'my/popup-eshell-toggle
    "o E" #'eshell)
#+end_src

** vterm

Установим пакет. После установки будет запрос на компиляцию Vterm.

#+begin_src emacs-lisp :tangle yes
(use-package vterm
    :ensure t)
#+end_src

Вызов терминала vterm.  Терминал создается по возможности свой для
каждого рабочего пространства.  Если буфер с таким терминалом уже
создан, то он показывается в окне или окно с таким терминалом
скрывается.

#+begin_src emacs-lisp :tangle yes
(defun my/popup-vterm-toggle ()
    (interactive)
    (let* ((buffer (my/--get-vterm-buffer-create)))
        (if-let ((window (get-buffer-window buffer)))
            (delete-window window)
            (pop-to-buffer buffer))))

(defun my/--get-vterm-buffer-create ()
    (let* ((buffer-name (format "*vterm-popup:%s*"
                                (my/--get-current-persp-name)))
           (buffer (get-buffer buffer-name))
           (window))
        (unless buffer
            (setq buffer (get-buffer-create buffer-name))
            (with-current-buffer buffer
                (vterm-mode)))
        buffer))
#+end_src

Чтобы удобнее было работать с проектами, создадим новую вкладку с именем "term", в которую поместим буфер с терминалом vterm.

#+begin_src emacs-lisp :tangle yes
(defun my/open-term-in-new-tab ()
    (interactive)
    (let ((persp-name (my/--get-current-persp-name))
          (buffer (my/--get-vterm-buffer-create)))
        (tab-bar-new-tab)
        (tab-bar-rename-tab (format "vterm:%s" persp-name))
        (tab-bar-mode -1)
        (switch-to-buffer buffer)
        (when my/evil
            (evil-normal-state)
            (evil-emacs-state))))
#+end_src

Привычные горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o t" #'my/popup-vterm-toggle
    "o T" #'vterm
    "o v" #'my/open-term-in-new-tab)
#+end_src

* Инструменты внешние

** Treemacs

Дерево проектов. Полезная штука для анализа незнакомого кода. Немного глючит, но
со временем выравнивается.

#+begin_src emacs-lisp :tangle yes
(use-package treemacs
    :ensure t)
(use-package treemacs-projectile
    :ensure t)
#+end_src

Горячие клавиши для вызова дерева проектов.  Добавим переход в окно
treemacs при показе текущего файла в дереве проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/treemacs-find-file-and-select-tree-window ()
    (interactive)
    (treemacs-find-file)
    (treemacs-select-window))

(my/leader-def nil 'override
    "o p" #'treemacs
    "o P" #'my/treemacs-find-file-and-select-tree-window
    "o w" #'treemacs-add-project-to-workspace)

(my/evil-define-key 'normal 'treemacs-mode-map
    ">" #'treemacs-increase-width
    "<" #'treemacs-decrease-width)
#+end_src

Вызов меню для treemacs.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key 'normal 'treemacs-mode-map
    "?" #'treemacs-common-helpful-hydra)
               
#+end_src

** Magit

Один из самых лучших и удобных клиентов для Git.

Загрузим необходимые пакеты и определим некоторые базовые клавиши.

#+begin_src emacs-lisp :tangle yes
(use-package magit
    :ensure t
    :config
    ;; Define some keys:
    (my/leader-def nil 'override
                   "g" '(:ignore t :which-key "git")
                   "g g" #'magit-status
                   "g b" #'magit-branch-checkout
                   "g /" #'magit-dispatch))
(use-package magit-gitflow
    :ensure t)
(use-package magit-popup
    :ensure t)
(use-package magit-todos
    :ensure t)
#+end_src

Запилим горячие клавиши на полезные операции. Итак:

Горячие клавиши для лога текущей ветки.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g u" #'magit-log-head)
#+end_src

Горячие клавиши для лога файла в активном буфере.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g h" #'magit-log-buffer-file)
#+end_src

Горячие клавиши для просмотра логов от git-команд.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g p" #'magit-process-buffer)
(my/leader-def 'normal 'magit-diff-mode-map
    "g p" #'magit-process-buffer)
#+end_src

Горячие клавиши для выкачки информации по всем веткам (magit-fetch-all).

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g a" #'magit-fetch-all)
#+end_src

Блеймер (подробный)

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g B" #'magit-blame-addition)
#+end_src

** Подсветка разницы с HEAD в каждой строке

Метки строк по состоянию в Git добавим через пакет =Git-gutter=.

#+begin_src emacs-lisp :tangle yes
(use-package git-gutter-fringe
	  :ensure t
	  :config
	  (global-git-gutter-mode t)
	  (setq git-gutter:update-interval 1))
#+end_src

** Blamer (смотрелка заголовков последних коммитов в коде)

Пример скопирован [[https://github.com/Artawower/blamer.el][отсюда]]. Запомню его тут, чтобы долго не искать.

#+begin_example emacs-lisp :tangle yes
(use-package blamer
  :bind (("s-i" . blamer-show-commit-info))
  :defer 20
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                    :background nil
                    :height 140
                    :italic t)))
  :config
  (global-blamer-mode 1))
#+end_example

Теперь сделаем свою конфигурацию.

#+begin_src emacs-lisp :tangle yes
(use-package blamer
    :ensure t
    :config
    (global-blamer-mode -1))
#+end_src

Посадим на горячие клавиши переключение blamer-mode.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "g m" #'blamer-mode)
#+end_src

** Docker

Установка пакетов для работы с docker.

#+begin_src emacs-lisp :tangle yes
(use-package docker
    :ensure t)
(use-package docker-tramp
    :ensure t)
(use-package dockerfile-mode
    :ensure t)
#+end_src

Горячие клавиши для работы с docker. Тут хватает только вызова
основной функции, а далее по меню все понятно.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o D" #'docker)
#+end_src

** Календарь, как его представление

Включение модуля "calendar" позволяет смотреть свои дела из Agenda в виде календаря.

#+begin_src emacs-lisp :tangle yes
(use-package calfw
	:ensure t
	:config
	(setq cfw:face-item-separator-color nil
		  cfw:render-line-breaker 'cfw:render-line-breaker-none
		  cfw:fchar-junction ?╋
		  cfw:fchar-vertical-line ?┃
		  cfw:fchar-horizontal-line ?━
		  cfw:fchar-left-junction ?┣
		  cfw:fchar-right-junction ?┫
		  cfw:fchar-top-junction ?┯
		  cfw:fchar-top-left-corner ?┏
		  cfw:fchar-top-right-corner ?┓))

(use-package calfw-org
	:ensure t)
(use-package calfw-cal
	:ensure t
	:commands (cfw:cal-create-source))

(use-package calfw-ical
	:ensure t
	:commands (cfw:ical-create-source))

;; (use-package org-gcal
;; 	:defer t)
#+end_src

Отключим показ ненужных праздников:

#+begin_src emacs-lisp :tangle yes
(setq cfw:display-calendar-holidays nil)
#+end_src

Ниже запилим сочетания клавиш.

Вызов буфера с cfw-календарем:

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o a c" #'cfw:open-org-calendar)
#+end_src

Вызов Agenda для выбранного дня:

#+begin_src emacs-lisp :tangle yes
(define-key cfw:calendar-mode-map "d" #'cfw:org-open-agenda-day)
#+end_src

* Инструменты свои
  
** Словарик под StarDict

Как установить словарик с нуля?

1. Установить утилиту sdcv:
   : sudo pacman -S sdcv
2. В Emacs добавить два пакета:
   - sdcv
   - posframe
3. Скачать словари из http://download.huzheng.org/dict.org/ .

Установим необходимые пакеты.

#+begin_src emacs-lisp :tangle yes
(use-package sdcv
    :ensure t)
(use-package posframe
    :ensure t)
#+end_src

Общий путь, где лежит словарик.

#+begin_src emacs-lisp :tangle yes
(setq my/sdcv-path (concat my/config-dir "/dictionaries/Lingvo-stardict"))
#+end_src

Чтобы утилита sdcv видела словари, выставим к ним путь в переменную среды.

#+begin_src emacs-lisp :tangle yes
(setenv "STARDICT_DATA_DIR" my/sdcv-path)
(require 'sdcv)
(setq sdcv-dictionary-data-dir my/sdcv-path)
#+end_src

Горячие клавиши.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "s g" '(sdcv-search-input :which-key "Dictionary search word by input")
    "s w" '(sdcv-search-pointer :which-key "Dictionary search at point"))
#+end_src

** Калькулятор на Python

Из удобств установлен пакетик =live-py-mode=. Установим его.

#+begin_src emacs-lisp :tangle yes
(use-package live-py-mode
    :ensure t)
#+end_src

При запуске =M-x live-py-mode= в открытом py-файле (ассоциация буфера
с файлом - это важно, при этом сам файл на диске может и
отсутствовать) окошко делится пополам, и в правом окне видим
результаты python-выражений из левого окна. Получился такой удобный
python-калькулятор (и не только).

Запилим функцию для быстрого создания калькулятора из всего
вышесказанного.

Ниже имя файла для буфера с 'калькулятором' и имя фрейма для него.

#+begin_src emacs-lisp :tangle yes
(setq my/calculator-python-filename "_calculator-python.py"
      my/calculator-python-framename "*-calculator-python-*")

(defun my/calculator--get-python-filename ()
    (let ((filename (concat (temporary-file-directory)
                            "/" my/calculator-python-filename)))
        (string-replace "//" "/" filename)))
#+end_src

Позаботимся о вставке выделенного текста в буфер 'калькулятора'.

#+begin_src emacs-lisp :tangle yes
(defun my/get-selection-and-deselect ()
    "Return selected text in current buffer or empty string."
    (if (region-active-p)
            (let ((selection (buffer-substring-no-properties (region-beginning) (region-end))))
                (deactivate-mark)
                selection)
        ""))
#+end_src

'Калькулятор' создается в отдельном фрейме.  Если перед этим в
активном буфере был выделен текст, то этот текст будет добавлен в
буфер 'калькулятора'.  Результат кода ниже - функция, которая
открывает или закрывает фрейм с калькулятором (если тот был открыт).

#+begin_src emacs-lisp :tangle yes
(defun my/calculator-python-open ()
    "Open a frame with 'calulator' on live-py-mode."
    (interactive)
    (let* ((selection (my/get-selection-and-deselect))
           (buffer (find-file-noselect (my/calculator--get-python-filename)))
           (frame (make-frame)))
        (select-frame-set-input-focus frame)
        (set-frame-name my/calculator-python-framename)
        (switch-to-buffer buffer)
        (live-py-mode)
        (when (not (string-empty-p selection))
            (goto-char (point-max))
            (if (> (point-max) 1)
                    (progn (insert "\n\n")
                           (save-excursion (insert "# -----\n")
                                           (insert selection)))
                (save-excursion (insert selection))))
        (set-buffer-modified-p nil)))

(defun my/calculator-python-close (frame)
    "Delete the frame. Raise calculator buffer and set it to unmodified."
    (select-frame-set-input-focus frame)
    (switch-to-buffer my/calculator-python-filename)
    (live-py-mode -1)
    (set-buffer-modified-p nil)
    (let ((text (buffer-string)))
        (delete-frame nil t)
        (with-current-buffer (find-file-noselect (my/calculator--get-python-filename))
            (erase-buffer)
            (insert text)
            (set-buffer-modified-p nil))))

(defun my/calculator-python-toggle ()
    "Open or close frame with 'calulator' on live-py-mode."
    (interactive)
    (let ((frame (my/get-frame-by-name my/calculator-python-framename)))
        (if frame
                (my/calculator-python-close frame)
            (my/calculator-python-open))))
#+end_src

Горячие клавиши для python-калькулятора.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "o c" '(my/calculator-python-toggle :which-key "Calculator live on Python"))
#+end_src

* LSP сервер

** Установка

Грузим lsp-mode пакет. Инструкция тут: [[https://emacs-lsp.github.io/lsp-mode/page/installation/][LSP Mode - LSP support for Emacs]].

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
    :ensure t)
#+end_src

На странице пакета рекомендуют загрузить следующие пакеты:
- [[https://emacs-lsp.github.io/lsp-ui/#intro][lsp-ui]]        - for fancy sideline, popup documentation, VScode-like peek UI, etc.
- [[https://github.com/flycheck/flycheck][flycheck]]      - if you prefer the more popular flycheck over renewed flymake. lsp-mode will automatically pick it up.
- [[https://github.com/company-mode/company-mode][company-mode]]  - /(Installed)/ for completion popups.
- [[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]]  - for various tree based UI controls (symbols, errors overview, call hierarchy, etc.)
- [[https://github.com/emacs-lsp/helm-lsp][helm-lsp]]      - provides on type completion alternative of xref-apropos using helm.
- [[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]]       - provides on type completion alternative of xref-apropos using ivy.
- [[https://emacs-lsp.github.io/dap-mode][dap-mode]]      - if your language is supported by the debugger.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-ui
    :ensure t
    :init
    ;; (setq lsp-ui-sideline-code-actions-prefix "💡")
    :config
    (add-hook 'lsp-mode-hook #'lsp-ui-mode))
(use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode))
(use-package lsp-treemacs
    :ensure t)
(use-package helm-lsp
    :ensure t)
(use-package lsp-ivy
    :ensure t)
(use-package dap-mode
    :ensure t)
#+end_src

** Общие настройки

Информацию по списку LSP-серверов можно посмотреть [[https://emacs-lsp.github.io/lsp-mode/page/languages/][тут]].

Настройка визуальных особенностей LSP-серверов (взято [[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][отюда]]).
Оставлен такой комментарий, но работает и без этого замечания:
#+begin_quote
"Don't forget to set these variables *before* loading lsp-mode, otherwise they won't have effect"
#+end_quote

Symbol highlighting (подсветка имен).

#+begin_src emacs-lisp :tangle yes
(setq lsp-enable-symbol-highlighting t)
#+end_src

lsp-ui-doc - on hover dialogs. (всплывающие подсказки).
- cursor hover (keep mouse hover)
- mouse hover (keep cursor hover)
Здесь запретим самопоказ всплывающих подсказок по клавишным переходам
и оставим для перехода мышью.

Положение поставим верхнее ('top), а если будет не удобно, то можно
сделать рядом с курсором ('at-point).

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-doc-enable t)
(setq lsp-ui-doc-show-with-cursor nil)
(setq lsp-ui-doc-show-with-mouse t)
(setq lsp-ui-doc-position 'top)
#+end_src

Информацию об объекте можно показывать не только через lsp-ui в
сплывающем окне, но и через eldoc в минибуфере. Чтобы информация от
eldoc была полной, выставим соответствующий флажок.

#+begin_src emacs-lisp :tangle yes
(setq lsp-eldoc-render-all t)
#+end_src

Lenses (показ количества ссылок).

#+begin_src emacs-lisp :tangle yes
(setq lsp-lens-enable nil)
#+end_src

Headerline (где находимся - отображение в headline).

#+begin_src emacs-lisp :tangle yes
(setq lsp-headerline-breadcrumb-enable t)
#+end_src

Sideline code actions (действия над кодом (желтые лампочки)).
- whole sideline via
- code actions

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-sideline-enable t)
(setq lsp-ui-sideline-show-code-actions t)
#+end_src

Sideline hover symbols (какая-то информация по коду).
- disable whole sideline via
- hide only hover symbols

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-sideline-enable t)
(setq lsp-ui-sideline-show-hover nil)
#+end_src

Modeline code actions (действия над кодом в строке статуса).

#+begin_src emacs-lisp :tangle yes
(setq lsp-modeline-code-actions-enable t)
#+end_src

Разрешаем или запрещаем проверку на ошибки LSP-сервером.
(Для Python у LSP отвратительная проверка - отменим ее в пользу альтернативной.)

#+begin_src emacs-lisp :tangle yes
(setq lsp-diagnostics-disabled-modes (list 'python-mode))
#+end_src

Еще отменим LSP для imenu - тоже плохо справляется.

#+begin_src emacs-lisp :tangle yes
(setq lsp-enable-imenu nil)
#+end_src

Flycheck (or flymake if no flycheck is present).
Все значения можно найти [[https://emacs-lsp.github.io/lsp-mode/page/settings/diagnostics/][тут]] в этом списке:

: Type: (choice (const :tag Pick flycheck if present and fallback to flymake :auto)
:               (const :tag Pick flycheck :flycheck)
:               (const :tag Pick flymake :flymake)
:               (const :tag Use neither flymake nor lsp :none)
:               (const :tag Prefer flymake t)
:               (const :tag Prefer flycheck nil))

#+begin_src emacs-lisp :tangle yes
(setq lsp-diagnostics-provider :auto)  ;; may be ':auto
;; (setq lsp-diagnostics-provider :flycheck)  ;; may be ':auto
#+end_src

Sideline diagnostics (тексты ошибок).
- disable whole sideline via
- hide only errors

#+begin_src emacs-lisp :tangle yes
(setq lsp-ui-sideline-enable t)
(setq lsp-ui-sideline-show-diagnostics t)
#+end_src

Eldoc (информация по объекту в строке состояния).

#+begin_src emacs-lisp :tangle yes
(setq lsp-eldoc-enable-hover t)
#+end_src

Modeline diagnostics statistics (показ числа ошибок в строке состояния).

#+begin_src emacs-lisp :tangle yes
(setq lsp-modeline-diagnostics-enable t)
#+end_src

Signature help (показ типа объекта внизу экрана).

#+begin_src emacs-lisp :tangle yes
(setq lsp-signature-auto-activate '(:on-trigger-char :on-server-request))   ;; you could manually request them via `lsp-signature-activate
#+end_src

Signature help documentation (keep the signatures) (показ текста документации по объекту внизу экрана).

#+begin_src emacs-lisp :tangle yes
(setq lsp-signature-render-documentation t)
#+end_src

Completion (company-mode) (автодополнение с выпадашкой).

#+begin_src emacs-lisp :tangle yes
(setq lsp-completion-provider :capf)
#+end_src

Completion item detail (детали в выпадашке автодополнения).

#+begin_src emacs-lisp :tangle yes
(setq lsp-completion-show-detail t)
#+end_src

Completion item kind (тип объекта в выпадашке автодополнения).

#+begin_src emacs-lisp :tangle yes
(setq lsp-completion-show-kind t)
#+end_src

** Клавиши для работы

Повесим всплывающую подсказку на клавишу Enter, а в минибуфере - на "K".
Удаление минибуфера с подсказкой тоже удобно сделать по той же
клавише, что и ее вызов.

#+begin_src emacs-lisp :tangle yes
(defun my/eldoc ()
    (interactive)
    (if-let (eldoc-window (get-buffer-window "*eldoc*"))
        (delete-window eldoc-window)
        (eldoc t)))

(my/evil-define-key 'normal 'prog-mode-map
    "RET" #'lsp-ui-doc-show
    "K" #'my/eldoc)
#+end_src

Добавим ставшую привычной из Doom навигацию по коду.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'prog-mode-map
               "c" '(:ignore t :which-key "code"))
(my/leader-def nil 'prog-mode-map
               "c d" '(lsp-find-definition :which-key "Jump to definition")
               "c D" '(lsp-find-references :which-key "Jump to references"))
#+end_src

* Программирование

** Подсказки компилятору для обработки org-babel блоков
   :PROPERTIES:
   :ID:       cb53569d-930e-42f1-925b-8c3b660f9c4d
   :END:

Подскажем редактору, как обрабатывать org-babel блоки.
Здесь дружим org-babel со всеми установленными языками.

(!) Но прежде чем дружить блоки с языками, надо загрузить сответствующую
поддержку ob-блоков. Подгрузку смотри в [[id:c98e419e-f7e9-456d-b8f3-5037f0af775b][разделе]] главы Org.

#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (plantuml . t)
     (python . t)
     (haskell . t)
     (rust . t)))
#+end_src

** Навигация по ошибкам

Запилим горячие клавиши для перемещения по ошибкам на основе flycheck.

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'override
    "e p" '(flycheck-previous-error :which-key "Jump to previous error")
    "e n" '(flycheck-next-error :which-key "Jump to next error"))
#+end_src

** Markdown

Устанавливаем пакеты для поддержки markdown.

#+begin_src emacs-lisp :tangle yes
(use-package markdown-toc
	:ensure t)
#+end_src

#+RESULTS:

Для markdown-файлов нужен просмотр. Сделаем его через утилиту
=retext=. Утилита хороша тем, что в режиме просмотра тут же
перерисовывает содержимое при изменениях в исходном файле. Это
особенно удобно при работе в плиточных оконных менеджерах.

Устанавливаем утилиту =retext= так:

#+begin_example bash
sudo apt install retext
#+end_example

Пишем код для предпросмотра markdown-файлов.

#+begin_src emacs-lisp :tangle yes
(defun my/markdown-preview-file ()
    "Preview a markdown file by `retext' utilite."
    (interactive)
    (start-process "Markdown-Preview-by-Retext"
                   "*markdown-retext-preview*"
                   "retext" "--preview" (buffer-file-name)))
                   ;; "retext" "--preview" (shell-quote-argument (buffer-file-name))))  ; Оставлено для памяти.
#+end_src

Вешаем предпросмотр на горячие клавиши.

#+begin_src emacs-lisp :tangle yes
;; (eval-after-load 'markdown-mode
;; 	'(evil-define-key nil markdown-mode-map (my/kbd-localleader "p") #'my/markdown-preview-file))

(my/localleader-def nil 'markdown-mode-map
    "p" #'my/markdown-preview-file)

#+end_src

** Yaml

Подсветка yaml-файлов.

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
    :ensure t)
#+end_src

** Json

#+begin_src emacs-lisp :tangle yes
(use-package json-mode
    :ensure t)
#+end_src   

** Make

#+begin_src emacs-lisp :tangle yes
(require 'make-mode)
#+end_src

** Vimrc

#+begin_src emacs-lisp :tangle yes
(use-package vimrc-mode
    :ensure t)
#+end_src

** PlantUML

Загружаем пакеты для поддержки Plantuml.
По-умолчанию на выходе стоит "svg"-файл (есть еще "png" и "txt").
Это неудобно для темных тем, поскольку все буквы идут черным цветом.
Перейдем на "png" по-умолчанию.

#+begin_src emacs-lisp :tangle yes
(use-package plantuml-mode
    :ensure t
    :init
    (let ((jar-path (concat user-emacs-directory "/.local/plantuml.jar")))
        (setq plantuml-jar-path jar-path
              org-plantuml-jar-path jar-path))
    :config
    (setq plantuml-default-exec-mode
          (cond ((file-exists-p plantuml-jar-path) 'jar)
                ((executable-find "plantuml") 'executable)
                (plantuml-default-exec-mode)))
    (plantuml-set-output-type "png"))
#+end_src

Подгрузим автоматом jar-файл.

#+begin_src emacs-lisp :tangle yes
(unless (file-exists-p plantuml-jar-path)
    (plantuml-download-jar))
#+end_src

Горячая клавиша для автодополнения.

#+begin_src emacs-lisp :tangle yes
(my/evil-define-key 'insert 'plantuml-mode-map
               "TAB" #'plantuml-complete-symbol)
#+end_src

Горячая клавиша для показа диаграмы в вертикально разделенной половине окна.

#+begin_src emacs-lisp :tangle yes
(defun my/plantuml-preview ()
    (interactive)
    (save-excursion
        (plantuml-preview 4)
        ;; (plantuml-preview-current-block 4)
        ;; (doom/escape)
        ))

(my/evil-define-key 'normal 'plantuml-mode-map
                    "RET" #'my/plantuml-preview)
#+end_src

UTF-8 - наше всё! :)

#+begin_src emacs-lisp :tangle yes
(add-to-list 'org-babel-default-header-args:plantuml
             '(:cmdline . "-charset utf-8"))
#+end_src

Настроим параметр :file для plantuml-блоков по-умолчанию. Если параметр
:file не указан, то создаем временный файл с картинкой (для этого есть
функция =org-babel-temp-file=). Это нужно для рисования схем и
картинок без лишних телодвижений.

#+begin_src emacs-lisp :tangle yes
(defun my/org-babel-execute:plantuml (func &rest args)
    (let* ((body (car args))
           (params (cadr args))
           (out-file-p (cdr (assq :file params)))
           (out-file (or out-file-p
                         (org-babel-temp-file "plantuml-" ".png")))
           (new-params (if out-file-p
                           params
                           (cons `(:file . ,out-file) params)))
           (result (apply func (list body new-params))))
        (if out-file-p
            result
            out-file)))

(advice-add #'org-babel-execute:plantuml
            :around #'my/org-babel-execute:plantuml)
#+end_src

** Python

Установим основные пакеты. Какие-то будут впрок.

/Шпаргалка:/
:   - if doom-module:+pyright
:     - doom-package:lsp-pyright

#+begin_src emacs-lisp :tangle yes
(use-package python
    :ensure t)
(use-package python-mode
    :ensure t)
(use-package pipenv
    :ensure t)
(use-package pip-requirements
    :ensure t)
(use-package pyvenv
    :ensure t
    :config
    (add-hook 'python-mode-local-vars-hook #'pyvenv-track-virtualenv)
    (add-to-list 'global-mode-string
                 '(pyvenv-virtual-env-name (" venv:" pyvenv-virtual-env-name " "))
                 'append))
(use-package pyenv-mode
    :ensure t)
(use-package pyimport
    :ensure t)
(use-package py-isort
    :ensure t)
(use-package python-pytest 
    :ensure t)
#+end_src

Путь к настройкам линтера PyLint.

#+begin_src emacs-lisp :tangle yes
(setq flycheck-pylintrc (list "pylintrc"
                              ".pylintrc"
                              ;; "pyproject.toml"
                              "setup.cfg"
                              (concat (getenv "HOME") "/.config/pylintrc")))
#+end_src

Путь к настройкам линтера flake8.

#+begin_src emacs-lisp :tangle yes
(setq flycheck-flake8rc (list ".flake8"
                              "setup.cfg"
                              "tox.ini"
                              (concat (getenv "HOME") "/.config/flake8")))
#+end_src

Путь к настройкам линтера mypy.

#+begin_src emacs-lisp :tangle yes
(setq flycheck-python-mypy-config (list "mypy.ini"
                                        ;; "pyproject.toml"
                                        "setup.cfg"
                                        (concat (getenv "HOME") "/.config/mypy/config")))
#+end_src

Настройка LSP сервера. Ориентируемся на Pyright, он более устойчивый и
легковесный, чем Mspyls.

Pyright может не скачаться с серверов, поэтому при удачной попытке его
лучше сохранить. Лежит сервер в директории
: ~/.emacs.d/.cache/lsp/npm/pyright

Устанавливаем pyright из архива в репозитории (ибо пакет =lsp-pyright=
уже не тянется).

#+begin_src emacs-lisp :tangle yes
(unless (file-exists-p (concat user-emacs-directory
                               "/.cache/lsp/npm/pyright"))
    (shell-command (concat "tar -xzf "
                           my/config-dir
                           "/lsp-saves/pyright_vanilla.tar.gz "
                           "-C " user-emacs-directory)))
#+end_src

Настраиваем активацию LSP-сервера.

#+begin_src emacs-lisp :tangle yes
(add-hook 'python-mode-hook
          (lambda ()
              (unless (equal (buffer-file-name)
                             (my/calculator--get-python-filename))
                  (require 'lsp-pyright)
                  (lsp))))  ; or lsp-deferred
#+end_src

У сервера есть *проблема*: Ошибка в буфере *stderr* имеет следующее описание:
: Process terminated. Couldn't find a valid ICU package installed on the
: system. Set the configuration flag System.Globalization.Invariant to
: true if you want to run with no globalization support.
И лечится установкой где-нибудь в [[/etc/profile]] переменной:
: export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1

Теперь устанавливаем сам сервер.

#+begin_src emacs-lisp :tangle yes
(lsp-ensure-server 'pyright)
#+end_src

** Python. Pyvenv

Если работаем в одном демоне с несколькими проектами, то удобно будет
иметь быструю менюшку для выбора ранее открытых виртуальных
сред. Запилим такую.

Для начала повесим обвязку на pyvenv-activate.

#+begin_src emacs-lisp :tangle yes
(setq my/pyvenv-activated-paths (make-hash-table :test 'equal))

(defun my/pyvenv-activate-path-saver (func &rest args)
    (let ((path (car args)))
        (puthash path nil my/pyvenv-activated-paths)
        (apply func args)))

(advice-add 'pyvenv-activate :around #'my/pyvenv-activate-path-saver)
#+end_src

Один /важный момент/ с пакетом =Conda=! Ему тоже надо накидывать путь
в виртуальную среду, и тогда он будет видеть ее объекты! Запилим для
этого собственную функцию активации виртуальной среды.

#+begin_src emacs-lisp :tangle yes
(defun my/pyvenv-activate (directory)
    (interactive (list (read-directory-name "Activate venv: " nil nil nil
                                            pyvenv-default-virtual-env-name)))
    (setq directory (expand-file-name directory))
    (pyvenv-activate directory)
    (when (fboundp 'conda-env-activate-path)
        (conda-env-activate-path directory)))
#+end_src

Теперь сделаем выбор из ранее открытых директорий виртуальных сред.
Сделаем попытку подтянуть наверх пути из текущего проекта.

#+begin_src emacs-lisp :tangle yes
(defun my/pyvenv-select-path ()
    "Select one of opened Python virtual environment paths."
    (interactive)
    (if (= 0 (hash-table-count my/pyvenv-activated-paths))
            (message "The history of Pyvenv activating is empty.")
        (let ((path (ivy-read "Select Python virtual environment path:"
                              (my/--sort-pyvenv-paths my/pyvenv-activated-paths
                                                      (projectile-project-root)))))
            (unless (string-empty-p path)
                (pyvenv-activate path)
                (when (fboundp 'conda-env-activate-path)
                    (conda-env-activate-path path))
                (message (format "Pyvenv is activated: %s" path))))))

(defun my/--sort-pyvenv-paths (paths-hashmap path-prefix)
    (let ((ensured-prefix (if path-prefix path-prefix ""))
          (with-prefix)
          (without-prefix)
          (result))
        (maphash (lambda (key val)
                     (if (string-search ensured-prefix key)
                             (setq with-prefix (cons key with-prefix))
                         (setq without-prefix (cons key without-prefix))))
                 paths-hashmap)
        (mapc (lambda (path)
                  (setq result (cons path result)))
              without-prefix)
        (mapc (lambda (path)
                  (setq result (cons path result)))
              with-prefix)
        result))
#+end_src

И горячие клавиши на активацию и на выбор путей:

#+begin_src emacs-lisp :tangle yes
(my/leader-def nil 'python-mode-map
               "e" '(:ignore t :which-key "env")
               "e a" #'my/pyvenv-activate
               "e i" #'my/pyvenv-select-path)
#+end_src

** Haskell

Устанавливаем пакет для Haskell и поддержку LPS для него.

#+begin_src emacs-lisp :tangle yes
(use-package haskell-mode
    :ensure t)
(use-package lsp-haskell
    :ensure t
    :config
    (add-hook 'haskell-mode-hook #'lsp)
    (add-hook 'haskell-literate-mode-hook #'lsp)
    ;; (customize-group 'lsp-haskell)
    )
#+end_src

#+RESULTS:

Для org-mode удобно раз и навсегда включить полезные расширения языка.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'haskell-process-args-ghci "-XDuplicateRecordFields")
(add-to-list 'haskell-process-args-ghci "-XOverloadedStrings")
(add-to-list 'haskell-process-args-ghci "-XDeriveGeneric")
(add-to-list 'haskell-process-args-ghci "-package aeson")
#+end_src

Автоотступы. Ставим четверки вместо двоек.

#+begin_src emacs-lisp :tangle yes
(setq haskell-indentation-starter-offset 4
      haskell-indentation-where-pre-offset 4
      haskell-indentation-left-offset 4
      haskell-indentation-where-post-offset 4
      haskell-indentation-layout-offset 4)
#+end_src

** Rust

(!) Чтобы заработал LSP-сервер для Rust,
необходимо установить утилиту =rust-analyzer=:
: sudo pacman -S rust-analyzer

Много полезных настроек можно посмотреть тут:
[[https://robert.kra.hn/posts/rust-emacs-setup/][Configuring Emacs for Rust development]].

Устанавливаем необходимые пакеты. (Все есть в одном пакете rustic, а
ob-rust для работы с org-babel блоками устанавливается [[id:c98e419e-f7e9-456d-b8f3-5037f0af775b][выше]]).

#+begin_src emacs-lisp :tangle yes
(use-package rustic
    :ensure t)
#+end_src
